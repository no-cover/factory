(function(window){window.webapis=window.webapis||{};var ppPluginCount=0;function PepperPlugin(name){this.name=name;var pluginID="_ppapi_plugin_"+name+"_"+(ppPluginCount++);var plugin=document.createElement("EMBED");plugin.id="_ppapi_plugin_"+name+"_div";plugin.type="application/x-ppapi-"+name;plugin.style.position="absolute";plugin.style.left="0px";plugin.style.top="0px";plugin.style.width="0px";plugin.style.height="0px";document.body.appendChild(plugin);this.elPlugin=plugin;this.messageHandlers={};this.listenerHandlers={};this.registerCount=0;this.elPlugin.addEventListener('message',this.handleMessage.webapiBind(this),true);}PepperPlugin.prototype.handleMessage=function(message){if(typeof message.data=="undefined"){console.log("[webapi.js] message.data is undefined. ");return;}var msgData=message.data;if(typeof msgData.command!="undefined")if(typeof msgData.callId!="undefined"){var cbArr=this.getCallbacksById(msgData.command,msgData.callId);console.log("[webapi.js]Have callId cbArr length: "+cbArr.length+", then remove Callback!");this.removeCallbackById(msgData.command,msgData.callId);for(var i=0;i<cbArr.length;i++)cbArr[i].call(this,message);}else{var cbArr=this.getCallbacksByCommand(msgData.command);console.log("[webapi.js] cbArr length: "+cbArr.length+", then remove Callback!");this.removeCallbacksByCommand(msgData.command);for(var i=0;i<cbArr.length;i++)cbArr[i].call(this,message);}else if(typeof msgData.event!="undefined"){var eventArr=this.getListenersByEvent(msgData.event);console.log("[webapi.js] eventArr length: "+eventArr.length);for(var i=0;i<eventArr.length;i++)eventArr[i].call(this,message);}else console.log("[webapi.js] unknown message type.");};PepperPlugin.prototype.handleMessage.webapiBind=function(oThis){if(typeof this!=="function")throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var aArgs=Array.prototype.slice.call(arguments,1),fToBind=this,fNOP=function(){},fBound=function(){return fToBind.apply(this instanceof fNOP&&oThis?this:oThis,aArgs.concat(Array.prototype.slice.call(arguments)));};fNOP.prototype=this.prototype;fBound.prototype=new fNOP();return fBound;};PepperPlugin.prototype.postMessage=function(cmdObj,callback){var cbId=this.registerCallback(cmdObj.command,callback);cmdObj.callId=cbId;this.elPlugin.postMessage(cmdObj);return cbId;};PepperPlugin.prototype.postMessageAndAwaitResponse=function(cmdObj){try{return this.elPlugin.postMessageAndAwaitResponse(cmdObj);}catch(e){console.log("[webapi.js] WebAPIException:"+e);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_SUPPORTED_ERR,"NotSupportedError","Please check dynamic library of this pepepr plugin.");return;}};PepperPlugin.prototype.registerCallback=function(command,callback){var cbId=this.registerCount++;this.messageHandlers[command]=this.messageHandlers[command]||{};this.messageHandlers[command][cbId]=callback;return cbId;};PepperPlugin.prototype.getCallbacksByCommand=function(command){var cbarr=[];if(!this.messageHandlers.hasOwnProperty(command))return false;for(var id in this.messageHandlers[command])cbarr.push(this.messageHandlers[command][id]);return cbarr;};PepperPlugin.prototype.getCallbacksById=function(command,cbId){var cbarr=[];if(!this.messageHandlers.hasOwnProperty(command))return false;for(var id in this.messageHandlers[command])if(id==cbId)cbarr.push(this.messageHandlers[command][id]);return cbarr;};PepperPlugin.prototype.removeCallbacksByCommand=function(command){if(!this.messageHandlers.hasOwnProperty(command))return false;for(var id in this.messageHandlers[command])delete this.messageHandlers[command][id];delete this.messageHandlers[command];this.messageHandlers[command]=null;return true;};PepperPlugin.prototype.removeCallbackById=function(command,cbId){if(!this.messageHandlers.hasOwnProperty(command))return;for(var id in this.messageHandlers[command])if(id==cbId){delete this.messageHandlers[command][id];return true;}return false;};var listenerCount=0;PepperPlugin.prototype.addListener=function(event,listener){var cbId=listenerCount++;this.listenerHandlers[event]=this.listenerHandlers[event]||{};this.listenerHandlers[event][cbId]=listener;return cbId;};PepperPlugin.prototype.getListenersByEvent=function(event){var cbarr=[];if(!this.listenerHandlers.hasOwnProperty(event))return false;for(var id in this.listenerHandlers[event])cbarr.push(this.listenerHandlers[event][id]);return cbarr;};PepperPlugin.prototype.getListenerById=function(event,cbId){var cbarr=[];if(!this.listenerHandlers.hasOwnProperty(event))return false;for(var id in this.listenerHandlers[event])if(id==cbId)cbarr.push(this.listenerHandlers[event][id]);return cbarr;};PepperPlugin.prototype.removeListenersByEvent=function(event){if(!this.listenerHandlers.hasOwnProperty(event))return false;for(var id in this.listenerHandlers[event])delete this.listenerHandlers[event][id];delete this.listenerHandlers[event];this.listenerHandlers[event]=null;return true;};PepperPlugin.prototype.removeListenerById=function(event,cbId){if(!this.listenerHandlers.hasOwnProperty(event))return;for(var id in this.listenerHandlers[event])if(id==cbId){delete this.listenerHandlers[event][id];return true;}return false;};var pepperPlugins={};function getPepperPlugin(name){if(pepperPlugins[name])return pepperPlugins[name];pepperPlugins[name]=new PepperPlugin(name);return pepperPlugins[name];}if(window.webapis._getPepperPlugin==null||window.webapis._getPepperPlugin==undefined){Object.defineProperty(window.webapis,"_getPepperPlugin",{value:getPepperPlugin});function enumCheckerObj(objEnum,value){for(var key in objEnum)if(objEnum[key]===value)return true;return false;}Object.defineProperty(window.webapis,"_enumCheckerObj",{value:enumCheckerObj});function enumCheckerArray(arrEnum,value){for(var i=0;i<arrEnum.length;i++)if(arrEnum[i]===value)return true;return false;}Object.defineProperty(window.webapis,"_enumCheckerArray",{value:enumCheckerArray});function typeChecker(type,value){switch(type){case "DOMString":return typeof value==="string";break;case "long":case "short":case "float":case "double":return !isExactNaN(value)&&typeof value==="number";break;case "boolean":return typeof value==="boolean";break;case "function":return typeof value==="function";break;}}Object.defineProperty(window.webapis,"_checkTypeValid",{value:typeChecker});var debug;var platformVersion;function isDebug(obj){if(debug===undefined){var internal=webapis._getPepperPlugin('appcommon');var message=internal.postMessageAndAwaitResponse({command:"isDebug"});if(message.code==0){debug=message.data;console.log("firmware is "+(debug?"debug":"not debug"));}}return debug;}function getPlatformVersion(obj){if(platformVersion===undefined){var internal=webapis._getPepperPlugin('appcommon');var message=internal.postMessageAndAwaitResponse({command:"getPlatformVersion"});if(message.code==0){platformVersion=message.data;console.log("Tizen version is "+platformVersion);}}return platformVersion;}function createFalsyAlert(obj){if(isDebug()&&("6.0"<=getPlatformVersion()))switch(obj){case false:case 0:alert("If webapis has falsy(false, 0) value for optional function, please remove it");break;}}Object.defineProperty(window.webapis,"_createFalsyAlert",{value:createFalsyAlert});function isExactNaN(obj){return isNaN(obj)==true&&typeof value==="number";}function isNullOrUndefined(obj){if("6.0"<=getPlatformVersion())return obj===null||obj===undefined;else return obj===false||obj===0||obj===null||obj===undefined||isExactNaN();}Object.defineProperty(window.webapis,"_isNullOrUndefined",{value:isNullOrUndefined});function WebAPIException(){}WebAPIException.INDEX_SIZE_ERR=1;WebAPIException.DOMSTRING_SIZE_ERR=2;WebAPIException.HIERARCHY_REQUEST_ERR=3;WebAPIException.WRONG_DOCUMENT_ERR=4;WebAPIException.INVALID_CHARACTER_ERR=5;WebAPIException.NO_DATA_ALLOWED_ERR=6;WebAPIException.NO_MODIFICATION_ALLOWED_ERR=7;WebAPIException.NOT_FOUND_ERR=8;WebAPIException.NOT_SUPPORTED_ERR=9;WebAPIException.INUSE_ATTRIBUTE_ERR=10;WebAPIException.INVALID_STATE_ERR=11;WebAPIException.SYNTAX_ERR=12;WebAPIException.INVALID_MODIFICATION_ERR=13;WebAPIException.NAMESPACE_ERR=14;WebAPIException.INVALID_ACCESS_ERR=15;WebAPIException.VALIDATION_ERR=16;WebAPIException.TYPE_MISMATCH_ERR=17;WebAPIException.SECURITY_ERR=18;WebAPIException.NETWORK_ERR=19;WebAPIException.ABORT_ERR=20;WebAPIException.URL_MISMATCH_ERR=21;WebAPIException.QUOTA_EXCEEDED_ERR=22;WebAPIException.TIMEOUT_ERR=23;WebAPIException.INVALID_NODE_TYPE_ERR=24;WebAPIException.DATA_CLONE_ERR=25;WebAPIException.INVALID_VALUES_ERR=26;WebAPIException.IO_ERR=27;WebAPIException.SERVICE_NOT_AVAILABLE_ERR=28;WebAPIException.UNKNOWN_ERR=9999;Object.defineProperty(window.webapis,"WebAPIException",{value:WebAPIException});function createWebAPIException(code,name,message){var webAPIException=new WebAPIException();Object.defineProperty(webAPIException,"code",{value:parseInt(code,0)});Object.defineProperty(webAPIException,"name",{value:name+""});Object.defineProperty(webAPIException,"message",{value:message+""});return webAPIException;}function createWebAPIError(code,name,message){var obj={};Object.defineProperty(obj,"code",{value:parseInt(code,0)});Object.defineProperty(obj,"name",{value:name+""});Object.defineProperty(obj,"message",{value:message+""});return obj;}Object.defineProperty(window.webapis,"_createWebAPIException",{value:createWebAPIException});Object.defineProperty(window.webapis,"_createWebAPIError",{value:createWebAPIError});}var Type=function(){};Type.prototype.isBoolean=function(obj){return typeof obj==='boolean';};Type.prototype.isObject=function(obj){return null!==obj&&typeof obj==='object'&&!this.isArray(obj);};Type.prototype.isArray=function(obj){return Array.isArray(obj);};Type.prototype.isFunction=function(obj){return typeof obj==='function';};Type.prototype.isNumber=function(obj){return typeof obj==='number';};Type.prototype.isString=function(obj){return typeof obj==='string';};Type.prototype.isStringArray=function(value){return Array.isArray(value)&&value.every(this.isString);};Type.prototype.isNull=function(obj){return obj===null;};Type.prototype.isNullOrUndefined=function(obj){return obj===null||obj===undefined;};Type.prototype.isUndefined=function(obj){return obj===void 0;};Type.prototype.isA=function(obj,type){var clas=Object.prototype.toString.call(obj).slice(8,-1);return obj!==undefined&&obj!==null&&clas===type;};Type.prototype.isEmptyObject=function(obj){for(var property in obj)if(obj.hasOwnProperty(property))return false;return true;};Type.prototype.hasProperty=function(obj,prop){return prop in obj;};Type.prototype.arrayContains=function(arr,value){return arr.indexOf(value)>-1;};Type.prototype.getValues=function(obj){var ret=[];for(var key in obj)if(obj.hasOwnProperty(key))ret.push(obj[key]);return ret;};var _type=new Type();Object.defineProperty(window.webapis,"_type",{value:_type});var Converter=function(){};function _nullableGeneric(func,nullable,val,name){if(_type.isNull(val)&&nullable===true)return val;else return func.apply(null,[].slice.call(arguments,2));}function _toBoolean(val,name){if(!_type.isBoolean(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be boolean.');return val;}Converter.prototype.toBoolean=function(val,nullable,name){return _nullableGeneric(_toBoolean,nullable,val,name);};function _toLong(val,name){if(!_type.isNumber(val)||isNaN(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be long.');return val;}Converter.prototype.toLong=function(val,nullable,name){return _nullableGeneric(_toLong,nullable,val,name);};function _toString(val,name){if(!_type.isString(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be string.');return val;}Converter.prototype.toString=function(val,nullable,name){return _nullableGeneric(_toString,nullable,val,name);};function _toFunction(val,name){if(!_type.isFunction(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be function.');return val;}Converter.prototype.toFunction=function(val,nullable,name){return _nullableGeneric(_toFunction,nullable,val,name);};function _toArray(val,name){if(!_type.isArray(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be array.');return val;}Converter.prototype.toArray=function(val,nullable,name){return _nullableGeneric(_toArray,nullable,val,name);};function _toDictionary(val,name){if(_type.isObject(val)||_type.isFunction(val))return val;throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be dictionary.');}Converter.prototype.toDictionary=function(val,nullable,name){return _nullableGeneric(_toDictionary,nullable,val,name);};function _toEnum(val,name,e){if(_type.arrayContains(e,val))return val;throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Cannot convert '+val+' to enum.');}Converter.prototype.toEnum=function(val,e,nullable,name){return _nullableGeneric(_toEnum,nullable,val,name,e);};function _toAttribute(val,name,e){if(_type.arrayContains(e,val))return val;if(!isExactNaN(val)&&typeof val==="number")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError",'Cannot convert '+val+' to attribute.');throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Cannot convert '+val+' to attribute.');}Converter.prototype.toAttribute=function(val,e,nullable,name){return _nullableGeneric(_toAttribute,nullable,val,name,e);};function _toPlatformObject(val,name,types){var t;if(_type.isArray(types))t=types;else t=[types];if(_type.isArray(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Cannot convert '+String(val)+' to '+String(t[0].name)+'.');var match=false;for(var i=0;i<t.length;++i)if(val instanceof t[i])return val;throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Cannot convert '+String(val)+' to '+String(t[0].name)+'.');}Converter.prototype.toPlatformObject=function(val,types,nullable,name){return _nullableGeneric(_toPlatformObject,nullable,val,name,types);};var _converter=new Converter();var Validator=function(){this.Types={BOOLEAN:'BOOLEAN',LONG:'LONG',STRING:'STRING',FUNCTION:'FUNCTION',ARRAY:'ARRAY',DICTIONARY:'DICTIONARY',ENUM:'ENUM',ATTRIBUTE:'ATTRIBUTE',LISTENER:'LISTENER',PLATFORM_OBJECT:'PLATFORM_OBJECT'};};Validator.prototype.validateArgs=function(a,d){var args={has:{}};for(var i=0;i<d.length;++i){var name=d[i].name;args.has[name]=i<a.length;var optional=d[i].optional;var nullable=d[i].nullable;var val=a[i];if(args.has[name]||!optional){var type=d[i].type;var values=d[i].values;switch(type){case this.Types.BOOLEAN:val=_converter.toBoolean(val,nullable,name);break;case this.Types.LONG:val=_converter.toLong(val,nullable,name);break;case this.Types.STRING:val=_converter.toString(val,nullable,name);break;case this.Types.FUNCTION:val=_converter.toFunction(val,nullable,name);break;case this.Types.ARRAY:val=_converter.toArray(val,nullable,name);if(!_type.isNull(val)&&values){var func;switch(values){case this.Types.BOOLEAN:func=_converter.toBoolean;break;case this.Types.LONG:func=_converter.toLong;break;case this.Types.STRING:func=_converter.toString;break;default:func=function(val){if(!(val instanceof values))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Items of array '+name+'should be of type: '+values+'.');return val;};}for(var j=0;j<val.length;++j)val[j]=func(val[j],nullable,name);}break;case this.Types.DICTIONARY:val=_converter.toDictionary(val,nullable,name);break;case this.Types.ENUM:val=_converter.toEnum(val,values,nullable,name);break;case this.Types.ATTRIBUTE:val=_converter.toAttribute(val,values,nullable,name);break;case this.Types.LISTENER:if(_type.isNull(val)){if(!nullable)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' cannot be null.');}else{if(!_type.isObject(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Argument '+name+' should be an object.');for(var ii=0;ii<values.length;++ii)if(_type.hasProperty(val,values[ii]))val[values[ii]]=_converter.toFunction(val[values[ii]],false,name+"["+values[ii]+"]");}break;case this.Types.PLATFORM_OBJECT:val=_converter.toPlatformObject(val,values,nullable,name);break;default:throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError",'Unknown type: '+type+'.');}var _validator=d[i].validator;if(_type.isFunction(_validator)&&!_validator(val))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,'Argument '+name+' did not pass additional validation.');args[name]=val;}}return args;};Validator.prototype.isConstructorCall=function(obj,instance){if(!(obj instanceof instance)||obj._previouslyConstructed)throw new WebAPIException('TypeError','Constructor cannot be called as function.');Object.defineProperty(obj,'_previouslyConstructed',{value:true,writable:false,enumerable:false});};Validator.prototype.validateConstructorCall=function(obj,instance){this.isConstructorCall(obj,instance);};var _validator=new Validator();Object.defineProperty(window.webapis,"_validator",{value:_validator});})(this);(function(window){var MOD_NAME="AppCommon";var INSTANTIATED_NAMESPACE="appcommon";var PEPPER_PLUGIN_NAME="appcommon";var registerkeyMap={"Power":{keyName:"XF86PowerOff",keyCode:409},"SmartHub":{keyName:"XF86Home",keyCode:10071},"PMODE":{keyName:"XF86PictureMode",keyCode:10141},"More":{keyName:"XF86More",keyCode:10148},"Sleep":{keyName:"XF86Sleep",keyCode:10150},"BTPairing":{keyName:"XF86BTPairing",keyCode:10161},"LFDPowerOff":{keyName:"XF86LFDPowerOff",keyCode:10120},"DiscretPowerOff":{keyName:"XF86DiscretPowerOff",keyCode:10360},"DiscretPowerOn":{keyName:"XF86DiscretPowerOn",keyCode:10361},"SMODE":{keyName:"XF86SoundMode",keyCode:10197},"BTVoice":{keyName:"XF86BTVoice",keyCode:10224},"BTFarVoice":{keyName:"XF86KeyBtFarVoice",keyCode:10538},"Color":{keyName:"XF86Color",keyCode:10385},"Alarm":{keyName:"XF86Alarm",keyCode:10418},"MultiView":{keyName:"XF86MultiView",keyCode:10505},"AccessibilityShortcut":{keyName:"XF86AccessibilityShortcut",keyCode:10364},"LearnRemote":{keyName:"XF86LearnRemote",keyCode:10588},"QuickAccess":{keyName:"XF86QuickAccess",keyCode:10591},"STBPower":{keyName:"XF86STBPower",keyCode:10487},"CCOnOff":{keyName:"XF86CCOnOff",keyCode:10616},"VoiceGuide":{keyName:"XF86VoiceGuide",keyCode:10093},"CCDivision":{keyName:"XF86CCDivision",keyCode:10097},"SignLanguageZoom":{keyName:"XF86SignLanguageZoom",keyCode:10103},"SignLanguageZoomPlus":{keyName:"XF86SignLanguageZoomPlus",keyCode:10121},"SignLanguageZoomMinus":{keyName:"XF86SignLanguageZoomMinus",keyCode:10122},"CCPreset":{keyName:"XF86CCPreset",keyCode:10123},"CCPosition":{keyName:"XF86CCPosition",keyCode:10132},"CCSize":{keyName:"XF86CCSize",keyCode:10136},"VGBackground":{keyName:"XF86VGBackground",keyCode:10251},"CurrentTime":{keyName:"XF86CurrentTime",keyCode:10254},"VoiceGender":{keyName:"XF86VoiceGender",keyCode:10255},"VoicePitch":{keyName:"XF86VoicePitch",keyCode:10256},"VoiceSpeed":{keyName:"XF86VoiceSpeed",keyCode:10362},"UserGuideAccessibility":{keyName:"XF86UserGuideAccessibility",keyCode:10363},"CCColor":{keyName:"XF86CCColor",keyCode:10395},"HighContrast":{keyName:"XF86KeyHighContrast",keyCode:10584},"Enlarge":{keyName:"XF86KeyEnlarge",keyCode:10585},"VisualImpaired":{keyName:"XF86VisualImpaired",keyCode:10601},"RotatePanel":{keyName:"XF86KeyRotatePanel",keyCode:10569},"TVPlus":{keyName:"XF86KeyTVPlus",keyCode:10568},"Globo":{keyName:"XF86KeyGlobo",keyCode:10510},"Zee5":{keyName:"XF86KeyZee5",keyCode:10509},"Ambient":{keyName:"XF86Ambient",keyCode:10530},"AmbientLong":{keyName:"XF86KeyAmbientLong",keyCode:10535},"HDMI":{keyName:"XF86Hdmi",keyCode:10143},"TV":{keyName:"XF86TV",keyCode:10153},"PanelDown":{keyName:"XF86PanelDown",keyCode:10157},"PanelEnter":{keyName:"XF86PanelEnter",keyCode:10171},"PanelUp":{keyName:"XF86PanelUp",keyCode:10173},"PanelExit":{keyName:"XF86PanelExit",keyCode:10181},"PanelPlus":{keyName:"XF86PanelPlus",keyCode:10223},"PanelMinus":{keyName:"XF86PanelMinus",keyCode:10227},"Netflix":{keyName:"XF86Netflix",keyCode:10234},"Amazon":{keyName:"XF86Amazon",keyCode:10229},"WebBrowser":{keyName:"XF86WWW",keyCode:10158},"Hulu":{keyName:"XF86LaunchApp1",keyCode:10507},"RakutenTV":{keyName:"XF86LaunchApp2",keyCode:10508},"HotelMovies":{keyName:"XF86HotelMovies",keyCode:10494},"HotelLanguage":{keyName:"XF86HotelLanguage",keyCode:10495},"HotelTVGuide":{keyName:"XF86HotelTVGuide",keyCode:10496},"Content":{keyName:"XF86HotelAppsGuest",keyCode:10497},"NoiseReduction":{keyName:"XF86NoiseReduction",keyCode:10519},"Help":{keyName:"XF86Help",keyCode:10520},"HotelRoomControl":{keyName:"XF86HotelRoomControl",keyCode:10522},"NR":{keyName:"XF86NR",keyCode:10521},"PanelPower":{keyName:"XF86PanelPower",keyCode:10531},"PanelSource":{keyName:"XF86PanelSource",keyCode:10532},"PanelMenu":{keyName:"XF86PanelMenu",keyCode:10533},"MBRMenu":{keyName:"XF86MBRMenu",keyCode:10237},"MBRBDPopup":{keyName:"XF86MBRBDPopup",keyCode:10185},"RussiaCP1":{keyName:"XF86RussiaCP1",keyCode:10511},"RussiaCP2":{keyName:"XF86RussiaCP2",keyCode:10512},"RussiaCP3":{keyName:"XF86RussiaCP3",keyCode:10513},"VietnamCP":{keyName:"XF86VietnamCP",keyCode:10591},"MenaCP":{keyName:"XF86MenaCP",keyCode:10592},"Disney":{keyName:"XF86Disney",keyCode:10634},"PlayBackGame":{keyName:"XF86PlayBackGame",keyCode:10571},"Tving":{keyName:"XF86Tving",keyCode:10632},"Hotstar":{keyName:"XF86Hotstar",keyCode:10633},"Kinopoisk":{keyName:"XF86Kinopoisk",keyCode:10635},"ARKVolume":{keyName:"XF86KeyARKVolume",keyCode:10593},"AndroidMenu":{keyName:"XF86AndroidMenu",keyCode:10595},"GamepadHomekey":{keyName:"XF86GamepadHomekey",keyCode:10572}};var mandatorykeyMap={"ArrowLeft":{keyName:"Left",keyCode:37},"ArrowUp":{keyName:"Up",keyCode:38},"ArrowRight":{keyName:"Right",keyCode:39},"ArrowDown":{keyName:"Down",keyCode:40},"Enter":{keyName:"Return",keyCode:13},"Back":{keyName:"XF86Back",keyCode:10009}};var generatekeyMap={"VolumeUp":{keyName:"XF86AudioRaiseVolume",keyCode:447,xkeyCode:76},"VolumeDown":{keyName:"XF86AudioLowerVolume",keyCode:448,xkeyCode:75},"VolumeMute":{keyName:"XF86AudioMute",keyCode:449,xkeyCode:74},"ChannelUp":{keyName:"XF86RaiseChannel",keyCode:427,xkeyCode:96},"ChannelDown":{keyName:"XF86LowerChannel",keyCode:428,xkeyCode:95},"ArrowLeft":{keyName:"Left",keyCode:37,xkeyCode:113},"ArrowUp":{keyName:"Up",keyCode:38,xkeyCode:111},"ArrowRight":{keyName:"Right",keyCode:39,xkeyCode:114},"ArrowDown":{keyName:"Down",keyCode:40,xkeyCode:116},"Enter":{keyName:"Return",keyCode:13,xkeyCode:36},"Back":{keyName:"XF86Back",keyCode:10009,xkeyCode:9},"GamepadHomekey":{keyName:"XF86GamepadHomekey",keyCode:10572,xkeyCode:572},"MediaTrackPrevious":{keyName:"XF86PreviousChapter",keyCode:10232,xkeyCode:232},"MediaRewind":{keyName:"XF86AudioRewind",keyCode:10176,xkeyCode:176},"MediaTrackNext":{keyName:"XF86NextChapter",keyCode:10233,xkeyCode:233},"MediaFastForward":{keyName:"XF86AudioNext",keyCode:10216,xkeyCode:216},"Search":{keyName:"XF86Search",keyCode:10225,xkeyCode:225},"Exit":{keyName:"XF86Exit",keyCode:10182,xkeyCode:182},"Source":{keyName:"XF86Display",keyCode:10072,xkeyCode:72},"MultiView":{keyName:"XF86MultiView",keyCode:10505,xkeyCode:505},"SmartHub":{keyName:"XF86Home",keyCode:10071,xkeyCode:71},"ARKVolume":{keyName:"XF86KeyARKVolume",keyCode:10593,xkeyCode:593},"PlayBackGame":{keyName:"XF86PlayBackGame",keyCode:10571,xkeyCode:571},"More":{keyName:"XF86More",keyCode:10148,xkeyCode:148}};if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var AppCommonScreenSaverState={SCREEN_SAVER_OFF:0,SCREEN_SAVER_ON:1};var AppcommonTarget={CONFIG_LAST_SOURCE:0};var AppcommonAction={CONFIG_LAUNCH:0};var AppCommonRecommendedWordsType={RECOMMENDED_WORDS_DISABLE:0,RECOMMENDED_WORDS_ENABLE:1};var ppAppCommon=null;function TVInputDeviceKey(dict){for(var key in dict)if(dict.hasOwnProperty(key))Object.defineProperty(this,key,{value:dict[key],enumerable:true});Object.freeze(this);};function getKeyNameByName(keyName){var keyConvetName="";for(var key in registerkeyMap)if(registerkeyMap.hasOwnProperty(key))if(key==keyName){keyConvetName=registerkeyMap[key].keyName;break;}for(var key in mandatorykeyMap)if(mandatorykeyMap.hasOwnProperty(key))if(key==keyName){keyConvetName=mandatorykeyMap[key].keyName;break;}console.log("[appcommon.js]  Conver Name["+keyName+"] to keyName["+keyConvetName+"]");return keyConvetName;};function getKeyCodeByName(keyName){var keyConvetCode="";for(var key in registerkeyMap)if(registerkeyMap.hasOwnProperty(key))if(key==keyName){keyConvetCode=registerkeyMap[key].keyCode;break;}for(var key in mandatorykeyMap)if(mandatorykeyMap.hasOwnProperty(key))if(key==keyName){keyConvetCode=mandatorykeyMap[key].keyCode;break;}console.log("[appcommon.js]  Conver Name["+keyName+"] to keyCode["+keyConvetCode+"]");return keyConvetCode;};function getXKeyCodeByName(keyName){var keyConvetXKeyCode="";for(var key in generatekeyMap)if(generatekeyMap.hasOwnProperty(key))if(key==keyName){keyConvetXKeyCode=generatekeyMap[key].xkeyCode;break;}console.log("[appcommon.js] Conver Name["+keyName+"] to keyCode["+keyConvetXKeyCode+"]");return keyConvetXKeyCode;};window.webapis[INSTANTIATED_NAMESPACE]={AppCommonScreenSaverState:AppCommonScreenSaverState,AppcommonTarget:AppcommonTarget,AppcommonAction:AppcommonAction,AppCommonRecommendedWordsType:AppCommonRecommendedWordsType,getVersion:function(){ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[appcommon.js] getVersion message data "+message.data);return message.data;}else{console.log("[appcommon.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setEpopAppWindow:function(epopPosition,anyPositionMode){if(anyPositionMode&&!window.webapis._checkTypeValid("boolean",anyPositionMode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid boolean type passed for 'anyPositionMode' parameter");else if(anyPositionMode!==true)anyPositionMode=false;if(!window.webapis._checkTypeValid("long",epopPosition))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'epopPosition' parameter");else if((anyPositionMode==false)&&((epopPosition<0)||(5<=epopPosition)))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'epopPosition' parameter");var result;console.log("setEpopAppWindow post message position:"+epopPosition+" anypositionmode:"+anyPositionMode);ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"setEpopAppWindow"});if(message.code==0){if(anyPositionMode)result=widget.move(epopPosition,0);else result=widget.setQuarterPosition(epopPosition);if(result=="success"){console.log("[appcommon.js] setEpopAppWindow message data "+true);return true;}else{console.log("[appcommon.js] setEpopAppWindow error "+window.webapis.WebAPIException.UNKNOWN_ERR);throw window.webapis._createWebAPIError(window.webapis.WebAPIException.UNKNOWN_ERR,"UnknownError","Unknown system error occurred");}}else{console.log("[appcommon.js] setEpopAppWindow error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getForegroundAppId:function(){ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"getForegroundAppID"});if(message.code==0){console.log("[appcommon.js] getForegroundAppID message data "+message.data);return message.data;}else{console.log("[appcommon.js] getForegroundAppID error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setScreenSaver:function(state,onsuccess,onerror){if(!window.webapis._enumCheckerObj(AppCommonScreenSaverState,state)){if(!window.webapis._checkTypeValid("long",state))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AppCommonScreenSaverState type passed for 'state' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppCommonScreenSaverState value passed for 'state' parameter");}if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppAppCommon.postMessage({command:"setScreenSaver",onoff:state},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},getSpecialSupportedKeys:function(){var ret=[];for(var key in registerkeyMap)if(registerkeyMap.hasOwnProperty(key))ret.push(new TVInputDeviceKey({name:key,code:registerkeyMap[key].keyCode}));return ret;},registerKey:function(keyNameList){if(!Array.isArray(keyNameList))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AppCommonKeyName[] passed for 'keyNameList' parameter");else{var keyConvetName=new Array();keyNameList.forEach(function(keyName){if(registerkeyMap.hasOwnProperty(keyName))keyConvetName.push(getKeyNameByName(keyName));else if(mandatorykeyMap.hasOwnProperty(keyName))keyConvetName.push(getKeyNameByName(keyName));else{console.log("[appcommon.js] registerKey - This "+keyName+" is invalid!");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppCommonKeyName value passed for 'keyNameList' parameter");}});}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"registerKey",keyNameList:keyConvetName});if(message.code==0){console.log("[appcommon.js] registerKey message data "+message.data);return message.data;}else{console.log("[appcommon.js] registerKey error ["+message.code+"]: "+message.errorMessage);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},unregisterKey:function(keyNameList){if(!Array.isArray(keyNameList))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AppCommonKeyName[] passed for 'keyNameList' parameter");else{var keyConvetName=new Array();keyNameList.forEach(function(keyName){if(registerkeyMap.hasOwnProperty(keyName))keyConvetName.push(getKeyNameByName(keyName));else if(mandatorykeyMap.hasOwnProperty(keyName))keyConvetName.push(getKeyNameByName(keyName));else{console.log("[appcommon.js] unregisterKey - This "+keyName+" is invalid!");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppCommonKeyName value passed for 'keyNameList' parameter");}});}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"unregisterKey",keyNameList:keyConvetName});if(message.code==0){console.log("[appcommon.js] unregisterKey message data "+message.data);return message.data;}else{console.log("[appcommon.js] unregisterKey error ["+message.code+"]: "+message.errorMessage);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},generateKey:function(keyName){if(!window.webapis._checkTypeValid("DOMString",keyName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid string type passed for 'keyName' parameter");else if(generatekeyMap.hasOwnProperty(keyName))var xKeyCode=getXKeyCodeByName(keyName);else{console.log("[appcommon.js] generateKey - This "+keyName+" is invalid!");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppCommonGenerateKeyName value passed for 'keyName' parameter");}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"generateKey",xkeyCode:xKeyCode});if(message.code==0){console.log("[appcommon.js] generateKey message data "+message.data);return;}else{console.log("[appcommon.js] generateKey error ["+message.code+"]: "+message.errorMessage);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setIMERecommendedWords:function(words){if(!Array.isArray(words))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString[] passed for 'words' parameter");else words.forEach(function(word){if(!window.webapis._checkTypeValid("DOMString",word))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString[] value passed for 'words' parameter");});ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"setIMERecommendedWords",recommendedWords:words});if(message.code==0){console.log("[appcommon.js] setIMERecommendedWords message data "+message.data);return message.data;}else{console.log("[appcommon.js] setIMERecommendedWords error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setIMERecommendedWordsType:function(type){if(!window.webapis._enumCheckerObj(AppCommonRecommendedWordsType,type)){if(!window.webapis._checkTypeValid("long",type))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AppCommonRecommendedWordsType type passed for 'type' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppCommonRecommendedWordsType value passed for 'type' parameter");}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"setIMERecommendedWordsType",recommendedWordsType:type});if(message.code==0){console.log("[appcommon.js] setIMERecommendedWordsType message data "+message.data);return message.data;}else{console.log("[appcommon.js] setIMERecommendedWordsType error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},requestTvContextTask:function(target,action){if(!window.webapis._enumCheckerObj(AppcommonTarget,target)||!window.webapis._enumCheckerObj(AppcommonAction,action)){if(!window.webapis._checkTypeValid("long",target)||!window.webapis._checkTypeValid("long",action))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AppcommonTarget/AppcommonAction type passed for parameters");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AppcommonTarget/AppcommonAction value passed for parameters");}ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"requestTvContextTask",target:target,action:action});if(message.code==0){console.log("[appcommon.js] requestTvContextTask message data "+message.data);return message.data;}else{console.log("[appcommon.js] requestTvContextTask error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getUuid:function(){ppAppCommon=ppAppCommon||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAppCommon.postMessageAndAwaitResponse({command:"getUuid"});if(message.code==0){console.log("[appcommon.js] getUuid message data "+message.data);return message.data;}else{console.log("[appcommon.js] getUuid error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="DrmInfo";var INSTANTIATED_NAMESPACE="drminfo";var PEPPER_PLUGIN_NAME="drminfo";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppDrmInfo=null;var exec=function(api){console.log("[drminfo.js] "+api+"  begin");ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[drminfo.js] "+api+"  begin_01");var message=ppDrmInfo.postMessageAndAwaitResponse({command:api});console.log("[drminfo.js] "+api+"  end "+message);if(message.code==0){console.log("[drminfo.js] "+api+" message data "+message.data);return message.data;}else{console.log("[drminfo.js] "+api+"  error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};var PP_NAGRA_EVENT="PP_NAGRA_EVENT";window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){return exec("getVersion");},getSupportedKeySystems:function(){var argNum=arguments.length;if(argNum<1){ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDrmInfo.postMessageAndAwaitResponse({command:"getSupportedKeySystems"});}else if(argNum==2){ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var p0=arguments[0].toString();var p1=arguments[1].toString();var message=ppDrmInfo.postMessageAndAwaitResponse({command:"getSupportedKeySystems",keySystem:p0,param2:p1});}else{console.log("API can be called with no parameter or 2 parameters");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed");return;}if(message.code==0){console.log("[drminfo.js]  message data "+message.data);return message.data;}else{console.log("[drminfo.js] getSupportedKeySystems error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isKeySystemSupported:function(){var argNum=arguments.length;if(argNum==1){if(!window.webapis._checkTypeValid("DOMString",arguments[0])){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'KeySystem' parameter");return;}ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var p0=arguments[0].toString();var message=ppDrmInfo.postMessageAndAwaitResponse({command:"isKeySystemSupported",keySystem:p0});}else{console.log("Exactly one parameter should be passed");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed");}if(message.code==0){console.log("[drminfo.js]  message data "+message.data);return message.data;}else{console.log("[drminfo.js] isKeySystemSupported error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getEsn:function(CompName){if(!window.webapis._checkTypeValid("DOMString",CompName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'CompName' parameter");ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDrmInfo.postMessageAndAwaitResponse({command:"getEsn",compName:CompName});if(message.code==0){console.log("[drminfo.js]  message data "+message.data);return message.data;}else{console.log("[drminfo.js] error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSdiId:function(){return exec("getSdiId");},nvInvoke:function(){var argNum=arguments.length;if(argNum<1){console.log("At least one parameter is needed.");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed");return;}var cmd=arguments[0];ppDrmInfo=ppDrmInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(cmd=="nvAddEventListener"){var nvEventListener=arguments[1];if(!window.webapis._checkTypeValid("function",nvEventListener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid type passed for 'listener' parameter");var listenerId=ppDrmInfo.addListener(PP_NAGRA_EVENT,function(msg){console.log("event type :"+msg.data.data[0]+" callback param1:"+msg.data.data[1]+" param2:"+msg.data.data[2]);nvEventListener(msg.data.data[0],msg.data.data[1],msg.data.data[2]);});return listenerId;}if(cmd=="nvRemoveEventListener"){var nvEventListenerID=arguments[1];var ret=ppDrmInfo.removeListenerById(PP_NAGRA_EVENT,nvEventListenerID);if(!window.webapis._checkTypeValid("boolean",ret))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","No NAGRA event listener exist to be removed.");return ret;}var p1="";var p2="";var p3="";switch(argNum){case 4:p3=arguments[3].toString();case 3:p2=arguments[2].toString();case 2:p1=arguments[1].toString();case 1:break;default:{console.log("Input parameter number error.");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.UNKNOWN_ERR,"UNKNOWN_ERR","input parameter number error.");}}console.log("command:"+cmd+" p1:"+p1+" p2:"+p2+" p3:"+p3);var message=ppDrmInfo.postMessageAndAwaitResponse({command:"nvInvoke",compName:"NAGRA",param1:cmd,param2:p1,param3:p2,param4:p3});if(message.code==0){console.log("[drminfo.js]  message data "+message.data);return message.data;}else{console.log("[drminfo.js] error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="Logging";var INSTANTIATED_NAMESPACE="logging";var PEPPER_PLUGIN_NAME="logging";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var LoggingAgreedState={NOT_AGREED:0,AGREED:1};var ppLogging=null;window.webapis[INSTANTIATED_NAMESPACE]={LoggingAgreedState:LoggingAgreedState,isAgreedWith:function(){ppLogging=ppLogging||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppLogging.postMessageAndAwaitResponse({command:"isAgreedWith"});if(message.code==0){console.log("[logging.js] isAgreedWith message data "+message.data);return message.data;}else{console.log("[logging.js] isAgreedWith error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getVersion:function(){ppLogging=ppLogging||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppLogging.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[logging.js] getVersion message data "+message.data);return message.data;}else{console.log("[logging.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setServiceConfigInfo:function(servicename,queuemax,expiration,threshold,loglevel,serverUrl,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",servicename))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'eventName' parameter");if(!window.webapis._checkTypeValid("long",queuemax))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'queuemax' parameter");if(!window.webapis._checkTypeValid("long",expiration))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'expiration' parameter");if(!window.webapis._checkTypeValid("long",threshold))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'threshold' parameter");if(!window.webapis._checkTypeValid("long",loglevel))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'loglevel' parameter");if(!window.webapis._checkTypeValid("DOMString",serverUrl))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverUrl' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppLogging=ppLogging||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppLogging.postMessage({command:'SetServiceConfInfo',servicename:servicename,queuemax:queuemax,expiration:expiration,threshold:threshold,loglevel:loglevel,serverurl:serverUrl},function(message){var msgData=message.data;if(msgData.code==0){console.log("[SetServiceConfInfo.js] message success");onsuccess.call(null,msgData.data);}else{console.log("[SetServiceConfInfo.js] message failed");onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));}});},setEventHeader:function(modelName,userId,duid,country,privacylog,onsuccess,onerror){console.log("this api was deprecated from Tizen 5.5");},addEventLog:function(eventName,time,category,value,desc,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",eventName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'eventName' parameter");if(!window.webapis._checkTypeValid("DOMString",time))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'time' parameter");if(!window.webapis._checkTypeValid("DOMString",category))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'category' parameter");if(!window.webapis._checkTypeValid("DOMString",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'value' parameter");if(!window.webapis._checkTypeValid("DOMString",desc))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'desc' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppLogging=ppLogging||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppLogging.postMessage({command:'AddEventLog',eventname:eventName,time:time,category:category,value:value,desc:desc},function(message){var msgData=message.data;if(msgData.code==0){console.log("[AddEventLog.js] message success");onsuccess.call(null);}else{console.log("[AddEventLog.js] message failed");onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));}});},addEventFullLog:function(eventName,log,onsuccess,onerror){console.log("this api was deprecated from Tizen 5.5");},flushLog:function(onsuccess,onerror){console.log("this api was deprecated from Tizen 5.5");},addEventConfigInfo:function(eventName,queueMax,expiration,threshold,loglevel,onsuccess,onerror){console.log("this api was deprecated from Tizen 5.5");}};})(this);(function(window){var MOD_NAME="ProductInfo";var INSTANTIATED_NAMESPACE="productinfo";var PEPPER_PLUGIN_NAME="productinfo";var PRODUCTINFO_SYSTEM_CONFIG_CHANGED="PRODUCTINFO_SYSTEM_CONFIG_CHANGED";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var keylistenerArr=[];var keylistener=function(key,listenerId){this.key=key;this.listenerId=listenerId;};var _hasKeyListener=function(key){for(i=0;i<keylistenerArr.length;i++)if(keylistenerArr[i].key==key)return true;return false;};var _removeKeyListenerById=function(id){for(i=0;i<keylistenerArr.length;i++)if(keylistenerArr[i].listenerId==id){var obj=keylistenerArr[i];keylistenerArr.splice(i,1);return obj;}return null;};var PRDINFO_EVENT_SYSTEM_CONFIG_CHANGED="PRDINFO_EVENT_SYSTEM_CONFIG_CHANGED";var ProductInfoConfigKey={CONFIG_KEY_DATA_SERVICE:0,CONFIG_KEY_SERVICE_COUNTRY:1,CONFIG_KEY_SHOPLOGO:2,CONFIG_KEY_CHANNELBOUND_APPS_TICKER:3,CONFIG_KEY_SUPPORT_SOCCER_PANEL:4,CONFIG_KEY_SUPPORT_ONTV_PANEL:5,CONFIG_KEY_SUPPORT_NEWSON_PANEL:6,CONFIG_KEY_SUPPORT_MYCONTENTS_PANEL:7,CONFIG_KEY_SUPPORT_GAME_PANEL:8,CONFIG_KEY_SUPPORT_CLIPS_PANEL:9,CONFIG_KEY_SUPPORT_APPS_PANEL:10,CONFIG_KEY_SYSTEM_PNP_COUNTRY:11,CONFIG_KEY_PIN:12,CONFIG_GPMURL_KEY_ACRCT:13,CONFIG_GPMURL_KEY_AM:14,CONFIG_GPMURL_KEY_AQUA:15,CONFIG_GPMURL_KEY_APPS:16,CONFIG_GPMURL_KEY_CDS:17,CONFIG_GPMURL_KEY_CLIPS:18,CONFIG_GPMURL_KEY_EMP:19,CONFIG_GPMURL_KEY_EXPLORER3D:20,CONFIG_GPMURL_KEY_FITNESS:21,CONFIG_GPMURL_KEY_FKP:22,CONFIG_GPMURL_KEY_GAME:23,CONFIG_GPMURL_KEY_GEO:24,CONFIG_GPMURL_KEY_HA:25,CONFIG_GPMURL_KEY_HBBTV:26,CONFIG_GPMURL_KEY_IMS:27,CONFIG_GPMURL_KEY_KBO:28,CONFIG_GPMURL_KEY_KIDS:29,CONFIG_GPMURL_KEY_NOTICE:30,CONFIG_GPMURL_KEY_LC:31,CONFIG_GPMURL_KEY_MSVC:32,CONFIG_GPMURL_KEY_NCS:33,CONFIG_GPMURL_KEY_NEWSON:34,CONFIG_GPMURL_KEY_ONTV:35,CONFIG_GPMURL_KEY_PUSH:36,CONFIG_GPMURL_KEY_RM:37,CONFIG_GPMURL_KEY_SAPPHIRE:38,CONFIG_GPMURL_KEY_SAS:39,CONFIG_GPMURL_KEY_SCS:40,CONFIG_GPMURL_KEY_SEARCHALL:41,CONFIG_GPMURL_KEY_SHS:42,CONFIG_GPMURL_KEY_SOCCER:43,CONFIG_GPMURL_KEY_SSO:44,CONFIG_GPMURL_KEY_STS:45,CONFIG_GPMURL_KEY_TWITTERGW:46,CONFIG_KEY_ACCESSIBILITY_TTS:47,CONFIG_KEY_MW_MSO_CONFIG:48,CONFIG_GPMURL_KEY_EXTRA:49,CONFIG_GPMURL_KEY_MUSIC:50,CONFIG_KEY_ACTIVE_CATEGORY:51,CONFIG_KEY_MUTE:52,CONFIG_KEY_OSD_NUMBERPAD:53,CONFIG_KEY_OSD_VIRTUALREMOTE:54,CONFIG_KEY_STATUS_NETFLIX:55,CONFIG_KEY_MULTIVIEW_INFO:56,CONFIG_KEY_MULTIVIEW_STATE:57};var ProductInfoSiServerType={SI_TYPE_OPERATIING_SERVER:0,SI_TYPE_DEVELOPMENT_SERVER:1,SI_TYPE_DEVELOPING_SERVER:2};var ProductInfoNoGlass3dSupport={NO_GLASS_3D_NOT_SUPPORTED:0,NO_GLASS_3D_SUPPORTED:1};var exec=function(api){console.log("[productinfo.js] "+api+"  begin");ppPrdInfo=ppPrdInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppPrdInfo.postMessageAndAwaitResponse({command:api});console.log("[productinfo.js] "+api+"  end "+message);if(message.code==0){console.log("[productinfo.js] "+api+" message data "+message.data);return message.data;}else{console.log("[productinfo.js] "+api+"  error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};var ppPrdInfo=null;window.webapis[INSTANTIATED_NAMESPACE]={ProductInfoNoGlass3dSupport:ProductInfoNoGlass3dSupport,ProductInfoConfigKey:ProductInfoConfigKey,ProductInfoSiServerType:ProductInfoSiServerType,getVersion:function(){return exec("getVersion");},getFirmware:function(){return exec("getFirmware");},getDuid:function(){return exec("getDuid");},getModelCode:function(){return exec("getModelCode");},getModel:function(){return exec("getModel");},getSmartTVServerType:function(){return exec("getSmartTVServerType");},getSmartTVServerVersion:function(){return exec("getSmartTVServerVersion");},getTunerEpop:function(){return exec("getTunerEpop");},isUdPanelSupported:function(){return exec("isUDPanelSupported");},is8KPanelSupported:function(){return exec("is8KPanelSupported");},isSoccerModeEnabled:function(){return exec("isSoccerModeEnabled");},isTtvSupported:function(){return exec("isTtvSupported");},getNoGlass3dSupport:function(){return exec("getNoGlass3dSupport");},getLocalSet:function(){return exec("getLocalSet");},getRealModel:function(){return exec("getRealModel");},getLicensedVendor:function(){return exec("getLicensedVendor");},getSystemConfig:function(key){webapis._validator.validateArgs(arguments,[{name:'key',type:webapis._validator.Types.ATTRIBUTE,values:Object.values(ProductInfoConfigKey)}]);if((key===ProductInfoConfigKey.CONFIG_KEY_CHANNELBOUND_APPS_TICKER)||(key===ProductInfoConfigKey.CONFIG_GPMURL_KEY_MUSIC))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid ProductInfoConfigKey value passed for 'key' parameter");ppPrdInfo=ppPrdInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppPrdInfo.postMessageAndAwaitResponse({command:"getSystemConfig",key:key});if(message.code==0){if(typeof message.data!="string")message.data+="";console.log("[productinfo.js] getSystemConfig message data "+message.data);return message.data;}else{console.log("[productinfo.js] getSystemConfig error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getPsid:function(){ppPrdInfo=ppPrdInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppPrdInfo.postMessageAndAwaitResponse({command:"getPsid"});if(message.code==0){if(typeof message.data!="string")message.data+="";console.log("[productinfo.js] getPsid message data "+message.data);return message.data;}else{console.log("[productinfo.js] getPsid error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSystemConfig:function(key,value,onsuccess,onerror){webapis._validator.validateArgs(arguments,[{name:'key',type:webapis._validator.Types.ATTRIBUTE,values:Object.values(ProductInfoConfigKey)},{name:'value',type:webapis._validator.Types.STRING},{name:'onsuccess',type:webapis._validator.Types.FUNCTION,optional:true,nullable:true},{name:'onerror',type:webapis._validator.Types.FUNCTION,optional:true,nullable:true}]);if(key!=ProductInfoConfigKey.CONFIG_KEY_DATA_SERVICE&&key!=ProductInfoConfigKey.CONFIG_KEY_CHANNELBOUND_APPS_TICKER&&key!=ProductInfoConfigKey.CONFIG_KEY_ACTIVE_CATEGORY)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","key ["+key+"] is readonly");ppPrdInfo=ppPrdInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppPrdInfo.postMessage({command:"setSystemConfig",key:key,value:value},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},addSystemConfigChangeListener:function(key,listener){webapis._validator.validateArgs(arguments,[{name:'key',type:webapis._validator.Types.ATTRIBUTE,values:Object.values(ProductInfoConfigKey)},{name:'listener',type:webapis._validator.Types.FUNCTION,optional:false,nullable:false}]);if(_hasKeyListener(key)==false){ppPrdInfo=ppPrdInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppPrdInfo.postMessageAndAwaitResponse({command:"addSystemConfigChangeListener",propertyKey:key});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else console.log("[PrdInfo.js] need not registerSystemConfigKeys again, key : "+key);var listenerId=ppPrdInfo.addListener(PRODUCTINFO_SYSTEM_CONFIG_CHANGED,function(msg){if(key==msg.data.data)listener(msg.data.data);});var obj=new keylistener(key,listenerId);keylistenerArr.push(obj);return listenerId;},removeSystemConfigChangeListener:function(listenerId){webapis._validator.validateArgs(arguments,[{name:'listenerId',type:webapis._validator.Types.LONG}]);var keyListener=_removeKeyListenerById(listenerId);if(null==keyListener){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","The listener can not be found using listenerId["+listenerId+"]");return;}if(_hasKeyListener(keyListener.key)==false){ppPrdInfo=ppPrdInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppPrdInfo.postMessageAndAwaitResponse({command:"removeSystemConfigChangeListener",propertyKey:keyListener.key});if(message.code==0){console.log("[ppPrdInfo.js] removeSystemConfigChangeListener success");ppPrdInfo.removeListenerById(PRODUCTINFO_SYSTEM_CONFIG_CHANGED,listenerId);}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else ppPrdInfo.removeListenerById(PRODUCTINFO_SYSTEM_CONFIG_CHANGED,listenerId);},isUHDAModel:function(){return exec("isUHDAModel");},isWallModel:function(){return exec("isWallModel");},isDisplayRotatorSupported:function(){var value;try{value=webapis.displayrotator.isSupported();}catch(e){value=false;}return value;}};})(this);(function(window){var MOD_NAME="TvInfo";var INSTANTIATED_NAMESPACE="tvinfo";var PEPPER_PLUGIN_NAME="tvinfo";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var LISTENER_CAPTION_CHANGED="TVINFO_EVENT_CAPTION_CHANGED";var LISTENER_TVINFO_CHANGED="TVINFO_EVENT_CHANGED";var TvInfoKey={TV_VIEWER_BG_EXECUTABLE:0};var TvInfoValue={TV_VIEWER_BG_NOT_EXECUTABLE:0,TV_VIEWER_BG_EXECUTABLE:1};var TvInfoMenuKey={CAPTION_ONOFF_KEY:0,CAPTION_MODE_KEY:1,CAPTION_FONT_SIZE_KEY:2,CAPTION_FONT_STYLE_KEY:3,CAPTION_FG_COLOR_KEY:4,CAPTION_FG_OPACITY_KEY:5,CAPTION_BG_COLOR_KEY:6,CAPTION_BG_OPACITY_KEY:7,CAPTION_EDGE_TYPE_KEY:8,CAPTION_EDGE_COLOR_KEY:9,CAPTION_WINDOW_COLOR_KEY:10,CAPTION_WINDOW_OPACITY_KEY:11,ACCESSIBILITY_FORCUS_ZOOM:12,ACCESSIBILITY_FOCUS_ZOOM:12,ACCESSIBILITY_HIGH_CONTRAST:13,SMARTHUB_CHANNEL_BOUND_APPS_TICKER:14,VOICE_GUIDE_KEY:15,SUBTITLE_ONOFF_KEY:16,SUBTITLE_MODE_KEY:17,PRIMARY_AUDIO_LANGUAGE_KEY:18,SECONDARY_AUDIO_LANGUAGE_KEY:19,ACCESSIBILITY_VOICE_GUIDE_SPEED:20,CAPTION_STYLE_KEY:21};var TvInfoMenuValue={OFF:0,ON:1,CAPTION_OFF:0,CAPTION_ON:1,CAPTION_MODE_DEFAULT:0,CAPTION_MODE_SERVICE1:1,CAPTION_MODE_SERVICE2:2,CAPTION_MODE_SERVICE3:3,CAPTION_MODE_SERVICE4:4,CAPTION_MODE_SERVICE5:5,CAPTION_MODE_SERVICE6:6,CAPTION_MODE_CC1:7,CAPTION_MODE_CC2:8,CAPTION_MODE_CC3:9,CAPTION_MODE_CC4:10,CAPTION_MODE_TEXT1:11,CAPTION_MODE_TEXT2:12,CAPTION_MODE_TEXT3:13,CAPTION_MODE_TEXT4:14,CAPTION_SIZE_DEFAULT:0,CAPTION_SIZE_SMALL:1,CAPTION_SIZE_STANDARD:2,CAPTION_SIZE_LARGE:3,CAPTION_SIZE_EXTRA_LARGE:4,CAPTION_FONT_DEFAULT:0,CAPTION_FONT_STYLE0:1,CAPTION_FONT_STYLE1:2,CAPTION_FONT_STYLE2:3,CAPTION_FONT_STYLE3:4,CAPTION_FONT_STYLE4:5,CAPTION_FONT_STYLE5:6,CAPTION_FONT_STYLE6:7,CAPTION_FONT_STYLE7:8,CAPTION_COLOR_DEFAULT:0,CAPTION_COLOR_WHITE:1,CAPTION_COLOR_BLACK:2,CAPTION_COLOR_RED:3,CAPTION_COLOR_GREEN:4,CAPTION_COLOR_BLUE:5,CAPTION_COLOR_YELLOW:6,CAPTION_COLOR_MAGENTA:7,CAPTION_COLOR_CYAN:8,CAPTION_OPACITY_SOLID:0,CAPTION_OPACITY_FLASH:1,CAPTION_OPACITY_TRANSLUCENT:2,CAPTION_OPACITY_TRANSPARENT:3,CAPTION_OPACITY_DEFAULT:4,CAPTION_OPACITY_HIGHLY_TRANSLUCENT:5,CAPTION_OPACITY_SLIGHTLY_TRANSLUCENT:6,CAPTION_EDGE_NONE:0,CAPTION_EDGE_RAISED:1,CAPTION_EDGE_DEPRESSED:2,CAPTION_EDGE_UNIFORM:3,CAPTION_EDGE_DROP_SHADOWED:4,SUBTITLE_NORMAL:0,SUBTITLE_HEARING_IMMPEARED:1,AUDIO_LANGUAGE_CODE_AFR:"AFR",AUDIO_LANGUAGE_CODE_AKA:"AKA",AUDIO_LANGUAGE_CODE_AMH:"AMH",AUDIO_LANGUAGE_CODE_ARA:"ARA",AUDIO_LANGUAGE_CODE_ASM:"ASM",AUDIO_LANGUAGE_CODE_BEN:"BEN",AUDIO_LANGUAGE_CODE_BUL:"BUL",AUDIO_LANGUAGE_CODE_CAT:"CAT",AUDIO_LANGUAGE_CODE_CHI:"CHI",AUDIO_LANGUAGE_CODE_CMN:"CMN",AUDIO_LANGUAGE_CODE_CZE:"CZE",AUDIO_LANGUAGE_CODE_DAG:"DAG",AUDIO_LANGUAGE_CODE_DAN:"DAN",AUDIO_LANGUAGE_CODE_DUT:"DUT",AUDIO_LANGUAGE_CODE_ENG:"ENG",AUDIO_LANGUAGE_CODE_EST:"EST",AUDIO_LANGUAGE_CODE_EUS:"EUS",AUDIO_LANGUAGE_CODE_EWE:"EWE",AUDIO_LANGUAGE_CODE_FIN:"FIN",AUDIO_LANGUAGE_CODE_FRE:"FRE",AUDIO_LANGUAGE_CODE_GAA:"GAA",AUDIO_LANGUAGE_CODE_GER:"GER",AUDIO_LANGUAGE_CODE_GLA:"GLA",AUDIO_LANGUAGE_CODE_GLG:"GLG",AUDIO_LANGUAGE_CODE_GOS:"GOS",AUDIO_LANGUAGE_CODE_GRE:"GRE",AUDIO_LANGUAGE_CODE_GUJ:"GUJ",AUDIO_LANGUAGE_CODE_HAU:"HAU",AUDIO_LANGUAGE_CODE_HEB:"HEB",AUDIO_LANGUAGE_CODE_HIN:"HIN",AUDIO_LANGUAGE_CODE_HRV:"HRV",AUDIO_LANGUAGE_CODE_HUN:"HUN",AUDIO_LANGUAGE_CODE_IGB:"IGB",AUDIO_LANGUAGE_CODE_IND:"IND",AUDIO_LANGUAGE_CODE_IRI:"IRI",AUDIO_LANGUAGE_CODE_ITA:"ITA",AUDIO_LANGUAGE_CODE_JPN:"JPN",AUDIO_LANGUAGE_CODE_KAN:"KAN",AUDIO_LANGUAGE_CODE_KOK:"KOK",AUDIO_LANGUAGE_CODE_KOR:"KOR",AUDIO_LANGUAGE_CODE_LAV:"LAV",AUDIO_LANGUAGE_CODE_LIT:"LIT",AUDIO_LANGUAGE_CODE_MAL:"MAL",AUDIO_LANGUAGE_CODE_MAO:"MAO",AUDIO_LANGUAGE_CODE_MAR:"MAR",AUDIO_LANGUAGE_CODE_MSA:"MSA",AUDIO_LANGUAGE_CODE_NBL:"NBL",AUDIO_LANGUAGE_CODE_NOR:"NOR",AUDIO_LANGUAGE_CODE_NSO:"NSO",AUDIO_LANGUAGE_CODE_NZI:"NZI",AUDIO_LANGUAGE_CODE_ORI:"ORI",AUDIO_LANGUAGE_CODE_PAN:"PAN",AUDIO_LANGUAGE_CODE_PER:"PER",AUDIO_LANGUAGE_CODE_POL:"POL",AUDIO_LANGUAGE_CODE_POR:"POR",AUDIO_LANGUAGE_CODE_QAA:"QAA",AUDIO_LANGUAGE_CODE_QAB:"QAB",AUDIO_LANGUAGE_CODE_QAC:"QAC",AUDIO_LANGUAGE_CODE_ROM:"ROM",AUDIO_LANGUAGE_CODE_RUS:"RUS",AUDIO_LANGUAGE_CODE_SLK:"SLK",AUDIO_LANGUAGE_CODE_SOT:"SOT",AUDIO_LANGUAGE_CODE_SPA:"SPA",AUDIO_LANGUAGE_CODE_SRP:"SRP",AUDIO_LANGUAGE_CODE_SSW:"SSW",AUDIO_LANGUAGE_CODE_SWA:"SWA",AUDIO_LANGUAGE_CODE_SWE:"SWE",AUDIO_LANGUAGE_CODE_TAM:"TAM",AUDIO_LANGUAGE_CODE_TEL:"TEL",AUDIO_LANGUAGE_CODE_THA:"THA",AUDIO_LANGUAGE_CODE_TSN:"TSN",AUDIO_LANGUAGE_CODE_TSO:"TSO",AUDIO_LANGUAGE_CODE_TUR:"TUR",AUDIO_LANGUAGE_CODE_TWI:"TWI",AUDIO_LANGUAGE_CODE_UKR:"UKR",AUDIO_LANGUAGE_CODE_VAL:"VAL",AUDIO_LANGUAGE_CODE_VEN:"VEN",AUDIO_LANGUAGE_CODE_VIE:"VIE",AUDIO_LANGUAGE_CODE_WEL:"WEL",AUDIO_LANGUAGE_CODE_XHO:"XHO",AUDIO_LANGUAGE_CODE_XSM:"XSM",AUDIO_LANGUAGE_CODE_YOR:"YOR",AUDIO_LANGUAGE_CODE_YUE:"YUE",AUDIO_LANGUAGE_CODE_ZHO:"ZHO",AUDIO_LANGUAGE_CODE_ZUL:"ZUL",VOICEGUIDE_SPEED_VERY_FAST:"VERY_FAST",VOICEGUIDE_SPEED_FAST:"FAST",VOICEGUIDE_SPEED_NORMAL:"NORMAL",VOICEGUIDE_SPEED_SLOW:"SLOW",VOICEGUIDE_SPEED_VERY_SLOW:"VERY_SLOW",CAPTION_STYLE_DEFAULT:0,CAPTION_STYLE_BOLD:1,CAPTION_STYLE_ITALIC:2};var keylistenerArr=[];var keylistener=function(key,listenerId){this.key=key;this.listenerId=listenerId;};var _hasKeyListener=function(key){for(i=0;i<keylistenerArr.length;i++)if(keylistenerArr[i].key==key)return true;return false;};var _removeKeyListenerById=function(id){for(i=0;i<keylistenerArr.length;i++)if(keylistenerArr[i].listenerId==id){var obj=keylistenerArr[i];keylistenerArr.splice(i,1);return obj;}return null;};var _convertLangToValue=function(value){var result=-1;switch(value){case "AFR":result=6383218;break;case "AKA":result=6384481;break;case "AMH":result=6385000;break;case "ARA":result=6386273;break;case "ASM":result=6386541;break;case "BEN":result=6448494;break;case "BUL":result=6452588;break;case "CAT":result=6513012;break;case "CHI":result=6514793;break;case "CMN":result=6516078;break;case "CZE":result=6519397;break;case "DAG":result=6578535;break;case "DAN":result=6578542;break;case "DUT":result=6583668;break;case "ENG":result=6647399;break;case "EST":result=6648692;break;case "EUS":result=6649203;break;case "EWE":result=6649701;break;case "FIN":result=6711662;break;case "FRE":result=6713957;break;case "GAA":result=6775137;break;case "GER":result=6776178;break;case "GLA":result=6775912;break;case "GLG":result=6777959;break;case "GOS":result=6778739;break;case "GRE":result=6779493;break;case "GUJ":result=6780266;break;case "HAU":result=6840693;break;case "HEB":result=6841698;break;case "HIN":result=6842734;break;case "HRV":result=6845046;break;case "HUN":result=6845806;break;case "IGB":result=6907746;break;case "IND":result=6909540;break;case "IRI":result=6910569;break;case "ITA":result=6911073;break;case "JPN":result=6975598;break;case "KAN":result=7037294;break;case "KOK":result=7040875;break;case "KOR":result=7040882;break;case "LAV":result=7102838;break;case "LIT":result=7104884;break;case "MAL":result=7168364;break;case "MAO":result=7168367;break;case "MAR":result=7168370;break;case "MSA":result=7172961;break;case "NBL":result=7234156;break;case "NOR":result=7237490;break;case "NSO":result=7238511;break;case "NZI":result=7240297;break;case "ORI":result=7303785;break;case "PAN":result=7364974;break;case "PER":result=7366002;break;case "POL":result=7368556;break;case "POR":result=7368562;break;case "QAA":result=7430497;break;case "QAB":result=7430498;break;case "QAC":result=7430499;break;case "ROM":result=7501165;break;case "RUS":result=7501171;break;case "SLK":result=7564395;break;case "SOT":result=7565172;break;case "SPA":result=7565409;break;case "SRP":result=7565936;break;case "SSW":result=7566199;break;case "SWA":result=7562081;break;case "SWE":result=7567205;break;case "TAM":result=7627117;break;case "TEL":result=7628140;break;case "THA":result=7628897;break;case "TSN":result=7631726;break;case "TSO":result=7631727;break;case "TUR":result=7632242;break;case "TWI":result=7632745;break;case "UKR":result=7695218;break;case "VAL":result=7758188;break;case "VEN":result=7759214;break;case "VIE":result=7760229;break;case "WEL":result=6519149;break;case "XHO":result=7891055;break;case "XSM":result=7893869;break;case "YOR":result=7958386;break;case "YUE":result=7959909;break;case "ZHO":result=8022127;break;case "ZUL":result=8025452;break;default:console.log("There is no key can be converted");}return result;};var _convertValueToLang=function(value){var result="";switch(value){case 6383218:result="AFR";break;case 6384481:result="AKA";break;case 6385000:result="AMH";break;case 6386273:result="ARA";break;case 6386541:result="ASM";break;case 6448494:result="BEN";break;case 6452588:result="BUL";break;case 6513012:result="CAT";break;case 6514793:result="CHI";break;case 6516078:result="CMN";break;case 6519397:result="CZE";break;case 6578535:result="DAG";break;case 6578542:result="DAN";break;case 6583668:result="DUT";break;case 6647399:result="ENG";break;case 6648692:result="EST";break;case 6649203:result="EUS";break;case 6649701:result="EWE";break;case 6711662:result="FIN";break;case 6713957:result="FRE";break;case 6775137:result="GAA";break;case 6776178:result="GER";break;case 6775912:result="GLA";break;case 6777959:result="GLG";break;case 6778739:result="GOS";break;case 6779493:result="GRE";break;case 6780266:result="GUJ";break;case 6840693:result="HAU";break;case 6841698:result="HEB";break;case 6842734:result="HIN";break;case 6845046:result="HRV";break;case 6845806:result="HUN";break;case 6907746:result="IGB";break;case 6909540:result="IND";break;case 6910569:result="IRI";break;case 6911073:result="ITA";break;case 6975598:result="JPN";break;case 7037294:result="KAN";break;case 7040875:result="KOK";break;case 7040882:result="KOR";break;case 7102838:result="LAV";break;case 7104884:result="LIT";break;case 7168364:result="MAL";break;case 7168367:result="MAO";break;case 7168370:result="MAR";break;case 7172961:result="MSA";break;case 7234156:result="NBL";break;case 7237490:result="NOR";break;case 7238511:result="NSO";break;case 7240297:result="NZI";break;case 7303785:result="ORI";break;case 7364974:result="PAN";break;case 7366002:result="PER";break;case 7368556:result="POL";break;case 7368562:result="POR";break;case 7430497:result="QAA";break;case 7430498:result="QAB";break;case 7430499:result="QAC";break;case 7501165:result="ROM";break;case 7501171:result="RUS";break;case 7564395:result="SLK";break;case 7565172:result="SOT";break;case 7565409:result="SPA";break;case 7565936:result="SRP";break;case 7566199:result="SSW";break;case 7562081:result="SWA";break;case 7567205:result="SWE";break;case 7627117:result="TAM";break;case 7628140:result="TEL";break;case 7628897:result="THA";break;case 7631726:result="TSN";break;case 7631727:result="TSO";break;case 7632242:result="TUR";break;case 7632745:result="TWI";break;case 7695218:result="UKR";break;case 7758188:result="VAL";break;case 7759214:result="VEN";break;case 7760229:result="VIE";break;case 6519149:result="WEL";break;case 7891055:result="XHO";break;case 7893869:result="XSM";break;case 7958386:result="YOR";break;case 7959909:result="YUE";break;case 8022127:result="ZHO";break;case 8025452:result="ZUL";break;default:console.log("There is no key can be converted");}return result;};var ppTvInfo=null;window.webapis[INSTANTIATED_NAMESPACE]={TvInfoMenuKey:TvInfoMenuKey,TvInfoMenuValue:TvInfoMenuValue,TvInfoKey:TvInfoKey,TvInfoValue:TvInfoValue,getVersion:function(){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[TvInfo.js] getVersion message data "+message.data);return message.data;}else{console.log("[TvInfo.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isTvsPicSizeResized:function(){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"isTVSPicSizeResized"});if(message.code==0){console.log("[TvInfo.js] isTvsPicSizeResized  message data "+message.data);return message.data;}else{console.log("[TvInfo.js] isTvsPicSizeResized  error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getMenuValue:function(key){if((!window.webapis._enumCheckerObj(TvInfoMenuKey,key))||(TvInfoMenuKey.SMARTHUB_CHANNEL_BOUND_APPS_TICKER==key)){if(!window.webapis._checkTypeValid("long",key))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoMenuKey type passed for 'key' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoMenuKey value passed for 'key' parameter");}ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"getMenuValue",propertyKey:key});if(message.code==0){if((key==window.webapis.tvinfo.TvInfoMenuKey.PRIMARY_AUDIO_LANGUAGE_KEY)||(key==window.webapis.tvinfo.TvInfoMenuKey.SECONDARY_AUDIO_LANGUAGE_KEY))return _convertValueToLang(message.data);return message.data;}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},addCaptionChangeListener:function(key,listener){if(!window.webapis._enumCheckerObj(TvInfoMenuKey,key)){if(!window.webapis._checkTypeValid("long",key))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoMenuKey type passed for 'key' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoMenuKey value passed for 'key' parameter");}if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoCaptionChangeCallback type passed for 'listener' parameter");if(_hasKeyListener(key)==false){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"registerVconfKeysForCaption",propertyKey:key});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else console.log("[TvInfo.js] need not registerVconfKeysForCaption again, key : "+key);var listenerId=ppTvInfo.addListener(LISTENER_CAPTION_CHANGED,function(msg){if(key==msg.data.data)listener(msg.data.data);});var obj=new keylistener(key,listenerId);keylistenerArr.push(obj);return listenerId;},removeCaptionChangeListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid listenerId type passed for 'listenerId' parameter");var keyListener=_removeKeyListenerById(listenerId);if(null==keyListener){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","The listener can not be found using listenerId["+listenerId+"]");return;}if(_hasKeyListener(keyListener.key)==false){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"unRegisterVconfKeysForCaption",propertyKey:keyListener.key});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);else ppTvInfo.removeListenerById(LISTENER_CAPTION_CHANGED,listenerId);}else ppTvInfo.removeListenerById(LISTENER_CAPTION_CHANGED,listenerId);console.log("[TvInfo.js] removeCaptionChangeListener success");},showCaption:function(show){if(!window.webapis._checkTypeValid("boolean",show))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid boolean type passed for 'show' parameter");var visibility;if(show)visibility=1;else visibility=0;ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"showCaption",show:visibility});if(message.code==0)console.log("[TvInfo.js] showCaption success");else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},registerInAppCaptionControl:function(status){if(!window.webapis._checkTypeValid("boolean",status))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid boolean type passed for 'status' parameter");var onoff;if(status)onoff=1;else onoff=0;ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"registerInAppCaptionControl",status:onoff});if(message.code==0)console.log("[TvInfo.js] registerInAppCaptionControl success");else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},getTvInfoValue:function(key){if(!window.webapis._enumCheckerObj(TvInfoKey,key)){if(!window.webapis._checkTypeValid("long",key))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoKey type passed for 'key' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoKey value passed for 'key' parameter");}ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"getTvInfoValue",propertyKey:key});if(message.code==0)return message.data;else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},addTvInfoChangeListener:function(key,listener){if(!window.webapis._enumCheckerObj(TvInfoKey,key)){if(!window.webapis._checkTypeValid("long",key))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoKey type passed for 'key' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoKey value passed for 'key' parameter");}if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoChangeCallback type passed for 'listener' parameter");if(_hasKeyListener(key)==false){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"registerVconfKeysForTvinfo",propertyKey:key});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else console.log("[TvInfo.js] need not registerVconfKeysForTvinfo again, key : "+key);var listenerId=ppTvInfo.addListener(LISTENER_TVINFO_CHANGED,function(msg){if(key==msg.data.data)listener(msg.data.data);});var obj=new keylistener(key,listenerId);keylistenerArr.push(obj);return listenerId;},removeTvInfoChangeListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid listenerId type passed for 'listenerId' parameter");var keyListener=_removeKeyListenerById(listenerId);if(null==keyListener){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","The listener can not be found using listenerId["+listenerId+"]");return;}if(_hasKeyListener(keyListener.key)==false){ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppTvInfo.postMessageAndAwaitResponse({command:"unRegisterVconfKeysForTvinfo",propertyKey:keyListener.key});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);else ppTvInfo.removeListenerById(LISTENER_TVINFO_CHANGED,listenerId);}else ppTvInfo.removeListenerById(LISTENER_TVINFO_CHANGED,listenerId);console.log("[TvInfo.js] removeTvInfoChangeListener success");},setMenuValue:function(key,value,onsuccess,onerror){if(!window.webapis._enumCheckerObj(TvInfoMenuKey,key)){if(!window.webapis._checkTypeValid("long",key))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoMenuKey type passed for 'key' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoMenuKey value passed for 'key' parameter");}if(!window.webapis._enumCheckerObj(TvInfoMenuValue,value)){if((!window.webapis._checkTypeValid("long",value))||(!window.webapis._checkTypeValid("DOMString",value)&&((key==window.webapis.tvinfo.TvInfoMenuKey.PRIMARY_AUDIO_LANGUAGE_KEY)||(key==window.webapis.tvinfo.TvInfoMenuKey.SECONDARY_AUDIO_LANGUAGE_KEY))))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid TvInfoMenuValue type passed for 'value' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid TvInfoMenuValue value passed for 'value' parameter");}if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if((key==window.webapis.tvinfo.TvInfoMenuKey.PRIMARY_AUDIO_LANGUAGE_KEY)||(key==window.webapis.tvinfo.TvInfoMenuKey.SECONDARY_AUDIO_LANGUAGE_KEY)){value=_convertLangToValue(value);console.log("converted key value is ["+value+"]");}ppTvInfo=ppTvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppTvInfo.postMessage({command:"setMenuValue",propertyKey:key,value:value},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null,msgData.data);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});}};})(this);(function(window){var MOD_NAME="WidgetData";var INSTANTIATED_NAMESPACE="widgetdata";var PEPPER_PLUGIN_NAME="widgetdata";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppWidgetData=null;window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppWidgetData.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[widgetdata.js] getVersion message data "+message.data);return message.data;}else{console.log("[widgetdata.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},readWidgetData:function(password,dataLength,widgetId,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",password))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'password' parameter");if(!window.webapis._checkTypeValid("long",dataLength))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'dataLength' parameter");if(!window.webapis._checkTypeValid("DOMString",widgetId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'widgetId' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid WidgetDataStringSuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:"ReadWidgetData",Password:password,DataLength:dataLength,widgetID:widgetId},function(message){var msgData=message.data;if(msgData.code==0)onsuccess.call(null,msgData.data);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},removeWidgetData:function(widgetId,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",widgetId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'widgetId' parameter");if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:"RemoveWidgetData",widgetID:widgetId},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},writeWidgetData:function(password,data,dataLength,widgetId,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",password))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'password' parameter");if(!window.webapis._checkTypeValid("DOMString",data))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'data' parameter");if(!window.webapis._checkTypeValid("long",dataLength))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'dataLength' parameter");if(!window.webapis._checkTypeValid("DOMString",widgetId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'widgetId' parameter");if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:'WriteWidgetData',Password:password,Data:data,DataLength:dataLength,widgetID:widgetId},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},read:function(onsuccess,onerror){if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid WidgetDataStringSuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:"Read"},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null,msgData.data);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},write:function(data,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",data))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'data' parameter");if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:'Write',Data:data},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},remove:function(onsuccess,onerror){if(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess)){window.webapis._createFalsyAlert(onsuccess);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'onsuccess' parameter");}if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppWidgetData=ppWidgetData||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppWidgetData.postMessage({command:"Remove"},function(message){var msgData=message.data;if(msgData.code==0)onsuccess&&onsuccess.call(null);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});}};})(this);(function(window){var MOD_NAME="was";var INSTANTIATED_NAMESPACE="was";var PEPPER_PLUGIN_NAME="was";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppWAS=null;window.webapis[INSTANTIATED_NAMESPACE]={INSTALL_STATE_DOWNLOADED:0,INSTALL_STATE_INSTALLING:1,INSTALL_STATE_UNINSTALLING:2,INSTALL_STATE_INSTALLED:3,INSTALL_STATE_UNDOWNLOADED:4,INSTALLED_SOURCE_TYPE_LOCAL:0,INSTALLED_SOURCE_TYPE_APPSTORE:1,INSTALLED_SOURCE_TYPE_OTHER:2,getVersion:function(){console.log("[WAS_PP] getVersion");ppWAS=ppWAS||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppWAS.postMessageAndAwaitResponse({command:'was_plugin_getVersion'});if(result.code==0){console.log("[Was.js] getVersion : message data "+result.data);return result.data;}else{console.log("[Was.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}return result;},getAtoken:function(){console.log("[WAS_PP] getAtoken");ppWAS=ppWAS||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var atoken=ppWAS.postMessageAndAwaitResponse({command:'was_plugin_GetAtoken'});console.log("[WAS_PP] [INFO] atoken is [ "+atoken+"]");if(atoken.code==0){console.log("[Was.js] getAtoken : message data "+atoken.data);return atoken.data;}else{console.log("[Was.js] getAtoken :  error code "+atoken.code);throw window.webapis._createWebAPIError(atoken.code,atoken.errorName,atoken.errorMessage);}return atoken;},getAppInfo:function(appId){console.log("[WAS_PP] getAppInfo");if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(0,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");ppWAS=ppWAS||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppWAS.postMessageAndAwaitResponse({command:'was_plugin_getAppInfo',appid:appId});console.log("[WAS_PP] getAppInfo success");if(result.code==0){console.log("[Was.js] getAppInfo : message data "+result.data);return result.data;}else{console.log("[Was.js] getAppInfo :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}}};})(this);(function(window){var MOD_NAME="sso";var INSTANTIATED_NAMESPACE="sso";var PEPPER_PLUGIN_NAME="sso";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var SsoLoginState={SSO_NOT_LOGIN:0,SSO_LOGIN:1};var SsoTermsAgreementState={SSO_NOT_AGREE:0,SSO_AGREE:1};var ppSSO=null;window.webapis[INSTANTIATED_NAMESPACE]={SsoLoginState:SsoLoginState,SsoTermsAgreementState:SsoTermsAgreementState,getVersion:function(){console.log("[SSO_PP] getVersion");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getVersion'});if(result.code==0){console.log("[sso.js] getVersion : message data "+result.data);return result.data;}else{console.log("[sso.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}return result;},getSsoState:function(){console.log("[SSO_PP] getSsoState");if(webapis.sso.getLoginStatus()==0)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getSSOState'});if(result.code==0){var loginfo=result.data;var SsoData={bLogin:false,id:"",authToken:"",uid:"",guid:""};if(loginfo==""||loginfo==-1){SsoData.bLogin=false;SsoData.id="";SsoData.authToken="";SsoData.uid="";SsoData.guid="";}else{var tmpValue=loginfo.split("?");SsoData.bLogin=true;SsoData.id=((typeof tmpValue[0]=='undefined')?'':tmpValue[0]);SsoData.authToken=((typeof tmpValue[1]=='undefined')?'':tmpValue[1]);SsoData.uid=((typeof tmpValue[2]=='undefined')?'':tmpValue[2]);SsoData.guid=((typeof tmpValue[3]=='undefined')?'':tmpValue[3]);}console.log("[SSO_PP] [INFO] the sso loginfo is "+SsoData);return SsoData;}else{console.log("[sso.js] getSsoState :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},getGuid:function(){console.log("[SSO_PP] getGuid");if(webapis.sso.getLoginStatus()==0)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getGuid'});if(result.code==0){var guid=result.data;if(-1==guid)guid="";console.log("[SSO_PP] Guid is ["+guid+"]");return guid;}else{console.log("[sso.js] getGuid :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},getLoginStatus:function(){console.log("[SSO_PP] getLoginStatus");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var state=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getLoginStatus'});if(state.code==0){console.log("[SSO_PP] login status is ["+state.data+"]");return state.data;}else{console.log("[sso.js] getLoginStatus :  error code "+state.code);throw window.webapis._createWebAPIError(state.code,state.errorName,state.errorMessage);}},getLoginUid:function(){console.log("[SSO_PP] getLoginUid");if(webapis.sso.getLoginStatus()==0)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var uid=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getLoginUid'});if(uid.code==0){console.log("[SSO_PP] Uid is ["+uid.data+"]");return uid.data;}else{console.log("[SSO_PP] getLoginUid  :  error code "+uid.code);throw window.webapis._createWebAPIError(uid.code,uid.errorName,uid.errorMessage);}},showAccountView:function(widgetName,onsuccess,onerror){console.log("[SSO_PP] showAccountView");if(!window.webapis._checkTypeValid("DOMString",widgetName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'widgetName' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid showAccountView SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_show_login_page",data:widgetName},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData.state){var message=msgData.context.split("?");data={status:msgData.state};}else data={status:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},showAccountViewWithTransparent:function(widgetName,onsuccess,onerror){console.log("[SSO_PP] showAccountViewWithTransparent");if(!window.webapis._checkTypeValid("DOMString",widgetName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'widgetName' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid showAccountViewWithTransparent SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_show_login_page_with_transparent_win",data:widgetName},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData.state){var message=msgData.context.split("?");data={status:msgData.state};}else data={status:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},getOspAccessToken:function(appID,secretKey,onsuccess,onerror){console.log("[SSO_PP] getOspAccessToken");if(!window.webapis._checkTypeValid("DOMString",appID)||appID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("DOMString",secretKey)||secretKey=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid getOspAccessToken SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_getOSPAccessToken",id:appID,secret:secretKey},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.token);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},showCreateAccountView:function(onsuccess,onerror){console.log("[SSO_PP] showCreateAccountView");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid showCreateAccountView SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_createAccount"},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.state);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},showTermsPage:function(termsId,callerId,onsuccess,onerror){console.log("[SSO_PP] showTermsPage");if(!window.webapis._checkTypeValid("DOMString",termsId)||termsId=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'termsId' parameter");if(!window.webapis._checkTypeValid("DOMString",callerId)||callerId=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'callerId' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid showTermsPage SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_showTermsPage",termsId:termsId,callerId:callerId},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData.state)data={status:msgData.state};else data={status:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},getTermsAgreementState:function(termsId){console.log("[SSO_PP] getTermsAgreementState");if(!window.webapis._checkTypeValid("DOMString",termsId)||termsId=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'termsId' parameter");if(webapis.sso.getLoginStatus()==0)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login");ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var termsState=ppSSO.postMessageAndAwaitResponse({command:'sso_plugin_getTermsAgreementState',termsId:termsId});if(termsState.code==0){console.log("[SSO_PP] Terms State is ["+termsState.data+"]");return termsState.data;}else{console.log("[SSO_PP] getTermsAgreementState  :  error code "+termsState.code);throw window.webapis._createWebAPIError(termsState.code,termsState.errorName,termsState.errorMessage);}},getPartnerAccountMappingList:function(appID,partnerName,onsuccess,onerror){console.log("[SSO_PP] getPartnerAccountMappingList");if(!window.webapis._checkTypeValid("DOMString",appID)||appID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid getPartnerAccountMappingList SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_getPartnerAccountMappingList",appID:appID,cpName:partnerName},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.PartnerAccountInfo);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},addPartnerAccountMappingInfo:function(appID,partnerName,partnerUID,onsuccess,onerror){console.log("[SSO_PP] addPartnerAccountMappingInfo");if(!window.webapis._checkTypeValid("DOMString",appID)||appID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("DOMString",partnerName)||partnerName=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'partnerName' parameter");if(!window.webapis._checkTypeValid("DOMString",partnerUID)||partnerUID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'partnerUID' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid addPartnerAccountMappingInfo SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_addPartnerAccountMappingInfo",appID:appID,cpName:partnerName,cpUID:partnerUID},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.result);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},removePartnerAccountMappingInfo:function(appID,partnerName,partnerUID,onsuccess,onerror){console.log("[SSO_PP] removePartnerAccountMappingInfo");if(!window.webapis._checkTypeValid("DOMString",appID)||appID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("DOMString",partnerName)||partnerName=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'partnerName' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid removePartnerAccountMappingInfo SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_removePartnerAccountMappingInfo",appID:appID,cpName:partnerName,cpUID:partnerUID},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.result);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});},requestAuthCodeForEffortlessLogin:function(appID,scope,onsuccess,onerror){console.log("[SSO_PP] requestAuthCodeForEffortlessLogin");if(!window.webapis._checkTypeValid("DOMString",appID)||appID=="")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appID' parameter");if(!window.webapis._checkTypeValid("DOMString",scope))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'partnerName' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid removePartnerAccountMappingInfo SuccessCallback type passed for 'onsuccess' parameter");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}if(webapis.sso.getLoginStatus()==0){onerror&&onerror.call(null,webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","the SSO is not login"));return;}if(scope=="")scope="HAS_NO_VALUE";ppSSO=ppSSO||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSSO.postMessage({command:"sso_plugin_requestPartnerAuthCodeForEffortlessLogin",appID:appID,scope:scope},function(message){console.log("[SSO_PP] message");var msgData=message.data;if(msgData.status==0){console.log("[SSO_PP] message success");onsuccess.call(null,msgData.authcode);}else{console.log("[SSO_PP] message fail");console.log("status: "+msgData.status+" message: "+msgData.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.result,msgData.errorMessage));}});}};})(this);(function(window){var MOD_NAME="Network";var INSTANTIATED_NAMESPACE="network";var PEPPER_PLUGIN_NAME="network";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppNetwork=null;var NETWORK_STATUS_CHANGE="NETWORK_STATUS_CHANGE";var INTERNET_STATUS="INTERNET_STATUS";var cdata=null;var NetworkActiveConnectionType={DISCONNECTED:0,WIFI:1,CELLULAR:2,ETHERNET:3};var NetworkIpMode={NONE:0,STATIC:1,DYNAMIC:2,AUTO:3,FIXED:4,UNKNOWN:5};var NetworkWiFiSecurityMode={WEP:1,WPA_PSK:2,WPA2_PSK:3,EAP:4,NONE:5,UNKNOWN:6};var NetworkWiFiEncryptionType={WEP:1,TKIP:2,AES:3,TKIP_AES_MIXED:4,NONE:5,UNKNOWN:6};var NetworkState={LAN_CABLE_ATTACHED:1,LAN_CABLE_DETACHED:2,LAN_CABLE_STATE_UNKNOWN:3,GATEWAY_CONNECTED:4,GATEWAY_DISCONNECTED:5,WIFI_MODULE_STATE_ATTACHED:6,WIFI_MODULE_STATE_DETACHED:7,WIFI_MODULE_STATE_UNKNOWN:8};var CurrentListenerId=-1;window.webapis[INSTANTIATED_NAMESPACE]={NetworkActiveConnectionType:NetworkActiveConnectionType,NetworkIpMode:NetworkIpMode,NetworkState:NetworkState,NetworkWiFiSecurityMode:NetworkWiFiSecurityMode,NetworkWiFiEncryptionType:NetworkWiFiEncryptionType,getVersion:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[network.js] getVersion message data "+message.data);return message.data;}else{console.log("[network.js] getVersion error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getActiveConnectionType:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getActiveConnectionType"});if(message.code==0){console.log("[network.js] getActiveConnectionType message data "+message.data);return message.data;}else{console.log("[network.js] getActiveConnectionType error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getdata:function(){return cdata;},addNetworkStateChangeListener:function(listener){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid NetworkStateChangeListener type passed for 'listener' parameter");var message=ppNetwork.postMessageAndAwaitResponse({command:"addNetworkStateChangeListener"});if(message.code==0){console.log("[network.js] addNetworkStateChangeListener  success");var listenerId=ppNetwork.addListener(NETWORK_STATUS_CHANGE,function(msg){listener(msg.data.result);});CurrentListenerId=listenerId;console.log("[network.js] listenerId "+listenerId);return listenerId;}else{console.log("[network.js] addNetworkStateChangeListener error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},removeNetworkStateChangeListener:function(listenerId){console.log("[network.js] removeNetworkStateChangeListener success ["+listenerId+"]");if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter["+listenerId+"]");if(listenerId!=CurrentListenerId)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid listenerId value passed for 'listenerId' parameter");ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"removeNetworkStateChangeListener"});if(message.code==0){console.log("[network.js] removeNetworkStateChangeListener success ");ppNetwork.removeListenerById(NETWORK_STATUS_CHANGE,listenerId);}else{console.log("[network.js] getActiveConnectionType error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getIp:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getIp"});if(message.code==0){console.log("[network.js] getIp message data "+message.data);return message.data;}else{console.log("[network.js] getIp error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getTVName:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getTVName"});if(message.code==0){console.log("[network.js] getTVName message data "+message.data);return message.data;}else{console.log("[network.js] getTVName error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isConnectedToInternet:function(listener){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid Listener type passed for 'listener' parameter");var message=ppNetwork.postMessageAndAwaitResponse({command:"isConnectedToInternet"});if(message.code==0){console.log("[network.js] isConnectedToInternet success");var listenerId=ppNetwork.addListener(INTERNET_STATUS,function(msg){listener(msg.data.result);});CurrentListenerId=listenerId;console.log("[network.js] listenerId "+listenerId);return listenerId;}else{console.log("[network.js] isConnectedToInternet error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},removeInternetCheckListener:function(listenerId){console.log("[network.js] removeInternetCheckListener success ["+listenerId+"]");if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter["+listenerId+"]");if(listenerId!=CurrentListenerId)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid listenerId value passed for 'listenerId' parameter");ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"removeInternetCheckListener"});if(message.code==0){console.log("[network.js] removeInternetCheckListener success ");ppNetwork.removeListenerById(INTERNET_STATUS,listenerId);}else{console.log("[network.js] getActiveConnectionType error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isConnectedToGateway:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"isConnectedToGateway"});if(message.code==0){console.log("[network.js] isConnectedToGateway message data "+message.data);return message.data;}else{console.log("[network.js] isConnectedToGateway error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getIpMode:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getIpMode"});if(message.code==0){console.log("[network.js] getIpMode message data "+message.data);return message.data;}else{console.log("[network.js] getIpMode error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSubnetMask:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getSubnetMask"});if(message.code==0){console.log("[network.js] getSubnetMask message data "+message.data);return message.data;}else{console.log("[network.js] getSubnetMask error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getGateway:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getGateway"});if(message.code==0){console.log("[network.js] getGateway message data "+message.data);return message.data;}else{console.log("[network.js] getGateway error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getMac:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getMac"});if(message.code==0){console.log("[network.js] getMac message data "+message.data);return message.data;}else{console.log("[network.js] getMac error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getDns:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getDns"});if(message.code==0){console.log("[network.js] getDns message data "+message.data);return message.data;}else{console.log("[network.js] getDns error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWiFiSsid:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getWiFiSsid"});if(message.code==0){console.log("[network.js] getWiFiSsid message data "+message.data);return message.data;}else{console.log("[network.js] getWiFiSsid error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWiFiSignalStrengthLevel:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getWiFiSignalStrengthLevel"});if(message.code==0){console.log("[network.js] getWiFiSignalStrengthLevel message data "+message.data);return message.data;}else{console.log("[network.js] getWiFiSignalStrengthLevel error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWiFiSecurityMode:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getWiFiSecurityMode"});if(message.code==0){console.log("[network.js] getWiFiSecurityMode message data "+message.data);return message.data;}else{console.log("[network.js] getWiFiSecurityMode error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWiFiEncryptionType:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getWiFiEncryptionType"});if(message.code==0){console.log("[network.js] getWiFiEncryptionType message data "+message.data);return message.data;}else{console.log("[network.js] getWiFiEncryptionType error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSecondaryDns:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getSecondaryDns"});if(message.code==0){console.log("[network.js] getSecondaryDns message data "+message.data);return message.data;}else{console.log("[network.js] getSecondaryDns error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setDhcpOption60Field:function(a){console.log("[network.js] setDhcpOption60Field message data "+a);if(!window.webapis._checkTypeValid("DOMString",a))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'a' parameter");ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"setDhcpOption60Field",vendor:a});if(message.code==0)console.log("[network.js] setDhcpOption60Field message data "+message.data);else{console.log("[network.js] setDhcpOption60Field error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},removeDhcpOption60Field:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"removeDhcpOption60Field"});if(message.code==0)console.log("[network.js] removeDhcpOption60Field message data "+message.data);else{console.log("[network.js] removeDhcpOption60Field error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentDhcpOption60Field:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getCurrentDhcpOption60Field"});if(message.code==0){console.log("[network.js] getCurrentDhcpOption60Field message data "+message.data);return message.data;}else{console.log("[network.js] getCurrentDhcpOption60Field error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},checkCurrentIpWith60Field:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"checkCurrentIpWith60Field"});if(message.code==0){console.log("[network.js] checkCurrentIpWith60Field message data "+message.data);return message.data;}else{console.log("[network.js] checkCurrentIpWith60Field error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getEthernetMac:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getEthernetMac"});if(message.code==0){console.log("[network.js] getEthernetMac message data "+message.data);return message.data;}else{console.log("[network.js] getEthernetMac error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},enableSoftAP:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"enableSoftAP"});if(message.code==0){console.log("[network.js] enableSoftAP message data "+message.data);return message.data;}else{console.log("[network.js] enableSoftAP error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},disableSoftAP:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"disableSoftAP"});if(message.code==0){console.log("[network.js] disableSoftAP message data "+message.data);return message.data;}else{console.log("[network.js] disableSoftAP error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isSoftAPEnabled:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"isSoftAPEnabled"});if(message.code==0){console.log("[network.js] isSoftAPEnabled message data "+message.data);return message.data;}else{console.log("[network.js] isSoftAPEnabled error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSoftAPSSID:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getSoftAPSSID"});if(message.code==0){console.log("[network.js] getSoftAPSSID message data "+message.data);return message.data;}else{console.log("[network.js] getSoftAPSSID error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSoftAPSecurityKey:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getSoftAPSecurityKey"});if(message.code==0){console.log("[network.js] getSoftAPSecurityKey message data "+message.data);return message.data;}else{console.log("[network.js] getSoftAPSecurityKey error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSoftAPChannel:function(a){console.log("[network.js] setSoftAPChannel message data "+a);ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"setSoftAPChannel",channel:a});if(message.code==0){console.log("[network.js] setSoftAPChannel message data "+message.data);return message.data;}else{console.log("[network.js] setSoftAPChannel error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSoftAPSignalStrength:function(a){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"setSoftAPSignalStrength",strength:a});if(message.code==0){console.log("[network.js] setSoftAPSignalStrength message data "+message.data);return message.data;}else{console.log("[network.js] setSoftAPSignalStrength error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSoftAPSecurityKeyAutoGeneration:function(a){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"setSoftAPSecurityKeyAutoGeneration",autoGenerateFlag:a});if(message.code==0){console.log("[network.js] setSoftAPSecurityKeyAutoGeneration message data "+message.data);return message.data;}else{console.log("[network.js] setSoftAPSecurityKeyAutoGeneration error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setTVName:function(name){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(!window.webapis._checkTypeValid("DOMString",name))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'a' parameter");var message=ppNetwork.postMessageAndAwaitResponse({command:"setTVName",tvName:name});if(message.code==0){console.log("[network.js] setTVName message data "+message.data);return message.data;}else{console.log("[network.js] setTVName error "+message.code);cdata=message.data;throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWiFiFrequency:function(){ppNetwork=ppNetwork||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppNetwork.postMessageAndAwaitResponse({command:"getWiFiFrequency"});if(message.code==0){console.log("[network.js] getWiFiFrequency message data "+message.data);return message.data;}else{console.log("[network.js] getWiFiFrequency error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="Microphone";var INSTANTIATED_NAMESPACE="microphone";var PEPPER_PLUGIN_NAME="microphone";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var EVENT_FROM_MANAGER="EventFromManager";var EVENT_FROM_DEVICE="MicrophoneDeviceCallback";var ppMicro=null;var getPlugin=function(){if(null!=ppMicro)return ppMicro;ppMicro=window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(null==ppMicro){console.log("[microphone.js]  init pepper plugin error ");return null;}var message=ppMicro.postMessageAndAwaitResponse({command:"RegisterCallback"});if(message.code==0)ppMicro.addListener(EVENT_FROM_MANAGER,window.webapis.microphone._handlerMicConnectMessage);else console.log("[ppMicrophone.js] RegisterManagerCallback message.code != 0");return ppMicro;};var exec=function(api){ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:api});if(message.code==0)return message.data;else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);};window.webapis[INSTANTIATED_NAMESPACE]={EVENT_DEVICE_CONNECT:11,EVENT_DEVICE_DISCONNECT:12,MICROPHONE_SAMPLE_RATE_48000:48000,MICROPHONE_SAMPLE_RATE_44100:44100,MICROPHONE_SAMPLE_RATE_32000:32000,MICROPHONE_SAMPLE_RATE_16000:16000,MICROPHONE_SAMPLE_RATE_8000:8000,MICROPHONE_EFFECT_NONE:0x00,MICROPHONE_EFFECT_REVERB:0x01,MICROPHONE_EFFECT_FILTER:0x10,MICROPHONE_STATUS_STOP:0x00000000,MICROPHONE_STATUS_PLAY:0x00000001,MICROPHONE_STATUS_RECORD:0x00000010,MICROPHONE_STATUS_FILTER:0x00000100,MICROPHONE_FORMAT_SIGNED_16BIT_LITTLE_ENDIAN:0,MICROPHONE_FORMAT_SIGNED_16BIT_BIG_ENDIAN_FORMAT:1,MICROPHONE_AUDIOINPUT_PLAY_FAIL:400,MICROPHONE_AUDIOINPUT_DATA:401,MICROPHONE_AUDIOINPUT_RECORD_FAIL:402,MICROPHONE_AUDIOINPUT_RECORD_STOP:403,MICROPHONE_AUDIOINPUT_FILTER_VOICE_DETECTED:404,MICROPHONE_AUDIOINPUT_FILTER_PLAY_START:405,MICROPHONE_AUDIOINPUT_FILTER_PLAY_STOP:406,MICROPHONE_AUDIOINPUT_FILTER_SILENCE_DETECTED:407,MICROPHONE_AUDIOINPUT_FILTER_PLAY_VOLUME:450,OCI_OK:0,OCI_NO_ERR:0,OCI_ERR:9999,DELIMITER_EVENT_PARAM:",",OCIDevInfo:function(){var uid;var name;var eventType;var deviceType;var isFree;},callbackCount:0,connectCallbackArr:[],connectCallback:function(listenerId,callback){this.id=listenerId;this.callback=callback;},_addConnectCallback:function(listenerId,callback){var callback=new window.webapis[INSTANTIATED_NAMESPACE].connectCallback(listenerId,callback);this.connectCallbackArr.push(callback);},_removeConnectCallbackById:function(id){for(i=0;i<this.connectCallbackArr.length;i++)if(this.connectCallbackArr[i].id==id){var obj=this.connectCallbackArr[i];this.connectCallbackArr.splice(i,1);return obj;}return null;},MicrophoneArray:new Array(),MicrophoneValidArray:new Array(),IsVoiceRecognition:true,MicrophoneManagerEvent:function(){var eventType;var name;var uid;},_handlerMicConnectMessage:function(msg){var connectEvent=msg.data.data;switch(connectEvent.eventType){case window.webapis[INSTANTIATED_NAMESPACE].EVENT_DEVICE_CONNECT:for(var i=0;i<window.webapis[INSTANTIATED_NAMESPACE].connectCallbackArr.length;i++)window.webapis[INSTANTIATED_NAMESPACE].connectCallbackArr[i].callback(connectEvent);break;case window.webapis[INSTANTIATED_NAMESPACE].EVENT_DEVICE_DISCONNECT:for(var i=0;i<window.webapis[INSTANTIATED_NAMESPACE].connectCallbackArr.length;i++)window.webapis[INSTANTIATED_NAMESPACE].connectCallbackArr[i].callback(connectEvent);for(var nCount=0;nCount<window.webapis.microphone.MicrophoneArray.length;nCount++){var nDevice=window.webapis.microphone.MicrophoneArray[nCount];uniqueID=nDevice.getUniqueId();if(uniqueID==connectEvent.uid){nDevice.stop(window.webapis.microphone.MICROPHONE_STATUS_PLAY|window.webapis.microphone.MICROPHONE_STATUS_RECORD);nDevice.disableDevice();}}window.webapis.microphone.removeSpecificDevice(connectEvent.uid,window.webapis.microphone.MicrophoneArray,window.webapis.microphone.MicrophoneValidArray);break;default:console.log("[microphone.js]unknow event :  "+connectEvent.eventType);break;}},create:function(){if(ppMicro!=null){ppMicro=getPlugin();if(this.getConnectedDeviceInfo(0)==window.webapis.microphone.OCI_ERR)return window.webapis.microphone.OCI_ERR;}else return window.webapis.microphone.OCI_ERR;},isConnected:function(uid){if(!window.webapis._checkTypeValid("DOMString",uid))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'uid' parameter");ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"IsConnected",uid:uid});if(message.code==0)return message.data;else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},getConnectedDeviceInfo:function(order){ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"GetConnectedDeviceInfo",uid:order});if(message.code==0)return message.data;else if(message.code==9080)return null;else{console.log("[microphone.js] getConnectedDeviceInfo error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},parseDeviceEvent:function(sParam){var event=sParam.split(window.webapis.microphone.DELIMITER_EVENT_PARAM);if(event!=null){var deviceEvent=new window.webapis.microphone.OCIDevInfo();deviceEvent.eventType=Number(event[0]);deviceEvent.uid=String(event[1]);deviceEvent.name=String(event[2]);deviceEvent.deviceType=Number(event[5]);return deviceEvent;}return null;},isAvailable:function(uniqueID,arrayDevice,arrayValid){for(var nCount=0;nCount<arrayDevice.length;nCount++)if(arrayDevice[nCount].getUniqueId()==uniqueID){arrayValid[nCount]=true;return nCount;}return null;},removeSpecificDevice:function(uniqueID,arrayDevice,arrayValid){var arrayID=this.isAvailable(uniqueID,arrayDevice,arrayValid);if(arrayID!=null){var deviceID=arrayDevice[arrayID].getDeviceId();delete arrayDevice[arrayID];this._destroyDevice(deviceID);arrayDevice.splice(arrayID,1);arrayValid.splice(arrayID,1);}},removeDevices:function(arrayDevice,arrayValid){if(arrayValid.length)for(var iCount=arrayValid.length-1;iCount>=0;iCount--)if(arrayValid[iCount]==false){this._destroyDevice(arrayDevice[iCount].getDeviceId());arrayDevice.splice(iCount,1);arrayValid.splice(iCount,1);}},getConnectedDevices:function(arrayDevice,arrayValid,successCallback,classDevice){for(var iCount=0;iCount<arrayDevice.length;iCount++)arrayValid[iCount]=false;var iNum=0;while(1){var saDevInfo=null;saDevInfo=this.getConnectedDeviceInfo(iNum++);if(saDevInfo==null)break;if(this.isAvailable(saDevInfo.uid,arrayDevice,arrayValid)==null){var iDeviceID=this._createDevice(saDevInfo.uid);if(iDeviceID!=this.OCI_ERR){var newDevice=new classDevice(saDevInfo,iDeviceID);arrayDevice.push(newDevice);}}}this.removeDevices(arrayDevice,arrayValid);successCallback(arrayDevice);},setFilePath:function(filepath){var filename='';console.log("microphone setFilePath  filepath="+filepath);if(filepath.indexOf('/')!=-1){filename=filepath.substring(7,filepath.length);var preFilename=filepath.substring(0,7);preFilename=preFilename.toLowerCase();if(preFilename!='file://'){if(preFilename=='http://')return filepath;else if(preFilename=='usb://s'){filename='/opt/storage/usb/'+filepath.substring(6,filepath.length);return filename;}return null;}if(filename[0]=='/'||filename.search(':')==-1||filename.indexOf("..")!=-1)return null;}else filename=filepath;var strLocalPath=window.location.pathname;var deleteIndex=strLocalPath.indexOf('/res/wgt/');if(deleteIndex!=-1){var pFilePath=strLocalPath.substring(0,deleteIndex)+'/res/wgt/';pFilePath=decodeURI(pFilePath+filename);return pFilePath;}return null;},destroy:function(){},isSupported:function(){return true;},getMicrophones:function(successCallback,errorCallback){if(!window.webapis._checkTypeValid("function",successCallback))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'successCallback' parameter");if(errorCallback&&!window.webapis._checkTypeValid("function",errorCallback))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid errorCallback type passed for 'errorCallback' parameter");var timeout=1;setTimeout(function(){webapis.microphone.getConnectedDevices(webapis.microphone.MicrophoneArray,webapis.microphone.MicrophoneValidArray,successCallback,webapis.microphone.MicrophoneDevice);},timeout);},addMicrophoneConnectListener:function(listener){if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid function type passed for 'listener' parameter");var listenerId=this.callbackCount++;this._addConnectCallback(listenerId,listener);console.log("[ppMicrophone.js] addMicrophoneConnectListener listenerId: "+listenerId);return listenerId;},removeMicrophoneConnectListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter");var callback=this._removeConnectCallbackById(listenerId);if(null==callback){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_FOUND_ERR,"NotFoundError","Can not find Listener by this listenerId ["+listenerId+"]");return;}},_createDevice:function(uid){ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"CreateMicrophone",uid:uid});if(message.code==0)return message.data;else return null;},_destroyDevice:function(deviceId){ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"DestroyMicrophone",microphoneId:deviceId});if(message.code==0){console.log("[microphone.js]: _destroyDevice ");return;}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);},MicrophoneDevice:function(devInfo,deviceID){INTERFACE_COMMAND="Microphone";this.uid=devInfo.uid;this.deviceId=deviceID;this.deviceCallback=null;this.deviceType=devInfo.deviceType;if(this.deviceType===0&&devInfo.name==="")this.name="USB Microphone "+this.deviceId;else this.name=devInfo.name;this.getUniqueId=function(){return this.uid;};this.getDeviceId=function(){return this.deviceId;};this.getName=function(){return this.name;};this.enableDevice=function(format,sampleRate){if(!window.webapis._checkTypeValid("long",format))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'format' parameter");else if(format!==webapis.microphone.MICROPHONE_FORMAT_SIGNED_16BIT_LITTLE_ENDIAN&&format!==webapis.microphone.MICROPHONE_FORMAT_SIGNED_16BIT_BIG_ENDIAN_FORMAT)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'format' parameter");if(!window.webapis._checkTypeValid("long",sampleRate))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'sampleRate' parameter");else if(sampleRate!==webapis.microphone.MICROPHONE_SAMPLE_RATE_48000&&sampleRate!==webapis.microphone.MICROPHONE_SAMPLE_RATE_44100&&sampleRate!==webapis.microphone.MICROPHONE_SAMPLE_RATE_32000&&sampleRate!==webapis.microphone.MICROPHONE_SAMPLE_RATE_16000&&sampleRate!==webapis.microphone.MICROPHONE_SAMPLE_RATE_8000)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'sampleRate' parameter");var ret;ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"EnableAudioIn",deviceID:this.deviceId,format:format,framerate:sampleRate});if(message.code==0)ret=message.data;if(ret!=webapis.microphone.OCI_NO_ERR){console.log("[OCI_microphone_enable]: ERROR = "+ret);return false;}return true;};this.disableDevice=function(){var ret;ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"DisableAudioIn",deviceID:this.deviceId});if(message.code==0)ret=message.data;if(ret!=webapis.microphone.OCI_NO_ERR){console.log("[OCI_microphone_disable]: ERROR = "+ret);return false;}return true;};this.playRecord=function(state,fileName,lockState){if(state&&!window.webapis._checkTypeValid("long",state))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'state' parameter");if(fileName&&!window.webapis._checkTypeValid("DOMString",fileName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'fileName' parameter");if(lockState&&!window.webapis._checkTypeValid("boolean",lockState))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'lockState' parameter");if(typeof state=="undefined")state=webapis.microphone.MICROPHONE_STATUS_PLAY;if(typeof lockState=="undefined")lockState=true;if(typeof fileName=="undefined")fileName="";ppMicro=getPlugin();var result;var message=ppMicro.postMessageAndAwaitResponse({command:"PlayAudioIn",deviceID:this.deviceId,strLockState:lockState,nState:state,strFilename:fileName});if(message.code==0)result=message.data;var ret=false;if(result==webapis.microphone.OCI_NO_ERR)ret=true;return ret;};this.stop=function(state){if(state&&!window.webapis._checkTypeValid("long",state))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'state' parameter");if(typeof state=="undefined")state=webapis.microphone.MICROPHONE_STATUS_PLAY;ppMicro=getPlugin();var result;var message=ppMicro.postMessageAndAwaitResponse({command:"StopAudioIn",deviceID:this.deviceId,nState:state});if(message.code==0)result=message.data;var ret=false;if(result==webapis.microphone.OCI_NO_ERR)ret=true;return ret;};this.play=function(lockState){if(lockState&&!window.webapis._checkTypeValid("boolean",lockState))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'lockState' parameter");if(typeof lockState=="undefined")lockState=true;var ret=this.playRecord(webapis.microphone.MICROPHONE_STATUS_PLAY,"",lockState);if(ret==false)console.log("play ERROR = "+ret);return ret;};this.stopPlay=function(){var ret=this.stop(webapis.microphone.MICROPHONE_STATUS_PLAY);if(ret==false)console.log("stopPlay ERROR = "+ret);return ret;};this.record=function(fileName){if(!window.webapis._checkTypeValid("DOMString",fileName))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'fileName' parameter");ppMicro=getPlugin();var result;var message=ppMicro.postMessageAndAwaitResponse({command:"GetVersion"});if(message.code==0)result=message.data;var ret=false;if(typeof fileName!="undefined"){if(Number(result)>=2.0){fileName=webapis.microphone.setFilePath(fileName);if(fileName!=null)ret=this.playRecord(webapis.microphone.MICROPHONE_STATUS_RECORD,fileName,true);}if(ret==false)console.log("record ERROR = "+ret);}return ret;};this.stopRecord=function(){ppMicro=getPlugin();var result;var message=ppMicro.postMessageAndAwaitResponse({command:"GetVersion"});if(message.code==0)result=message.data;var ret=false;if(Number(result)>=2.0)ret=this.stop(webapis.microphone.MICROPHONE_STATUS_RECORD);if(ret==false)console.log("stopRecord ERROR = "+ret);return ret;};this.getVolumeLevel=function(){ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"GetAudioInVolumeLevel",deviceID:this.deviceId});if(message.code==0)ret=message.data;return ret;};this.setVolumeLevel=function(volume){if(!window.webapis._checkTypeValid("long",volume))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'volume' parameter");ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"SetAudioInVolumeLevel",deviceID:this.deviceId,volume:volume});if(message.code==0)ret=message.data;if(ret!=webapis.microphone.OCI_NO_ERR){console.log("setVolumeLevel function only work while playing");return false;}return true;};this.getSupportedEffect=function(){ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"GetSupportedAudioInEffects",deviceID:this.deviceId});if(message.code==0)ret=message.data;return ret;};this.getEnabledEffect=function(){ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"GetEnabledAudioInEffects",deviceID:this.deviceId});if(message.code==0)ret=message.data;return ret;};this.setEffect=function(effect,enable,tempo,pitch,rate,threshold,noduration){if(!window.webapis._checkTypeValid("long",effect))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'effect' parameter");else if(effect!==webapis.microphone.MICROPHONE_EFFECT_NONE&&effect!==webapis.microphone.MICROPHONE_EFFECT_REVERB&&effect!==webapis.microphone.MICROPHONE_EFFECT_FILTER)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'effect' parameter");if(!window.webapis._checkTypeValid("boolean",enable))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid boolean type passed for 'enable' parameter");if(!window.webapis._isNullOrUndefined(tempo))if(!window.webapis._checkTypeValid("long",tempo))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'tempo' parameter");else if(tempo<-95.0||tempo>5000.0)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'tempo' parameter");if(!window.webapis._isNullOrUndefined(pitch))if(!window.webapis._checkTypeValid("long",pitch))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'pitch' parameter");else if(pitch<-60.0||pitch>60.0)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'pitch' parameter");if(!window.webapis._isNullOrUndefined(rate))if(!window.webapis._checkTypeValid("long",rate))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'rate' parameter");else if(rate<-95.0||rate>5000.0)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'rate' parameter");if(!window.webapis._isNullOrUndefined(threshold))if(!window.webapis._checkTypeValid("long",threshold))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'threshold' parameter");else if(threshold<0)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'threshold' parameter");if(!window.webapis._isNullOrUndefined(noduration))if(!window.webapis._checkTypeValid("long",noduration))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'noduration' parameter");else if(noduration<0)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'noduration' parameter");var enableFlag=0;if(enable==true)enableFlag=1;else enableFlag=0;if(typeof tempo=="undefined")tempo=0;if(typeof pitch=="undefined")pitch=0;if(typeof rate=="undefined")rate=0;if(typeof threshold=="undefined")threshold="";if(typeof noduration=="undefined")noduration="";ppMicro=getPlugin();var param=String(tempo)+','+String(pitch)+','+String(rate)+','+String(threshold)+','+String(noduration);console.log("param: "+param);var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"SetAudioInEffect",deviceID:this.deviceId,effect:effect,enableFlag:enableFlag,strParam:param});if(message.code==0)ret=message.data;if(ret==webapis.microphone.OCI_NO_ERR)return true;return false;};this.registerDeviceCallback=function(callback){if(typeof callback=='function'){this.deviceCallback=callback;ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"RegisterCallback"});if(message.code==0)ret=message.data;}else{this.deviceCallback=null;ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"UnregisterCallback"});if(message.code==0)ret=message.data;}};this.getFilterVolume=function(){ppMicro=getPlugin();var ret;var message=ppMicro.postMessageAndAwaitResponse({command:"GetFilterVolume",deviceID:this.deviceId});if(message.code==0)ret=message.data;return ret;};this.addMicrophoneEventListener=function(listener){var listenerId=-1;if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid function type passed for 'listener' parameter");ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"RegisterMicrophoneCallback",microphoneId:this.deviceId});if(message.code==0)listenerId=ppMicro.addListener(EVENT_FROM_DEVICE,function(msg){var eventMsg=msg.data.data;console.log("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"+eventMsg);listener(eventMsg);});else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);return listenerId;};this.removeMicrophoneEventListener=function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter");ppMicro=getPlugin();var message=ppMicro.postMessageAndAwaitResponse({command:"UnregisterMicrophoneCallback",microphoneId:this.deviceId});if(message.code==0){var flag=ppMicro.removeListenerById(EVENT_FROM_DEVICE,listenerId);console.log("removeListenerById "+flag);return;}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);};},getVersion:function(){return exec("getVersion");}};})(this);(function(window){var MOD_NAME="ContentsInfo";var INSTANTIATED_NAMESPACE="contentsinfo";var PEPPER_PLUGIN_NAME="contentsinfo";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var CONTENTS_INFO_EVENT="CONTENTS_INFO_EVENT";var ppContentsInfo=null;window.webapis[INSTANTIATED_NAMESPACE]={EVENT_CHANNEL_CHANGED:1,EVENT_PROGRAM_CHANGED:2,EVENT_ACR_MESSAGE:13,getVersion:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[contentsinfo] getVersion message data "+message.data);return message.data;}else{console.log("[contentsinfo] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentChannelName:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentChannelName"});if(message.code==0){console.log("[contentsinfo] getCurrentChannelName message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentChannelName error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentChannelId:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentChannelId"});if(message.code==0){console.log("[contentsinfo] getCurrentChannelId message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentChannelId error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentProgramName:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentProgramName"});if(message.code==0){console.log("[contentsinfo] getCurrentProgramName message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentProgramName error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentProgramId:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentProgramId"});if(message.code==0){console.log("[contentsinfo] getCurrentProgramId message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentProgramId error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getAcrMessage:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getAcrMessage"});if(message.code==0){console.log("[contentsinfo] getAcrMessage message data "+message.data);return message.data;}else{console.log("[contentsinfo] getAcrMessage error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentContentsAdditionalInfo:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentContentsAdditionalInfo"});if(message.code==0){console.log("[contentsinfo] getCurrentContentsAdditionalInfo message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentContentsAdditionalInfo error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getCurrentContentsInfo:function(){ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"getCurrentContentsInfo"});if(message.code==0){console.log("[contentsinfo] getCurrentContentsInfo message data "+message.data);return message.data;}else{console.log("[contentsinfo] getCurrentContentsInfo error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},addEventListener:function(listener){if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid function type passed for 'listener' parameter");ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppContentsInfo.postMessageAndAwaitResponse({command:"addEventListener"});if(message.code==0){var listenerId=ppContentsInfo.addListener(CONTENTS_INFO_EVENT,function(msg){listener(msg.data.code,msg.data.data);});return listenerId;}else{console.log("[contentsinfo] addEventListener error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},removeEventListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter");ppContentsInfo=ppContentsInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var listener=ppContentsInfo.getListenerById(CONTENTS_INFO_EVENT,listenerId);if(!listener||listener.length==0)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","This listenerId ["+listenerId+"] is invalid");var message=ppContentsInfo.postMessageAndAwaitResponse({command:"removeEventListener"});if(message.code==0){console.log("[contentsinfo] removeEventListener success");var flag=ppContentsInfo.removeListenerById(CONTENTS_INFO_EVENT,listenerId);}else{console.log("[contentsinfo] addEventListener error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="AvInfo";var INSTANTIATED_NAMESPACE="avinfo";var PEPPER_PLUGIN_NAME="avinfo";var HDMI_ACTIVATED_INFO_CHANGED="HDMI_ACTIVATED_INFO_CHANGED";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppAvInfo=null;var hasListener=0;var AvInfoSoundOutputMode={SOUND_TV_OUTPUT_SPEAKER:0,SOUND_TV_OUTPUT_EXTERNAL_SPEAKER:1,SOUND_TV_OUTPUT_RECEIVER:2,SOUND_TV_OUTPUT_SOUND_SHARE:3,SOUND_TV_OUTPUT_MULTIROOM_LINK:4,SOUND_TV_OUTPUT_BT_HEADSET:5,SOUND_TV_OUTPUT_DUAL_BT_SPK:6,SOUND_TV_OUTPUT_MAX:7,SOUND_TV_OUTPUT_DUAL_RECEIVER_SPK:8,SOUND_TV_OUTPUT_DUAL_EXTERNAL_SPK:9,SOUND_TV_OUTPUT_DUAL_MULTIROOM_SPK:10};var AvInfoDigitalCompMode={DOLBY_DIGITAL_COMP_MODE_LINE:0,DOLBY_DIGITAL_COMP_MODE_RF:1};var AvInfoColorSpaceType;(function(AvInfoColorSpaceType){AvInfoColorSpaceType[AvInfoColorSpaceType.red=0]="red";AvInfoColorSpaceType[AvInfoColorSpaceType.green=1]="green";AvInfoColorSpaceType[AvInfoColorSpaceType.blue=2]="blue";AvInfoColorSpaceType[AvInfoColorSpaceType.yellow=3]="yellow";AvInfoColorSpaceType[AvInfoColorSpaceType.cyan=4]="cyan";AvInfoColorSpaceType[AvInfoColorSpaceType.magenta=5]="magenta";})(AvInfoColorSpaceType||(AvInfoColorSpaceType={}));var AvInfoSetColorEffectType;(function(AvInfoSetColorEffectType){AvInfoSetColorEffectType[AvInfoSetColorEffectType.OFF=0]="OFF";AvInfoSetColorEffectType[AvInfoSetColorEffectType.ON=1]="ON";})(AvInfoSetColorEffectType||(AvInfoSetColorEffectType={}));var AvInfoSubAmpMode={NO_EXT_AUDIO:0,EXT_AUDIO_TV:1,EXT_AUDIO_SWITCH:2,EXT_HEALTHCARE:3};window.webapis[INSTANTIATED_NAMESPACE]={AvInfoSoundOutputMode:AvInfoSoundOutputMode,AvInfoDigitalCompMode:AvInfoDigitalCompMode,getVersion:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[AvInfo.js] getVersion message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isHdrTvSupport:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"isHdrTvSupport"});if(message.code==0){console.log("[AvInfo.js] isHdrTvSupport message data "+message.data);return message.data;}else{console.log("[AvInfo.js] isHdrTvSupport error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSpeakerSelection:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getSpeakerSelection"});if(message.code==0){console.log("[AvInfo.js] getSpeakerSelection message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getSpeakerSelection error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSpeakerSelection:function(soundMode){if(!window.webapis._enumCheckerObj(AvInfoSoundOutputMode,soundMode)){if(!window.webapis._checkTypeValid("long",soundMode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AvInfoSoundOutputMode type passed for 'soundMode' parameter");throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AvInfoSoundOutputMode value passed for 'soundMode' parameter");}ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setSpeakerSelection",outputRoute:soundMode});if(message.code==0){console.log("[AvInfo.js] setSpeakerSelection message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setSpeakerSelection error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSubAmpMode:function(mode){webapis._validator.validateArgs(arguments,[{name:'mode',type:webapis._validator.Types.ENUM,values:Object.keys(AvInfoSubAmpMode)}]);ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setSubAmpMode",mode:AvInfoSubAmpMode[mode]});if(message.code==0){console.log("[AvInfo.js] setSubAmpMode message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setSubAmpMode error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setWideScreenMode:function(desktopId,screenMode){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_SUPPORTED_ERR,"NotSupportedError","setWideScreenMode is deprecated since 4.0");},getDolbyDigitalCompMode:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getDolbyDigitalCompMode"});if(message.code==0){console.log("[AvInfo.js] getDolbyDigitalCompMode message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getDolbyDigitalCompMode error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getBrightness:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getBrightness"});if(message.code==0){console.log("[AvInfo.js] getBrightness message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getBrightness error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setBrightness:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setBrightness",value:value});if(message.code==0){console.log("[AvInfo.js] setBrightness message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setBrightness error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getContrast:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getContrast"});if(message.code==0){console.log("[AvInfo.js] getContrast message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getContrast error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setContrast:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setContrast",value:value});if(message.code==0){console.log("[AvInfo.js] setContrast message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setContrast error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getSharpness:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getSharpness"});if(message.code==0){console.log("[AvInfo.js] getSharpness message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getSharpness error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setSharpness:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setSharpness",value:value});if(message.code==0){console.log("[AvInfo.js] setSharpness message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setSharpness error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getBacklight:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getBacklight"});if(message.code==0){console.log("[AvInfo.js] getBacklight message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getBacklight error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setBacklight:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setBacklight",value:value});if(message.code==0){console.log("[AvInfo.js] setBacklight message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setBacklight error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setColorEffect:function(value){if(!window.webapis._checkTypeValid("DOMString",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'colorEffectOnOff' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var selectedEffect=AvInfoSetColorEffectType[value];console.log("[AvInfo.js] ["+value+"] selectedEffect is ["+selectedEffect+"]");var message=ppAvInfo.postMessageAndAwaitResponse({command:"setColorEffect",colorEffect:selectedEffect});if(message.code==0){console.log("[AvInfo.js] setColorEffect message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setColorEffect error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getColorSpaceCustomRGB:function(color){if(!window.webapis._checkTypeValid("DOMString",color))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'color' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var selecetedColor=AvInfoColorSpaceType[color];console.log("[AvInfo.js] ["+color+"] selecetedColor is ["+selecetedColor+"]");var message=ppAvInfo.postMessageAndAwaitResponse({command:"getColorSpaceCustomRGB",color:selecetedColor});if(message.code==0){console.log("[AvInfo.js] getColorSpaceCustomRGB message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getColorSpaceCustomRGB error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setColorSpaceCustomRGB:function(color,red,green,blue){if(!window.webapis._checkTypeValid("DOMString",color))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'color' parameter");if(!window.webapis._checkTypeValid("long",red))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'red' parameter");if(!window.webapis._checkTypeValid("long",green))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'green' parameter");if(!window.webapis._checkTypeValid("long",blue))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'blue' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var selecetedColor=AvInfoColorSpaceType[color];console.log("[AvInfo.js] ["+color+"] selecetedColor is ["+selecetedColor+"]");var message=ppAvInfo.postMessageAndAwaitResponse({command:"setColorSpaceCustomRGB",color:selecetedColor,red:red,green:green,blue:blue});if(message.code==0){console.log("[AvInfo.js] setColorSpaceCustomRGB message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setColorSpaceCustomRGB error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getColorStrength:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getColorStrength"});if(message.code==0){console.log("[AvInfo.js] getColorStrength message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getColorStrength error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setColorStrength:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setColorStrength",value:value});if(message.code==0){console.log("[AvInfo.js] setColorStrength message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setColorStrength error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getColorTint:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getColorTint"});if(message.code==0){console.log("[AvInfo.js] getColorTint message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getColorTint error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setColorTint:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setColorTint",value:value});if(message.code==0){console.log("[AvInfo.js] setColorTint message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setColorTint error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getWhiteBalance:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getWhiteBalance"});if(message.code==0){console.log("[AvInfo.js] getWhiteBalance message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getWhiteBalance error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setWhiteBalance:function(offset_r,offset_g,offset_b,gain_r,gain_g,gain_b){if(!window.webapis._checkTypeValid("long",offset_r))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'offset_r' parameter");if(!window.webapis._checkTypeValid("long",offset_g))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'offset_g' parameter");if(!window.webapis._checkTypeValid("long",offset_b))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'offset_b' parameter");if(!window.webapis._checkTypeValid("long",gain_r))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'gain_r' parameter");if(!window.webapis._checkTypeValid("long",gain_g))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'gain_g' parameter");if(!window.webapis._checkTypeValid("long",gain_b))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'gain_b' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setWhiteBalance",offset_r:offset_r,offset_g:offset_g,offset_b:offset_b,gain_r:gain_r,gain_g:gain_g,gain_b:gain_b});if(message.code==0){console.log("[AvInfo.js] setWhiteBalance message data "+message.data);return message.data;}else{console.log("[AvInfo.js] setWhiteBalance error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},resetPictureSettings:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"resetPictureSettings"});if(message.code==0){console.log("[AvInfo.js] resetPicture message data "+message.data);return message.data;}else{console.log("[AvInfo.js] resetPicture error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setHdmiActivateChangeListener:function(onstatechange){if(!window.webapis._checkTypeValid("function",onstatechange))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid AvInfoChangeCallback type passed for 'onstatechange' parameter");if(hasListener==0){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setHdmiActivateChangeListener"});if(message.code!=0){console.log("[avinfo.js] setHdmiActivateChangeListener error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else{hasListener=1;ppAvInfo.addListener(HDMI_ACTIVATED_INFO_CHANGED,function(msg){onstatechange(msg.data.data);});}}else console.log("[avinfo.js] no need to setHdmiActivateChangeListener again");},unsetHdmiActivateChangeListener:function(){if(hasListener==1){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"unsetHdmiActivateChangeListener"});if(message.code==0){console.log("[ppAvInfo.js] unsetHdmiActivateChangeListener success");hasListener=0;}else{console.log("[AvInfo.js] unsetHdmiActivateChangeListener error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}else console.log("[avinfo.js] no need to unsetHdmiActivateChangeListener");},getHdmiHdcpType:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getHdmiHdcpType"});if(message.code==0){console.log("[AvInfo.js] getHdmiHdcpType message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getHdmiHdcpType error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getHdmiHighestResolution:function(){ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"getHdmiHighestResolution"});if(message.code==0){console.log("[AvInfo.js] getHdmiHighestResolution message data "+message.data);return message.data;}else{console.log("[AvInfo.js] getHdmiHighestResolution error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setAiScalerValue:function(value){if(!window.webapis._checkTypeValid("long",value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'value' parameter");ppAvInfo=ppAvInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAvInfo.postMessageAndAwaitResponse({command:"setAiScalerValue",value:value});if(message.code==0){console.log("[AvInfo.js] setAiScalerValue message data "+message.data);return;}else{console.log("[AvInfo.js] setAiScalerValue error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="billing";var INSTANTIATED_NAMESPACE="billing";var PEPPER_PLUGIN_NAME="billing";var RequestPurchaseHistoryType={"ALL":"0","SUBSCRIPTION":"1","NON_SUBSCRIPTION":"2"};var RequestServerType={DUMMY:"DUMMY",WORKING:"WORKING",DEV:"DEV",PRD:"PRD"};if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppBilling=null;window.webapis[INSTANTIATED_NAMESPACE]={RequestPurchaseHistoryType:RequestPurchaseHistoryType,RequestServerType:RequestServerType,getVersion:function(){console.log("[BILLING_PP] Billing getVersion");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppBilling.postMessageAndAwaitResponse({command:'billing_plugin_getVersion'});if(result.code==0){console.log("[billing.js] getVersion : message data "+result.data);return result.data;}else{console.log("[billing.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}return result;},applyInvoice:function(appId,customId,invoiceId,countryCode,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!window.webapis._checkTypeValid("DOMString",customId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'customId' parameter");if(!window.webapis._checkTypeValid("DOMString",invoiceId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'invoiceId' parameter");if(!window.webapis._checkTypeValid("DOMString",countryCode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'applyInvoice',appId:appId,countryCode:countryCode,customId:customId,invoiceId:invoiceId,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},verifyInvoice:function(appId,customId,invoiceId,countryCode,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!window.webapis._checkTypeValid("DOMString",customId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'customId' parameter");if(!window.webapis._checkTypeValid("DOMString",invoiceId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'invoiceId' parameter");if(!window.webapis._checkTypeValid("DOMString",countryCode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType value passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'verifyInvoice',appId:appId,countryCode:countryCode,customId:customId,invoiceId:invoiceId,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},isServiceAvailable:function(serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'serviceAvailable',server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},getServiceCountryAvailability:function(appId,countryCodes,checkValue,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!Array.isArray(countryCodes))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid Array type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",checkValue))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'checkValue' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'serviceAvailability',appId:appId,countryCodes:countryCodes.toString(),checkValue:checkValue,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},getUserPurchaseList:function(appId,customId,countryCode,pageNumber,checkValue,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!window.webapis._checkTypeValid("DOMString",customId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'customId' parameter");if(!window.webapis._checkTypeValid("DOMString",countryCode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",pageNumber))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'pageNumber' parameter");if(!window.webapis._checkTypeValid("DOMString",checkValue))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'checkValue' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'getUserPurchaseList',appId:appId,countryCode:countryCode,customId:customId,pageNumber:pageNumber,checkValue:checkValue,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},getProductsList:function(appId,countryCode,pageSize,pageNumber,checkValue,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!window.webapis._checkTypeValid("DOMString",countryCode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",pageSize))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'pageSize' parameter");if(!window.webapis._checkTypeValid("DOMString",pageNumber))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'pageNumber' parameter");if(!window.webapis._checkTypeValid("DOMString",checkValue))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'checkValue' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'getProductsList',appId:appId,countryCode:countryCode,pageSize:pageSize,pageNumber:pageNumber,checkValue:checkValue,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},cancelSubscription:function(appId,invoiceId,customId,countryCode,serverType,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",appId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appId' parameter");if(!window.webapis._checkTypeValid("DOMString",countryCode))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'countryCode' parameter");if(!window.webapis._checkTypeValid("DOMString",invoiceId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'pageSize' parameter");if(!window.webapis._checkTypeValid("DOMString",customId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'pageNumber' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'cancelSubscription',appId:appId,countryCode:countryCode,invoiceId:invoiceId,customId:customId,server_type:serverType},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={apiResult:((typeof (msgData.apiResult)=='undefined')?'':msgData.apiResult)};else data={apiResult:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},showRegisterPromotionalCode:function(callerAppId,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",callerAppId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'callerAppId' parameter");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isDeepLinkAvailable'});if(result.code==0&&result.data==true){var isNotavailableOnerrorCallback=(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror));var isNotavailableOnSuccessCallback=(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess));if(isNotavailableOnerrorCallback||isNotavailableOnSuccessCallback)ppBilling.postMessage({command:'showRegisterPromotionalCodeNoCB',callerAppId:callerAppId});else{console.log("[BILLING_PP] function onsuccess is valid");console.log("[BILLING_PP] function onerror is valid");ppBilling.postMessage({command:'showRegisterPromotionalCode',callerAppId:callerAppId},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={openDeepLinkResult:((typeof (msgData.deepLink_result)=='undefined')?'':msgData.deepLink_result),openDeepLinkDetail:((typeof (msgData.deepLink_addtional_data)=='undefined')?'':msgData.deepLink_addtional_data)};else data={openDeepLinkResult:'',openDeepLinkDetail:''};onsuccess&&onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});}}else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},showPaymentInfo:function(){ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'showPaymentInfo'});if(result.code==0)console.log("[billing.js] showPaymentInfo success");else{console.log("[billing.js] showPaymentInfo :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},showRegisterCreditCard:function(onsuccess,onerror){ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isDeepLinkAvailable'});if(result.code==0&&result.data==true){var isNotavailableOnerrorCallback=(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror));var isNotavailableOnSuccessCallback=(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess));if(isNotavailableOnerrorCallback||isNotavailableOnSuccessCallback)ppBilling.postMessage({command:'showRegisterCreditCardNoCB'});else{console.log("[BILLING_PP] function onsuccess is valid");console.log("[BILLING_PP] function onerror is valid");ppBilling.postMessage({command:'showRegisterCreditCard'},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={openDeepLinkResult:((typeof (msgData.deepLink_result)=='undefined')?'':msgData.deepLink_result),openDeepLinkDetail:((typeof (msgData.deepLink_addtional_data)=='undefined')?'':msgData.deepLink_addtional_data)};else data={openDeepLinkResult:'',openDeepLinkDetail:''};onsuccess&&onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});}}else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},showPurchaseHistory:function(historyApp,historyDetail,onsuccess,onerror){if(!window.webapis._checkTypeValid("DOMString",historyApp))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'historyApp' parameter");if(!window.webapis._checkTypeValid("DOMString",historyDetail))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'historyDetail' parameter");if(!RequestPurchaseHistoryType[historyDetail])throw window.webapis._createWebAPIException(webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid 'RequestPurchaseHistoryType' values passed for 'historyDetail' parameter");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isDeepLinkAvailable'});if(result.code==0&&result.data==true){var isNotavailableOnerrorCallback=(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror));var isNotavailableOnSuccessCallback=(!window.webapis._isNullOrUndefined(onsuccess)&&!window.webapis._checkTypeValid("function",onsuccess));if(isNotavailableOnerrorCallback||isNotavailableOnSuccessCallback)ppBilling.postMessage({command:'showPurchaseHistoryNoCB',historyApp:historyApp,historyDetail:RequestPurchaseHistoryType[historyDetail]});else{console.log("[BILLING_PP] function onsuccess is valid");console.log("[BILLING_PP] function onerror is valid");ppBilling.postMessage({command:'showPurchaseHistory',historyApp:historyApp,historyDetail:RequestPurchaseHistoryType[historyDetail]},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={openDeepLinkResult:((typeof (msgData.deepLink_result)=='undefined')?'':msgData.deepLink_result),openDeepLinkDetail:((typeof (msgData.deepLink_addtional_data)=='undefined')?'':msgData.deepLink_addtional_data)};else data={openDeepLinkResult:'',openDeepLinkDetail:''};onsuccess&&onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});}}else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}},buyItem:function(appid,serverType,paymentDetail,onsuccess,onerror){console.log("[BILLING_PP] call");if(!window.webapis._checkTypeValid("DOMString",appid))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'appid' parameter");if(!window.webapis._checkTypeValid("DOMString",serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'serverType' parameter");console.log("[BILLING_PP] param appid is valid");if(!window.webapis._enumCheckerObj(RequestServerType,serverType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid RequestServerType type passed for 'serverType' parameter");console.log("[BILLING_PP] param server_type is valid");if(!window.webapis._checkTypeValid("DOMString",paymentDetail))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'paymentDetail' parameter");console.log("[BILLING_PP] param paymentDetail is valid");if(!window.webapis._checkTypeValid("function",onsuccess))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid VersionSuccessCallback type passed for 'onsuccess' parameter");console.log("[BILLING_PP] function onsuccess is valid");if(!window.webapis._isNullOrUndefined(onerror)&&!window.webapis._checkTypeValid("function",onerror)){window.webapis._createFalsyAlert(onerror);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'onerror' parameter");}console.log("[BILLING_PP] function onerror is valid");ppBilling=ppBilling||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[BILLING_PP] get PepperPlugin[ppBilling] object success");var result=ppBilling.postMessageAndAwaitResponse({command:'isBuyItemAvailable'});if(result.code==0&&result.data==true)ppBilling.postMessage({command:'billing_plugin_request_payment',appid:appid,server_type:serverType,payInfo:paymentDetail},function(message){console.log("[BILLING_PP] message");var msgData=message.data;if(msgData.status==0){var data;if(""!=msgData)data={payResult:((typeof (msgData.pay_result)=='undefined')?'':msgData.pay_result),payDetail:((typeof (msgData.pay_detail)=='undefined')?'':msgData.pay_detail)};else data={payResult:'',payDetail:''};onsuccess.call(null,data);}else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.status,msgData.errorName,msgData.errorMessage));});else{console.log("[billing.js]"+result.errorMessage);onerror&&onerror.call(null,webapis._createWebAPIError(result.code,result.errorName,result.errorMessage));}}};})(this);(function(window){var MOD_NAME="Allshare";var INSTANTIATED_NAMESPACE="allshare";var PEPPER_PLUGIN_NAME="allshare";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ASF_DEVICE_STATUS_CHANGE="ASF_DEVICE_STATUS_CHANGE";var STR_IS_SEARCHABLE="isSearchable";var STR_ROOT="rootFolder";var ppSample=null;var serviceconnector={serviceProvider:serviceProvider,createServiceProvider:function(serviceProviderCreateSuccessCallback,serviceProviderErrorCallback){console.log("[sample.js] serviceProviderCreateSuccessCallback createServiceProvider");if(!window.webapis._isNullOrUndefined(serviceProviderCreateSuccessCallback)&&!window.webapis._checkTypeValid("function",serviceProviderCreateSuccessCallback)){window.webapis._createFalsyAlert(serviceProviderCreateSuccessCallback);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'serviceProviderCreateSuccessCallback' parameter");}console.log("[sample.js] serviceProviderErrorCallback createServiceProvider");if(!window.webapis._isNullOrUndefined(serviceProviderErrorCallback)&&!window.webapis._checkTypeValid("function",serviceProviderErrorCallback)){window.webapis._createFalsyAlert(serviceProviderErrorCallback);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'serviceProviderErrorCallback' parameter");}console.log("[sample.js] _getPepperPlugin createServiceProvider");ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);console.log("[sample.js] postMessage createServiceProvider");ppSample.postMessage({command:"createServiceProvider"},function(message){var msgData=message.data;if(msgData.code==0){console.log("[sample.js] postMessage createServiceProvider success");serviceProviderCreateSuccessCallback&&serviceProviderCreateSuccessCallback.call(null,serviceProvider);}else{console.log("[sample.js] postMessage createServiceProvider failed");if(msgData.code==29)throw window.webapis._createWebAPIError(0,message.errorName,message.errorMessage);else serviceProviderErrorCallback&&serviceProviderErrorCallback.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage,msgData.data));}});},deleteServiceProvider:function(serviceProviderDeleteSuccessCallback,serviceProviderErrorCallback){if(!window.webapis._isNullOrUndefined(serviceProviderDeleteSuccessCallback)&&!window.webapis._checkTypeValid("function",serviceProviderDeleteSuccessCallback)){window.webapis._createFalsyAlert(serviceProviderDeleteSuccessCallback);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'serviceProviderDeleteSuccessCallback' parameter");}if(!window.webapis._isNullOrUndefined(serviceProviderErrorCallback)&&!window.webapis._checkTypeValid("function",serviceProviderErrorCallback)){window.webapis._createFalsyAlert(serviceProviderErrorCallback);throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid ErrorCallback type passed for 'serviceProviderErrorCallback' parameter");}ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSample.postMessage({command:"deleteServiceProvider"},function(message){var msgData=message.data;if(msgData.code==0)serviceProviderDeleteSuccessCallback&&serviceProviderDeleteSuccessCallback.call(null,serviceProvider);else serviceProviderErrorCallback&&serviceProviderErrorCallback.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage),msgData.data);});},getServiceProvider:function(){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getServiceProvider"});if(message.code==0){console.log("[sample.js] getServiceProvider message data "+message.data);return serviceProvider;}else{console.log("[sample.js] getServiceProvider error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};var serviceProvider={getServiceState:function(){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getServiceState"});if(message.code==0){console.log("[sample.js] getServiceState message data "+message.data);return message.data;}else{console.log("[sample.js] getServiceState error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},refresh:function(){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"refresh"});if(message.code==0){console.log("[sample.js] refresh message data "+message.data);return;}else{console.log("[sample.js] refresh error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getDeviceFinder:function(){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getDeviceFinder"});if(message.code==0){console.log("[sample.js] getDeviceFinder message data "+message.data);return this;}else{console.log("[sample.js] getDeviceFinder error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getProperty:function(propertyName,deviceinfo){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getProperty",propertyName:propertyName,deviceinfo:deviceinfo});if(message.code==0){console.log("[sample.js] getProperty message data "+message.data);return message.data;}else{console.log("[sample.js] getProperty error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getDeviceList:function(name){if(!window.webapis._checkTypeValid("DOMString",name))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'name' parameter");ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getDeviceList",name:name});if(message.code==0){var mediaProvidersArray=[];for(index=0;index<message.data.length;index++){var MediaProviders={};MediaProviders.iconArray=[];MediaProviders.browse=function(folderItem,startIndex,requestCount,mediaProviderSuccessCallback,mediaProviderErrorCallback,browseFilter,sortMode){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var self=this;ppSample.postMessage({command:"browse",folderItem:folderItem,startIndex:startIndex,requestCount:requestCount,browseFilter:browseFilter,sortMode:sortMode,deviceinfo:self},function(message){var msgData=message.data;if(msgData.code==0)mediaProviderSuccessCallback&&mediaProviderSuccessCallback.call(null,msgData.data.sc_itemList,msgData.data.sc_fEndOfItems,msgData.data.sc_providerId);else mediaProviderErrorCallback&&mediaProviderErrorCallback.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});};MediaProviders.search=function(keyword,startIndex,requestCount,mediaProviderSuccessCallback,mediaProviderErrorCallback,searchFilter){ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var self=this;ppSample.postMessage({command:"search",keyword:keyword,startIndex:startIndex,requestCount:requestCount,searchFilter:searchFilter,deviceinfo:self},function(message){var msgData=message.data;if(msgData.code==0)mediaProviderSuccessCallback&&mediaProviderSuccessCallback.call(null,msgData.data.sc_itemList,msgData.data.sc_fEndOfItems,msgData.data.sc_providerId);else mediaProviderErrorCallback&&mediaProviderErrorCallback.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});};MediaProviders.deviceDomain=message.data[index].deviceDomain;MediaProviders.deviceType=message.data[index].deviceType;MediaProviders.id=message.data[index].id;MediaProviders.ipAddress=message.data[index].ipAddress;MediaProviders.modelName=message.data[index].modelName;MediaProviders.name=message.data[index].name;MediaProviders.nic=message.data[index].nic;MediaProviders.subtype=message.data[index].subtype;for(icon_index=0;icon_index<message.data[index].iconArray.length;icon_index++){MediaProviders.iconArray[icon_index]=message.data[index].iconArray[icon_index];MediaProviders.iconArray[icon_index].iconUri=message.data[index].iconArray[icon_index].iconUri;}MediaProviders.isSearchable=this.getProperty(STR_IS_SEARCHABLE,MediaProviders);MediaProviders.rootFolder=this.getProperty(STR_ROOT,MediaProviders);mediaProvidersArray[index]=MediaProviders;}return mediaProvidersArray;}else{console.log("[sample.js] getDeviceList error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getDevice:function(deviceType,deviceID){if(!window.webapis._checkTypeValid("DOMString",deviceType))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'deviceType' parameter");if(!window.webapis._checkTypeValid("DOMString",deviceID))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'deviceID' parameter");ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"getDevice",deviceType:deviceType,deviceID:deviceID});if(message.code==0){console.log("[sample;.js] getDeviceList message data "+message.data);return message.data;}else{console.log("[sample.js] getDevice error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},addDeviceDiscoveryListener:function(self){if(typeof self!='object'||self==null)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'self' parameter");if(!self.hasOwnProperty('ondeviceadded')||!window.webapis._checkTypeValid("function",self.ondeviceadded))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'self.ondeviceadded' parameter");if(!self.hasOwnProperty('ondeviceremoved')||!window.webapis._checkTypeValid("function",self.ondeviceremoved))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid SuccessCallback type passed for 'self.ondeviceremoved' parameter");ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSample.postMessageAndAwaitResponse({command:"addDeviceDiscoveryListener"});if(message.code==0){console.log("[sample.js] serviceProvider message data "+message.data);var listenerId=ppSample.addListener(ASF_DEVICE_STATUS_CHANGE,function(msg){if(msg.data.data.deviceStatus=="ASF_DEVICE_ADDED")self.ondeviceadded(msg.data.data);else if(msg.data.data.deviceStatus=="ASF_DEVICE_REMOVED")self.ondeviceremoved(msg.data.data);});return listenerId;}else{console.log("[sample.js] getServiceState error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},removeDeviceDiscoveryListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter");ppSample=ppSample||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var listener=ppSample.getListenerById(ASF_DEVICE_STATUS_CHANGE,listenerId);if(!listener||listener.length==0){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_FOUND_ERR,"NotFoundError","Can not find Listener by this listenerId ["+listenerId+"]");return;}var message=ppSample.postMessageAndAwaitResponse({command:"removeDeviceDiscoveryListener"});var flag=ppSample.removeListenerById(ASF_DEVICE_STATUS_CHANGE,listenerId);}};window.webapis[INSTANTIATED_NAMESPACE]={serviceconnector:serviceconnector};})(this);(function(window){var MOD_NAME="AppCGPlayer",INSTANTIATED_NAMESPACE="appcgplayer",PEPPER_PLUGIN_NAME="appcgplayer";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var pCGPlayer=null;var CGPLAYER_EVENT="CGPLAYER_EVENT";var EventListener_id=null;var oneventlistener=function(msg1,msg2,msg3){console.log("called :oneventlistener"+msg1+"$$"+msg2+"##"+msg3);var Eventlist=[];Eventlist[0]=msg1;Eventlist[1]=msg2;Eventlist[2]=msg3;console.log("[oneventlistener] msg :"+Eventlist[0]+", "+Eventlist[1]+","+Eventlist[2]);if(EventListener_id)EventListener_id&&EventListener_id.call(null,Eventlist[0],Eventlist[1],Eventlist[2]);};window.webapis[INSTANTIATED_NAMESPACE]={OnEvent:function(listener){if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid EventListener type passed for 'listener' parameter");EventListener_id=listener;pCGPlayer=pCGPlayer||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var t=pCGPlayer.postMessageAndAwaitResponse({command:"OnEvent"});if(t.code==0){console.log("[appcgplayer.js] OnEvent success ");var listenerId=pCGPlayer.addListener(CGPLAYER_EVENT,function(msg){oneventlistener(msg.data.data1,msg.data.data2,msg.data.data3);});return listenerId;}else{console.log("[appcgplayer.js] OnEvent error "+t.code);throw window.webapis._createWebAPIError(t.code,t.errorName,t.errorMessage);}},StartCloudGame:function(param1,param2,param3){pCGPlayer=pCGPlayer||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);try{var plugappcgplayer=document.getElementById("_ppapi_plugin_appcgplayer_div");if(plugappcgplayer){plugappcgplayer.style.width="1920px";plugappcgplayer.style.height="1080px";}}catch(e){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_FOUND_ERR,"TypeMismatchError","appcgplayer Plugin Not found");}var t=pCGPlayer.postMessageAndAwaitResponse({command:"StartCloudGame",param1:param1,param2:param2,param3:param3});if(t.code==0)return console.log("[appcgplayer.js] StartCloudGame message data "+t.data),t.data;throw console.log("[appcgplayer.js] StartCloudGame error "+t.code),window.webapis._createWebAPIError(t.code,t.errorName,t.errorMessage);},StopCloudGame:function(){pCGPlayer=pCGPlayer||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var t=pCGPlayer.postMessageAndAwaitResponse({command:"StopCloudGame"});if(t.code==0)return console.log("[appcgplayer.js] StopCloudGame message data "+t.data),t.data;throw console.log("[appcgplayer.js] StopCloudGame error "+t.code),window.webapis._createWebAPIError(t.code,t.errorName,t.errorMessage);},SendCommand:function(param1,param2,param3){pCGPlayer=pCGPlayer||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var t=pCGPlayer.postMessageAndAwaitResponse({command:"SendCommand",param1:param1,param2:param2,param3:param3});if(t.code==0)return console.log("[appcgplayer.js] SendCommand message data "+t.data),t.data;throw console.log("[appcgplayer.js] SendCommand error "+t.code),window.webapis._createWebAPIError(t.code,t.errorName,t.errorMessage);},SendStringCommand:function(param1,param2,param3){pCGPlayer=pCGPlayer||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var t=pCGPlayer.postMessageAndAwaitResponse({command:"SendStringCommand",param1:param1,param2:param2,param3:param3});if(t.code==0)return console.log("[appcgplayer.js] SendStringCommand message data "+t.data),t.data;throw console.log("[appcgplayer.js] SendStringCommand error "+t.code),window.webapis._createWebAPIError(t.code,t.errorName,t.errorMessage);}};})(this);(function(window){"use strict";var INSTANTIATED_NAMESPACE="certmanager";var PEPPER_PLUGIN_NAME="certmanager";var MOD_NAME="certmanager";var LOG_HEADER="["+MOD_NAME+"]";var helper;var ErrorCodes={CERTMANAGER_SUCCESS:0,CERTMANAGER_FAILURE:1,CERTMANAGER_EMPTY_PARAMS:2,CERTMANAGER_INCORRECT_APPID_MAGIC:3,CERTMANAGER_UNSUPPORTED_KEY_LENGTH:4,CERTMANAGER_KEY_ALREADY_GENERATED:5,CERTMANAGER_CSR_PARAMS_INCORRECT:6,CERTMANAGER_CERT_NOT_VALID_WITH_PK:7,CERTMANAGER_CERT_ALREADY_EXISTS:8,CERTMANAGER_PK_NOT_FOUND:9,CERTMANAGER_CERT_NOT_FOUND:10,CERTMANAGER_INTERNAL_ERROR:11};helper=(function(){var pluginInstance;var PARAM_TYPES={STRING:"DOMString",LONG:'long',SHORT:'short',FLOAT:'float',DOUBLE:'double',BOOLEAN:'boolean',FUNCTION:'function',UNKNOWN:'unknown',OBJECT:'object'};function getPlugin(){pluginInstance=pluginInstance||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(!pluginInstance)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_FOUND_ERR,"NotFoundError","Unable to get plugin: "+PEPPER_PLUGIN_NAME);return pluginInstance;}function checkParam(name,type,value){if(type!==PARAM_TYPES.UNKNOWN)if(type===PARAM_TYPES.OBJECT){if(value==null)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid "+type+" type passed for '"+name+"' parameter");if(typeof value!=='object')throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid "+type+" type passed for '"+name+"' parameter");}else if(!window.webapis._checkTypeValid(type,value))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid "+type+" type passed for '"+name+"' parameter");}function prepareParams(params){var obj={},i;obj.command=params.command;if(params.params&&params.params.length)for(i=0;i<4;i++)if(i<params.params.length){checkParam(params.params[i][0],params.params[i][1],params.params[i][2]);obj["param"+(i+1)]=params.params[i][2];}else obj["param"+(i+1)]="";return obj;}function parseResponse(response){if(!response)response={data:0,code:-1,errorName:"NO_RESPONSE",errorMessage:"No response from "+PEPPER_PLUGIN_NAME+" plugin"};if(response.code===0)return response.data;throw window.webapis._createWebAPIError(response.code,response.errorName,response.errorMessage);}function infoLogCall(params){console.log(LOG_HEADER+" pepper call:"+JSON.stringify(params));}function infoLogResponse(params){console.log(LOG_HEADER+" pepper response:"+JSON.stringify(params));}function postMessageAndAwaitResponse(config){var plugin=getPlugin();var params=prepareParams(config);infoLogCall(params);var response=plugin.postMessageAndAwaitResponse(params);infoLogResponse(response);return parseResponse(response);}return{PARAM_TYPES:PARAM_TYPES,getPlugin:getPlugin,postMessageAndAwaitResponse:postMessageAndAwaitResponse,checkParam:checkParam};}());if(!window.webapis){console.log(LOG_HEADER+" window.webapis is not defined");throw LOG_HEADER+" window.webapis is not defined";}window.webapis[INSTANTIATED_NAMESPACE]={CertManagerErrorCodes:ErrorCodes,isAvailable:function(){var config={command:'PingPlugin'};return !!helper.postMessageAndAwaitResponse(config);},registerApp:function(appId,secret){var config={command:'RegisterApp',params:[["appId",helper.PARAM_TYPES.STRING,appId],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},generatePrivateKey:function(appId,keyLength,secret){helper.checkParam("keyLength",helper.PARAM_TYPES.LONG,keyLength);var certmanKeyLength=keyLength===4096?"CERTMAN_KEY_LENGTH_4096":"CERTMAN_KEY_LENGTH_2048";var config={command:'GeneratePK',params:[["appId",helper.PARAM_TYPES.STRING,appId],["keyLength",helper.PARAM_TYPES.STRING,certmanKeyLength],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},removePrivateKey:function(appId,secret){var config={command:'RemovePK',params:[["appId",helper.PARAM_TYPES.STRING,appId],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},generateCSR:function(appId,certParams,secret){helper.checkParam("certParams",helper.PARAM_TYPES.OBJECT,certParams);var config={command:'GenerateCSR',params:[["appId",helper.PARAM_TYPES.STRING,appId],["certParams",helper.PARAM_TYPES.STRING,JSON.stringify(certParams)],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},getVersion:function(){var config={command:'GetVersion'};return helper.postMessageAndAwaitResponse(config);},getCertificate:function(appId,host,secret){var config={command:'GetCert',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},setCertificate:function(appId,host,cert,secret){var config={command:'SetCert',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host],["cert",helper.PARAM_TYPES.STRING,cert],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},removeCertificate:function(appId,host,secret){var config={command:'RemoveCert',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},getCertificatePath:function(appId,host){var config={command:'GetCertPath',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host]]};return helper.postMessageAndAwaitResponse(config);},getCertificatePaths:function(appId){var config={command:'GetCertPaths',params:[["appId",helper.PARAM_TYPES.STRING,appId]]};var response=helper.postMessageAndAwaitResponse(config);return JSON.parse(response);},peekSubject:function(appId,host,secret){var config={command:'PeekSubject',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);},peekNotAfter:function(appId,host,secret){var config={command:'PeekNotAfter',params:[["appId",helper.PARAM_TYPES.STRING,appId],["host",helper.PARAM_TYPES.STRING,host],["secret",helper.PARAM_TYPES.STRING,secret]]};return helper.postMessageAndAwaitResponse(config);}};Object.defineProperty(window.webapis,'certmanager',{writable:false});}(window));(function(window){var MOD_NAME="AudioCapture";var INSTANTIATED_NAMESPACE="audiocapture";var PEPPER_PLUGIN_NAME="audiocapture";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var BUFFER_FROM_AUDIO="AudioBuffer";var AUDIOCAPTURE_FRAME_SIZE_4096=4096;var AUDIOCAPTURE_CHANNEL_NUM_2=2;var ppCapture=null;var isTriggle=true;var AudioCaptureSampleRate={AUDIOCAPTURE_SAMPLE_RATE_44100:44100,AUDIOCAPTURE_SAMPLE_RATE_48000:48000};var getPlugin=function(){if(null!==ppCapture)return ppCapture;ppCapture=window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);if(null===ppCapture){console.log("[audiocapture.js]  init pepper plugin error ");return null;}return ppCapture;};window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){ppCapture=getPlugin();var message=ppCapture.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[audiocapture.js] getVersion message data "+message.data);return message.data;}else{console.log("[audiocapture.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},addAudioBufferListener:function(listener,samplerate){var listenerId=-1;if(!window.webapis._checkTypeValid("function",listener))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid function type passed for 'listener' parameter");if(samplerate&&!window.webapis._checkTypeValid("DOMString",samplerate))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'samplerate' parameter");else if(typeof samplerate=="undefined")samplerate=44100;else{samplerate=Number(samplerate.substring(0,5));if(!window.webapis._enumCheckerObj(AudioCaptureSampleRate,samplerate))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid AudioCaptureSampleRate value passed for 'samplerate' parameter");}ppCapture=getPlugin();var message=ppCapture.postMessageAndAwaitResponse({command:"AddAudioBufferListener",channel:AUDIOCAPTURE_CHANNEL_NUM_2,samplerate:samplerate,frame:AUDIOCAPTURE_FRAME_SIZE_4096});if(message.code===0){listenerId=ppCapture.addListener(BUFFER_FROM_AUDIO,function(msg){if(isTriggle){var eventMsg=msg.data.data;listener(eventMsg);}});}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);return listenerId;},startCapture:function(){if(!ppCapture)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,'InvalidStateError','Module window.webapis.audiocapture is not created');isTriggle=true;},stopCapture:function(){if(!ppCapture)throw window.webapis._createWebAPIError(window.webapis.WebAPIException.INVALID_STATE_ERR,'InvalidStateError','Module window.webapis.audiocapture is not created');isTriggle=false;},removeAudioBufferListener:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid long type passed for 'listenerId' parameter");ppCapture=getPlugin();var message=ppCapture.postMessageAndAwaitResponse({command:"RemoveAudioBufferListener"});if(message.code===0){var flag=ppCapture.removeListenerById(BUFFER_FROM_AUDIO,listenerId);console.log("RemoveAudioBufferListener remove Listener By Id : ["+flag+"]");isTriggle=true;return;}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};})(this);(function(window){var MOD_NAME="AdInfo";var INSTANTIATED_NAMESPACE="adinfo";var PEPPER_PLUGIN_NAME="adinfo";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var exec=function(api){console.log("[adinfo.js] "+api+" begin");ppAdInfo=ppAdInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAdInfo.postMessageAndAwaitResponse({command:api});if(message.code==0){console.log("[adinfo.js] "+api+" message data ["+message.data+"]");return message.data;}else{console.log("[adinfo.js] "+api+" error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};var ppAdInfo=null;window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){return exec("getVersion");},getTIFA:function(){return exec("getTIFA");},isLATEnabled:function(){return exec("isLATEnabled");}};})(this);(function(window){var MOD_NAME="DisplayRotator";var INSTANTIATED_NAMESPACE="displayrotator";var PEPPER_PLUGIN_NAME="displayrotator";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var DISPLAY_ROTATOR_CHANGED="DISPLAY_ROTATOR_CHANGED";var ppDisplayRotator=null;var ListenerID=null;var DisplayRotatorStatus;var ValueToStatus=function(value){var result="NOT_READY";switch(value){case -3:result="BREAKDOWN";break;case -2:result="ABNORMAL";break;case -1:result="NOT_READY";break;case 0:result="STOPPED";break;case 1:result="RUNNING_CLOCKWISE";break;case 2:result="RUNNING_COUNTERCLOCKWISE";break;default:console.log("There is no key can be converted");}return result;};var OrientationToValue=function(orientation){var result=-1;switch(orientation){case "INVALID":result=-1;break;case "PORTRAIT":result=0;break;case "LANDSCAPE":result=1;break;case "PORTRAIT_REVERSED":result=2;break;case "LANDSCAPE_REVERSED":result=3;break;default:console.log("There is no key can be converted");}return result;};var ValueToOrientation=function(value){var result="INVALID";switch(value){case -1:result="INVALID";break;case 0:result="PORTRAIT";break;case 1:result="LANDSCAPE";break;case 2:result="PORTRAIT_REVERSED";break;case 3:result="LANDSCAPE_REVERSED";break;default:console.log("There is no key can be converted");}return result;};window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"getVersion"});if(message.code===0){console.log("[displayrotator.js] getVersion message data "+message.data);return message.data;}else{console.log("[displayrotator.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isSupported:function(){ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"isSupported"});if(message.code===0){console.log("[displayrotator.js] isSupported message data "+message.data);return message.data;}else{console.log("[displayrotator.js] isSupported error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getStatus:function(){ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"getStatus"});if(message.code===0){console.log("[displayrotator.js] getStatus message data "+ValueToStatus(message.data));return ValueToStatus(message.data);}else{console.log("[displayrotator.js] getStatus error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getOrientation:function(){ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"getOrientation"});if(message.code===0){console.log("[displayrotator.js] getOrientation message data "+ValueToOrientation(message.data));return ValueToOrientation(message.data);}else{console.log("[displayrotator.js] getOrientation error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setOrientation:function(orientation,option){if(!window.webapis._checkTypeValid("DOMString",orientation))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DisplayRotatorOrientation type passed for 'orientation' parameter");if(orientation==="PORTRAIT_REVERSED"||orientation==="LANDSCAPE_REVERSED")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.NOT_SUPPORTED_ERR,"NotSupportedError","The orientation is NOT supported");if(orientation!=="PORTRAIT"&&orientation!=="LANDSCAPE")throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","Invalid value passed for 'orientation' parameter");ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"setOrientation",orientation:OrientationToValue(orientation)});if(message.code!==0){console.log("[displayrotator.js] setOrientation error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},setListener:function(onevent){if(!window.webapis._checkTypeValid("function",onevent))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DisplayRotatorListener type passed for 'listener' parameter");if(ListenerID!==null)throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_STATE_ERR,"InvalidStateError","Listener is already set");ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"setListener"});if(message.code===0){console.log("[displayrotator.js] setListener success ");ListenerID=ppDisplayRotator.addListener(DISPLAY_ROTATOR_CHANGED,function(msg){var event=msg.data.data;event.status=ValueToStatus(event.status);event.orientation=ValueToOrientation(event.orientation);onevent(event);});}else{console.log("[displayrotator.js] setListener error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},unsetListener:function(){ppDisplayRotator=ppDisplayRotator||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppDisplayRotator.postMessageAndAwaitResponse({command:"unsetListener"});if(message.code===0){console.log("[ppPrdInfo.js] removeSystemConfigChangeListener success");ppDisplayRotator.removeListenerById(DISPLAY_ROTATOR_CHANGED,ListenerID);ListenerID=null;}else throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};})(this);(function(window){var MOD_NAME="oobepromotion";var INSTANTIATED_NAMESPACE="oobepromotion";var PEPPER_PLUGIN_NAME="oobepromotion";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppOOBEPROMOTION=null;window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){console.log("[OOBEPROMOTION_PP] getVersion");ppOOBEPROMOTION=ppOOBEPROMOTION||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppOOBEPROMOTION.postMessageAndAwaitResponse({command:'oobepromotion_plugin_getVersion'});if(result.code==0){console.log("[oobepromotion.js] getVersion : message data "+result.data);return result.data;}else{console.log("[oobepromotion.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},getSecureBlob:function(){console.log("[OOBEPROMOTION_PP] getSecureBlob");ppOOBEPROMOTION=ppOOBEPROMOTION||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppOOBEPROMOTION.postMessageAndAwaitResponse({command:'oobepromotion_plugin_getBlob'});if(result.code==0){console.log("[oobepromotion.js] getBlob : message data: "+result.data);return result.data;}else{console.log("[oobepromotion.js] getBlob :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},delSecureBlob:function(){console.log("[OOBEPROMOTION_PP] delSecureBlob");ppOOBEPROMOTION=ppOOBEPROMOTION||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppOOBEPROMOTION.postMessageAndAwaitResponse({command:'oobepromotion_plugin_delBlob'});if(result.code==0)console.log("[oobepromotion.js] delBlob success: "+result.data);else{console.log("[oobepromotion.js] delBlob failed: "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}}};})(this);(function(window){var MOD_NAME="samsunghealth";var INSTANTIATED_NAMESPACE="samsunghealth";var PEPPER_PLUGIN_NAME="samsunghealth";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppSamsungHealth=null;window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){console.log("[SAMSUNGHEALTH_PP] getVersion");ppSamsungHealth=ppSamsungHealth||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppSamsungHealth.postMessageAndAwaitResponse({command:"samsunghealth_plugin_getVersion"});if(result.code==0){console.log("[ppSamsungHealth.js] getVersion : message data "+result.data);return result.data;}else{console.log("[ppSamsungHealth.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},sendActivityTime:function(data,callback){console.log("[SAMSUNGHEALTH_PP] sendActivityTime");if(!window.webapis._checkTypeValid("DOMString",data))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'data' parameter");if(!window.webapis._checkTypeValid("function",callback))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid response callback type passed for 'callback' parameter");ppSamsungHealth=ppSamsungHealth||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSamsungHealth.postMessage({command:"samsunghealth_plugin_sendActivityTime",data:data},function(message){var msgData=message.data;if(msgData.code==0){console.log("[SAMSUNGHEALTH_PP] succeeded sendActivityTime");var response={result:true,msg:msgData.errorMessage};}else{console.log("[SAMSUNGHEALTH_PP] failed sendActivityTime");var response={result:false,code:msgData.code,name:msgData.errorName,msg:msgData.errorMessage};}callback.call(null,response);});},sendEntitlementData:function(data,callback){console.log("[SAMSUNGHEALTH_PP] sendEntitlementData");if(!window.webapis._checkTypeValid("DOMString",data))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid DOMString type passed for 'data' parameter");if(!window.webapis._checkTypeValid("function",callback))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid response callback type passed for 'callback' parameter");ppSamsungHealth=ppSamsungHealth||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);ppSamsungHealth.postMessage({command:"samsunghealth_plugin_sendEntitlementData",data:data},function(message){var msgData=message.data;if(msgData.code==0){console.log("[SAMSUNGHEALTH_PP] succeeded sendEntitlementData");var response={result:true,msg:msgData.errorMessage};}else{console.log("[SAMSUNGHEALTH_PP] failed sendEntitlementData");var response={result:false,code:msgData.code,name:msgData.errorName,msg:msgData.errorMessage};}callback.call(null,response);});}};})(this);(function(window){var MOD_NAME="AdfwExtensionInitializer";var PEPPER_PLUGIN_NAME="adfwextensioninitializer";var INSTANTIATED_NAMESPACE="adfwextension";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppAdFramework=null;window.webapis[INSTANTIATED_NAMESPACE]={initialize:function(){console.log('[AdfwExtensionInitializer], Call initialize');ppAdFramework=ppAdFramework||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAdFramework.postMessageAndAwaitResponse({command:"initialize"});if(message.code==0){console.log("[AdfwExtensionInitializer] initialize success");return;}else{console.log("[AdfwExtensionInitializer] initialize ERROR");throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="Happycast";var INSTANTIATED_NAMESPACE="happycast";var PEPPER_PLUGIN_NAME="happycast";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var POST_MSG_TO_WEBAPP="HAPPYCAST_NOTIFICATION_TO_WEBAPP";var HCNotifyTypeID={LB_NOTIFY_TYPE_EM_NONE:-1,LB_NOTIFY_TYPE_EM_SYSTEM:0,LB_NOTIFY_TYPE_EM_PLAYER:1,LB_NOTIFY_TYPE_EM_WND:2};var HCNotifySystemMsgID={LB_RCAST_STATUS_EM_NONE:-1,LB_RCAST_STATUS_EM_AUTH_FAIL:0,LB_RCAST_STATUS_EM_LISTEN_SERVIC_FAIL:1,LB_RCAST_STATUS_EM_PUBLISH_SERVIC_FAIL:2,LB_RCAST_STATUS_EM_NET_ERROR:3,LB_RCAST_STATUS_EM_IP_CHANGE:4,LB_RCAST_STATUS_EM_DBG_DATA:5,LB_RCAST_STATUS_EM_PIC_TOO_BIG:6,LB_RCAST_STATUS_EM_DEVICE_NAME_CHANGE:7,LB_RCAST_STATUS_EM_WIFI_INFO_CHANGE:8,LB_RCAST_STATUS_EM_SET_LAN:9,LB_RCAST_STATUS_EM_SET_SCREEN_FORMAT:10,LB_RCAST_STATUS_EM_SET_SCREEN_TUNING:11,LB_RCAST_STATUS_EM_REBOOT:12,LB_RCAST_STATUS_EM_RESET_FACTORY:13,LB_RCAST_STATUS_EM_APP_UPGRADE:14,LB_RCAST_STATUS_EM_SET_WIRELESS_SHOW:15,LB_RCAST_STATUS_EM_SERVICE_START:16,LB_RCAST_STATUS_EM_SERVICE_QUIT:17};var HCNotifyPlayerMsgID={LB_RCAST_PLAYER_EVENT_EM_NONE:-1,LB_RCAST_PLAYER_EVENT_EM_PREPARED:0,LB_RCAST_PLAYER_EVENT_EM_START:1,LB_RCAST_PLAYER_EVENT_EM_PAUSE:2,LB_RCAST_PLAYER_EVENT_EM_RESUME:3,LB_RCAST_PLAYER_EVENT_EM_STOP:4,LB_RCAST_PLAYER_EVENT_EM_SEEK:5,LB_RCAST_PLAYER_EVENT_EM_PROGRESS:6,LB_RCAST_PLAYER_EVENT_EM_VOLUME:7,LB_RCAST_PLAYER_EVENT_EM_MUTE:8,LB_RCAST_PLAYER_EVENT_EM_ERROR:9,LB_RCAST_PLAYER_EVENT_EM_LOADING:10,LB_RCAST_PLAYER_EVENT_EM_LOADED:11,LB_RCAST_PLAYER_EVENT_EM_COMPLETE:12,LB_RCAST_PLAYER_EVENT_EM_SHOT_SCREEN:13,LB_RCAST_PLAYER_EVENT_EM_MUSIC_INFO:14,LB_RCAST_PLAYER_EVENT_EM_SCENE:15,LB_RCAST_PLAYER_EVENT_EM_PLAY_RATE:16,LB_RCAST_PLAYER_EVENT_EM_FIRST_VIDEO_FRAME:17,LB_RCAST_PLAYER_EVENT_EM_FIRST_AUDIO_FRAME:18,LB_RCAST_PLAYER_EVENT_EM_CONNECTING:19,LB_RCAST_PLAYER_EVENT_EM_CONNECTED:20,LB_RCAST_PLAYER_EVENT_EM_CONNECT_FAIL:21,LB_RCAST_PLAYER_EVENT_EM_CONNECT_QUIT:22,LB_RCAST_PLAYER_EVENT_EM_P2P_NEGOTIATION_ERROR:23,LB_RCAST_PLAYER_EVENT_EM_P2P_FORMATION_ERROR:24,LB_RCAST_PLAYER_EVENT_EM_P2P_TIMEOUT_ERROR:25,LB_RCAST_PLAYER_EVENT_EM_P2P_OVERLAP_ERROR:26,LB_RCAST_PLAYER_EVENT_EM_VID_PLAY_FAIL:27,LB_RCAST_PLAYER_EVENT_EM_AUD_PLAY_FAIL:28,LB_RCAST_PLAYER_EVENT_EM_PLAY_FAIL:29,LB_RCAST_PLAYER_EVENT_EM_NOT_SUPPORT:30,LB_RCAST_PLAYER_EVENT_EM_TIMEOUT:31,LB_RCAST_PLAYER_EVENT_EM_UNKNOW_ERROR:32,LB_RCAST_PLAYER_EVENT_EM_NET_NORMAL:33,LB_RCAST_PLAYER_EVENT_EM_P2P_LOST_PACKET:34,LB_RCAST_PLAYER_EVENT_EM_P2P_FIRST_SHOW:35,LB_RCAST_PLAYER_EVENT_EM_MEDIA_META:36,LB_RCAST_PLAYER_EVENT_EM_NET_CHANGE:37,LB_RCAST_PLAYER_EVENT_EM_P2P_FOUND:38,LB_RCAST_PLAYER_EVENT_EM_CONNECT_FAILED:39,LB_RCAST_PLAYER_EVENT_EM_NET_DISCONNECT:40,LB_RCAST_PLAYER_EVENT_EM_RES_NOT_FOUND:41,LB_RCAST_PLAYER_EVENT_EM_SUB_PLAY_FAIL:42,LB_RCAST_PLAYER_EVENT_EM_IFRAME_ERR:43,LB_RCAST_PLAYER_EVENT_EM_PIC_URL:44,LB_RCAST_PLAYER_EVENT_EM_MEDIA_URL:45};var HCNotifyWindowMsgID={LB_RCAST_WND_EVENT_EM_NONE:-1,LB_RCAST_WND_EVENT_EM_POS:0};var HCControlTypeID={LB_RCAST_CTL_TYPE_NONE:-1,LB_RCAST_CTL_TYPE_GET_VERSION:0,LB_RCAST_CTL_TYPE_GET_DEVICE_NAME:1,LB_RCAST_CTL_TYPE_SET_DEVICE_NAME:2,LB_RCAST_CTL_TYPE_GET_VIDEO_INFO:3,LB_RCAST_CTL_TYPE_SET_VIDEO_INFO:4,LB_RCAST_CTL_TYPE_GET_ENABLE_PUBLISH:5,LB_RCAST_CTL_TYPE_ENABLE_PUBLISH:6,LB_RCAST_CTL_TYPE_GET_MIRROR_MODE:7,LB_RCAST_CTL_TYPE_SET_MIRROR_MODE:8,LB_RCAST_CTL_TYPE_SET_VIDEO_URL:9,LB_RCAST_CTL_TYPE_GET_LOG_LEVEL:10,LB_RCAST_CTL_TYPE_SET_LOG_LEVEL:11,LB_RCAST_CTL_TYPE_RELEASE_RESOURCE:12,LB_RCAST_CTL_TYPE_GET_PIN_CODE:13,LB_RCAST_CTL_TYPE_START:14,LB_RCAST_CTL_TYPE_STOP:15,LB_RCAST_CTL_TYPE_PAUSE:16,LB_RCAST_CTL_TYPE_RESUME:17,LB_RCAST_CTL_TYPE_FAST_FORWARD:18,LB_RCAST_CTL_TYPE_FAST_BACKWORD:19,LB_RCAST_CTL_TYPE_SEEK:20,LB_RCAST_CTL_TYPE_GET_DISPLAY_MODE:21,LB_RCAST_CTL_TYPE_SET_DISPLAY_MODE:22,LB_RCAST_CTL_TYPE_GET_VOLUME:23,LB_RCAST_CTL_TYPE_SET_VOLUME:24,LB_RCAST_CTL_TYPE_GET_MUTE:25,LB_RCAST_CTL_TYPE_SET_MUTE:26,LB_RCAST_CTL_TYPE_GET_DURATION:27,LB_RCAST_CTL_TYPE_GET_CUR_POSITION:28,LB_RCAST_CTL_TYPE_GET_CONTENT_NAME:29,LB_RCAST_CTL_TYPE_GET_WIN_POSITION:30,LB_RCAST_CTL_TYPE_SET_WIN_POSITION:31,LB_RCAST_CTL_TYPE_GET_PLAYRATE:32,LB_RCAST_CTL_TYPE_SET_PLAYRATE:33,LB_RCAST_CTL_TYPE_GET_PIC_POSITION:34,LB_RCAST_CTL_TYPE_SET_PIC_POSITION:35,LB_RCAST_CTL_TYPE_GET_PIC_ANGLE:36,LB_RCAST_CTL_TYPE_SET_PIC_ANGLE:37,LB_RCAST_CTL_TYPE_GET_PLAY_SCENE:38,LB_RCAST_CTL_TYPE_GET_MIR_MODE:39,LB_RCAST_CTL_TYPE_SET_MIR_MODE:40,LB_RCAST_CTL_TYPE_GET_DOWNLOAD_RATE:41,LB_RCAST_CTL_TYPE_GET_SEEKABLE:42,LB_RCAST_CTL_TYPE_GET_WIFI_INFO:43,LB_RCAST_CTL_TYPE_RESTART_CAST_SERVICE:44,LB_RCAST_CTL_TYPE_NOTIFY_LANGUAGE:45,LB_RCAST_CTL_TYPE_GET_LANGUAGE:46,LB_RCAST_CTL_TYPE_RESTORE_DEFAULT:47,LB_RCAST_CTL_TYPE_SET_WIN_INFO:100,LB_RCAST_CTL_TYPE_API_FOR_EXTEND:666};var notifycbArr=[];var notifycb=function(wndid,listenerId){this.wndid=wndid;this.listenerId=listenerId;};var _hasNotifyCB=function(wndid){for(i=0;i<notifycbArr.length;i++)if(notifycbArr[i].wndid==wndid)return true;return false;};var _removeKeyListenerById=function(id){for(i=0;i<notifycbArr.length;i++)if(notifycbArr[i].listenerId==id){var obj=notifycbArr[i];notifycbArr.splice(i,1);return obj;}return null;};var ppHappycast=null;window.webapis[INSTANTIATED_NAMESPACE]={HCControlTypeID:HCControlTypeID,HCNotifyWindowMsgID:HCNotifyWindowMsgID,HCNotifyPlayerMsgID:HCNotifyPlayerMsgID,HCNotifySystemMsgID:HCNotifySystemMsgID,HCNotifyTypeID:HCNotifyTypeID,connect:function(wndid,notifycbfun){if(!window.webapis._checkTypeValid("long",wndid))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid passed for 'wndid' parameter");if(!window.webapis._checkTypeValid("function",notifycbfun))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid type passed for 'notifycbfun' parameter");if(_hasNotifyCB(wndid)==false){ppHappycast=ppHappycast||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppHappycast.postMessageAndAwaitResponse({command:"registerNotifyCBForHappycast",WindID:wndid});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}else console.log("[Happycast.js] need not registerNotifyCBForHappycast again, wndid : "+wndid);var listenerId=ppHappycast.addListener(POST_MSG_TO_WEBAPP,function(msg){var eventMsg=msg.data;if(eventMsg.data===null||typeof eventMsg.data==='undefined')throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"INVALID_VALUES_ERR","Invalid Value Error");var msg=JSON.parse(eventMsg.data);notifycbfun(msg);});var obj=new notifycb(wndid,listenerId);notifycbArr.push(obj);return listenerId;},disconnect:function(listenerId){if(!window.webapis._checkTypeValid("long",listenerId))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid listenerId type passed for 'listenerId' parameter");var keyListener=_removeKeyListenerById(listenerId);if(null==keyListener){throw window.webapis._createWebAPIException(window.webapis.WebAPIException.INVALID_VALUES_ERR,"InvalidValuesError","The listener can not be found using listenerId["+listenerId+"]");return;}if(_hasNotifyCB(keyListener.wndid)==false){ppHappycast=ppHappycast||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppHappycast.postMessageAndAwaitResponse({command:"unregisterNotifyCBForHappycast",WindID:keyListener.wndid});if(message.code!=0)throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);else ppHappycast.removeListenerById(POST_MSG_TO_WEBAPP,listenerId);}else ppHappycast.removeListenerById(POST_MSG_TO_WEBAPP,listenerId);console.log("[Happycast.js] unregister notify cb success");},ctrl:function(typeid,jsonCtrlParams){if(!window.webapis._checkTypeValid("DOMString",jsonCtrlParams))throw window.webapis._createWebAPIException(window.webapis.WebAPIException.TYPE_MISMATCH_ERR,"TypeMismatchError","Invalid type passed for 'jsonCtrlParams' parameter");ppHappycast=ppHappycast||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppHappycast.postMessageAndAwaitResponse({command:"GetAndSetAttributes",attrID:typeid,jsonstr:jsonCtrlParams});if(message.code==0){console.log("[Happycast.js] ctrl success");return message.data;}else{console.log("[Happycast.js] ctrl error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},getVersion:function(){ppHappycast=ppHappycast||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppHappycast.postMessageAndAwaitResponse({command:"getVersion"});if(message.code==0){console.log("[Happycast.js] getVersion message data "+message.data);return message.data;}else{console.log("[Happycast.js] getVersion error "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="securityapp API";var INSTANTIATED_NAMESPACE="securityapp";var PEPPER_PLUGIN_NAME="securityapp";if(!window.webapis)throw "Module"+MOD_NAME+": window.webapis is not defined";var APPLIST_CHANGED="APPLIST_CHANGED";var securityapp_PP=null;function doCall(calleeObject){console.log("[securityapp] doCall() cmd : "+calleeObject.command);securityapp_PP=securityapp_PP||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var reply=securityapp_PP.postMessageAndAwaitResponse(calleeObject);if(reply.code!==undefined){console.log("[securityapp] throwing code         : "+reply.code);console.log("[securityapp] throwing errorName    : "+reply.errorName);console.log("[securityapp] throwing errorMessage : "+reply.errorMessage);throw window.webapis._createWebAPIError(reply.code,reply.errorName,reply.errorMessage);}return reply;};function doAsyncCall(calleeObject,cbFunction){console.log("[securityapp] doAsyncCall() cmd : "+calleeObject.command);securityapp_PP=securityapp_PP||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);securityapp_PP.postMessage(calleeObject,cbFunction);};window.webapis[INSTANTIATED_NAMESPACE]={getAppListByPrivilege:function(privilege,onsuccess,onerror){webapis._validator.validateArgs(arguments,[{name:'privilege',type:webapis._validator.Types.STRING},{name:'onsuccess',type:webapis._validator.Types.FUNCTION,optional:false,nullable:false},{name:'onerror',type:webapis._validator.Types.FUNCTION,optional:true,nullable:true}]);var reply=doAsyncCall({command:"getAppListByPrivilege",cmdvalue:privilege},function(message){var msgData=message.data;if(msgData.code==0)onsuccess.call(null,msgData.data);else onerror&&onerror.call(null,webapis._createWebAPIError(msgData.code,msgData.errorName,msgData.errorMessage));});},getVersion:function(){var reply=doCall({command:"getVersion"});return reply.context;}};})(this);(function(window){var MOD_NAME="SystemInfo";var INSTANTIATED_NAMESPACE="systeminfo";var PEPPER_PLUGIN_NAME="systeminfo";var MAX_RESOLUTION_INFO_CHANGED="MAX_RESOLUTION_INFO_CHANGED";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppSystemInfo=null;var exec=function(api){console.log("Module "+MOD_NAME+":"+api+" begin");ppSystemInfo=ppSystemInfo||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSystemInfo.postMessageAndAwaitResponse({command:api});if(message.code==0){console.log("Module "+MOD_NAME+":"+api+" message data ["+message.data+"]");return message.data;}else{console.log("Module "+MOD_NAME+":"+api+" error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){return exec("getVersion");},getMaxVideoResolution:function(){return exec("getMaxVideoResolution");},setMaxVideoResolutionListener:function(listener){ppSystemInfo=ppSystemInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);webapis._validator.validateArgs(arguments,[{name:'listener',type:webapis._validator.Types.FUNCTION,optional:false,nullable:false}]);var message=ppSystemInfo.postMessageAndAwaitResponse({command:"setMaxVideoResolutionListener"});if(message.code==0){console.log("Module "+MOD_NAME+": "+"success register resolution listener");ppSystemInfo.addListener(MAX_RESOLUTION_INFO_CHANGED,function(msg){console.log("Module "+MOD_NAME+": Changed max resolution frameRate: "+msg.data.data.frameRate+" width: "+msg.data.data.width+" height: "+msg.data.data.height);listener(msg.data.data);});}else{console.log("Module "+MOD_NAME+": setMaxVideoResolutionListener "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},unsetMaxVideoResolutionListener:function(){ppSystemInfo=ppSystemInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppSystemInfo.postMessageAndAwaitResponse({command:"unsetMaxVideoResolutionListener"});if(message.code==0)console.log("Module "+MOD_NAME+": success unregister resolution listener ");else{console.log("Module "+MOD_NAME+": unsetMaxVideoResolutionListener "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isSupportedAudioCodec:function(audiocodec){ppSystemInfo=ppSystemInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);webapis._validator.validateArgs(arguments,[{name:"audiocodec",type:webapis._validator.Types.STRING}]);var message=ppSystemInfo.postMessageAndAwaitResponse({command:"isSupportedAudioCodec",acodec:audiocodec});if(message.code==0){console.log("Module "+MOD_NAME+": isSupportedAudioCodec"+" message data ["+message.data+"]");return message.data;}else{console.log("Module "+MOD_NAME+": isSupportedAudioCodec "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},isSupportedVideoCodec:function(videocodec){ppSystemInfo=ppSystemInfo||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);webapis._validator.validateArgs(arguments,[{name:"videocodec",type:webapis._validator.Types.STRING}]);var message=ppSystemInfo.postMessageAndAwaitResponse({command:"isSupportedVideoCodec",vcodec:videocodec});if(message.code==0){console.log("Module "+MOD_NAME+": isSupportedVideoCodec"+" message data ["+message.data+"]");return message.data;}else{console.log("Module "+MOD_NAME+": isSupportedVideoCodec "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="AISound";var INSTANTIATED_NAMESPACE="aisound";var PEPPER_PLUGIN_NAME="aisound";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppAISound=null;var exec=function(api){console.log("Module "+MOD_NAME+":"+api+" begin");ppAISound=ppAISound||window.webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAISound.postMessageAndAwaitResponse({command:api});if(message.code==0){console.log("Module "+MOD_NAME+":"+api+" message data ["+message.data+"]");return message.data;}else{console.log("Module "+MOD_NAME+":"+api+" error code "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}};window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){return exec("getVersion");},setPosition:function(x,y){ppAISound=ppAISound||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);webapis._validator.validateArgs(arguments,[{name:'x',type:webapis._validator.Types.LONG,optional:false,nullable:false},{name:'y',type:webapis._validator.Types.LONG,optional:false,nullable:false}]);var message=ppAISound.postMessageAndAwaitResponse({command:"setPosition",x:x,y:y});if(message.code==0)console.log("Module "+MOD_NAME+": "+"Success to call setPosition");else{console.log("Module "+MOD_NAME+": setPosition "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}},unsetPosition:function(){ppAISound=ppAISound||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var message=ppAISound.postMessageAndAwaitResponse({command:"unsetPosition"});if(message.code==0)console.log("Module "+MOD_NAME+": "+"Success to call unsetPosition");else{console.log("Module "+MOD_NAME+": unsetPosition "+message.code);throw window.webapis._createWebAPIError(message.code,message.errorName,message.errorMessage);}}};})(this);(function(window){var MOD_NAME="terms";var INSTANTIATED_NAMESPACE="terms";var PEPPER_PLUGIN_NAME="terms";if(!window.webapis)throw "Module "+MOD_NAME+": window.webapis is not defined";var ppTerms=null;window.webapis[INSTANTIATED_NAMESPACE]={getVersion:function(){console.log("[Terms_PP] getVersion");ppTerms=ppTerms||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppTerms.postMessageAndAwaitResponse({command:'terms_plugin_getVersion'});if(result.code==0){console.log("[terms.js] getVersion : message data "+result.data);return result.data;}else{console.log("[terms.js] getVersion :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},getTCString:function(){console.log("[Terms_PP] getTCString");ppTerms=ppTerms||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppTerms.postMessageAndAwaitResponse({command:'terms_plugin_getTCString'});console.log("[Terms_PP] [INFO] terms_plugin_getTCString Result is ",result);if(result.code==0){var tcString=result.data;console.log("[Terms_PP] [INFO] TCString is "+tcString);return tcString;}else{console.log("[terms.js] getTCString :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);}},setTCString:function(seckey,tcString){console.log("[Terms_PP] setTCString");webapis._validator.validateArgs(arguments,[{name:'seckey',type:webapis._validator.Types.STRING},{name:'tcString',type:webapis._validator.Types.STRING}]);ppTerms=ppTerms||webapis._getPepperPlugin(PEPPER_PLUGIN_NAME);var result=ppTerms.postMessageAndAwaitResponse({command:'terms_plugin_setTCString',seckey:seckey,TCString:tcString});console.log("[Terms_PP] [INFO] terms_plugin_setTCString Result is ",result.code);if(result.code==0)return result.data;else{console.log("[terms.js] getTCString :  error code "+result.code);throw window.webapis._createWebAPIError(result.code,result.errorName,result.errorMessage);};}};})(this);/*!
samsung-js-ad-framework
Version: 2.2.6  (2019-12-20)
Author: 
Company: Samsung Research America, Digital Media Solutions Lab

License:
This software may be used only on Samsung Smart-TVs. It may not be reverse-engineered, unminified, forked, modified, sold or used in any platform other than Samsung Smart-TVs.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
(function (definition) {
    "use strict";

    // Borrowed this definition loader from Q.js - it's pretty cool
    // CommonJS
    if (typeof exports === "object") {
        exports.adframework = definition();
    } else if (typeof self !== "undefined") {
        if (typeof self.webapis === "undefined") {
            self.webapis = {};
        }
        self.webapis.adframeworkLazyLoadedDefinition = null;
        Object.defineProperty(self.webapis, 'adframework', {
            get: function () {
                if (!self.webapis.adframeworkLazyLoadedDefinition) {
                    try {
                        console.log('[ADFW ADFRAMEWORKPRELOAD] lazily executing ad framework definition');
                        var startTime = new Date();
                        self.webapis.adframeworkLazyLoadedDefinition = definition();
                        var duration = new Date() - startTime;
                        console.log('[ADFW ADFRAMEWORKPRELOAD] successfully lazy-instantiated ad framework: ' + duration + 'ms');
                    }
                    catch (e) {

                    }

                }
                return self.webapis.adframeworkLazyLoadedDefinition;
            },
            configurable: true
        });
    } else {
        throw new Error("This running environment is not supported.");
    }
})(function () {

    var adfw = {};

    //If we're on VOLT, we want to require in some modules and prepare some stuff
    if (typeof require === "function" && typeof Volt !== "undefined" && typeof setTimeout === "undefined") {
        if (typeof setTimeout === "undefined" && typeof Volt !== "undefined" && typeof Volt.setTimeout === "function" && Function.prototype.bind) {
            setTimeout = Volt.setTimeout.bind(Volt);
            print("setTimeout has been bound");
        }
        if (typeof setInterval === "undefined" && typeof Volt !== "undefined" && typeof Volt.setInterval === "function") {
            setInterval = Volt.setInterval.bind(Volt);
            print("setInterval has been bound");
        }
        if (typeof clearTimeout === "undefined" && typeof Volt !== "undefined" && typeof Volt.clearTimeout === "function") {
            clearTimeout = function (id) {
                if (typeof id === "number") {
                    Volt.clearTimeout(id);
                }
            };
            print("clearTimeout has been bound");
        }
        if (typeof clearInterval === "undefined" && typeof Volt !== "undefined" && typeof Volt.clearInterval === "function") {
            clearInterval = function (id) {
                if (typeof id === "number") {
                    Volt.clearInterval(id);
                }
            };
            print("clearInterval has been bound");
        }
    }

/*!
 * @preserve
 * Q Version 1.4.0 https://github.com/kriskowal/q
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    //We want Q to be dropped into the adfw namespace, so we have removed most of the loader code in favor of this one line here:
    adfw.Q = definition();

})(function () {
    "use strict";

    var hasStacks = false;
    try {
        throw new Error();
    } catch (e) {
        hasStacks = !!e.stack;
    }

// All code after this point will be filtered from stack traces reported
// by Q.
    var qStartingLine = captureLine();
    var qFileName;

// shims

// used for fallback in "allResolved"
    var noop = function () {
    };

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
    var nextTick = (function () {
        // linked list of tasks (single, with head node)
        var head = {task: void 0, next: null};
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        // queue for late tasks, used by unhandled rejection tracking
        var laterQueue = [];

        function flush() {
            /* jshint loopfunc: true */
            var task, domain;

            while (head.next) {
                head = head.next;
                task = head.task;
                head.task = void 0;
                domain = head.domain;

                if (domain) {
                    head.domain = void 0;
                    domain.enter();
                }
                runSingle(task, domain);

            }
            while (laterQueue.length) {
                task = laterQueue.pop();
                runSingle(task);
            }
            flushing = false;
        }

        // runs a single function in the async queue
        function runSingle(task, domain) {
            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        nextTick = function (task) {
            tail = tail.next = {
                task: task,
                domain: isNodeJS && process.domain,
                next: null
            };

            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };

        if (typeof process === "object" &&
            process.toString() === "[object process]" && process.nextTick) {
            // Ensure Q is in a real Node environment, with a `process.nextTick`.
            // To see through fake Node environments:
            // * Mocha test runner - exposes a `process` global without a `nextTick`
            // * Browserify - exposes a `process.nexTick` function that uses
            //   `setTimeout`. In this case `setImmediate` is preferred because
            //    it is faster. Browserify's `process.toString()` yields
            //   "[object Object]", while in a real Node environment
            //   `process.nextTick()` yields "[object process]".
            isNodeJS = true;

            requestTick = function () {
                process.nextTick(flush);
            };

        } else if (typeof setImmediate === "function") {
            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
            if (typeof window !== "undefined") {
                requestTick = setImmediate.bind(window, flush);
            } else {
                requestTick = function () {
                    setImmediate(flush);
                };
            }

        } else if (typeof MessageChannel !== "undefined") {
            // modern browsers
            // http://www.nonblocking.io/2011/06/windownexttick.html
            var channel = new MessageChannel();
            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
            // working message ports the first time a page loads.
            channel.port1.onmessage = function () {
                requestTick = requestPortTick;
                channel.port1.onmessage = flush;
                flush();
            };
            var requestPortTick = function () {
                // Opera requires us to provide a message payload, regardless of
                // whether we use it.
                channel.port2.postMessage(0);
            };
            requestTick = function () {
                setTimeout(flush, 0);
                requestPortTick();
            };

        } else {
            // old browsers
            requestTick = function () {
                setTimeout(flush, 0);
            };
        }
        // runs a task after all other tasks have been run
        // this is useful for unhandled rejection tracking that needs to happen
        // after all `then`d tasks have been run.
        nextTick.runAfter = function (task) {
            laterQueue.push(task);
            if (!flushing) {
                flushing = true;
                requestTick();
            }
        };
        return nextTick;
    })();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don't need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller's explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
    var call = Function.call;

    function uncurryThis(f) {
        return function () {
            return call.apply(f, arguments);
        };
    }

// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

    var array_slice = uncurryThis(Array.prototype.slice);

    var array_reduce = uncurryThis(
        Array.prototype.reduce || function (callback, basis) {
            var index = 0,
                length = this.length;
            // concerning the initial value, if one is not provided
            if (arguments.length === 1) {
                // seek to the first value in the array, accounting
                // for the possibility that is is a sparse array
                do {
                    if (index in this) {
                        basis = this[index++];
                        break;
                    }
                    if (++index >= length) {
                        throw new TypeError();
                    }
                } while (1);
            }
            // reduce
            for (; index < length; index++) {
                // account for the possibility that the array is sparse
                if (index in this) {
                    basis = callback(basis, this[index], index);
                }
            }
            return basis;
        }
    );

    var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function (value) {
            // not a very good shim, but good enough for our one use of it
            for (var i = 0; i < this.length; i++) {
                if (this[i] === value) {
                    return i;
                }
            }
            return -1;
        }
    );

    var array_map = uncurryThis(
        Array.prototype.map || function (callback, thisp) {
            var self = this;
            var collect = [];
            array_reduce(self, function (undefined, value, index) {
                collect.push(callback.call(thisp, value, index, self));
            }, void 0);
            return collect;
        }
    );

    var object_create = Object.create || function (prototype) {
            function Type() {
            }

            Type.prototype = prototype;
            return new Type();
        };

    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

    var object_keys = Object.keys || function (object) {
            var keys = [];
            for (var key in object) {
                if (object_hasOwnProperty(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };

    var object_toString = uncurryThis(Object.prototype.toString);

    function isObject(value) {
        return value === Object(value);
    }

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
    function isStopIteration(exception) {
        return (
            object_toString(exception) === "[object StopIteration]" ||
            exception instanceof QReturnValue
        );
    }

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
    var QReturnValue;
    if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
    } else {
        QReturnValue = function (value) {
            this.value = value;
        };
    }

// long stack traces

    var STACK_JUMP_SEPARATOR = "From previous event:";

    function makeStackTraceLong(error, promise) {
        // If possible, transform the error stack trace by removing Node and Q
        // cruft, then concatenating with the stack trace of `promise`. See #57.
        if (hasStacks &&
            promise.stack &&
            typeof error === "object" &&
            error !== null &&
            error.stack &&
            error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
        ) {
            var stacks = [];
            for (var p = promise; !!p; p = p.source) {
                if (p.stack) {
                    stacks.unshift(p.stack);
                }
            }
            stacks.unshift(error.stack);

            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
            error.stack = filterStackString(concatedStacks);
        }
    }

    function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
            var line = lines[i];

            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join("\n");
    }

    function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 ||
            stackLine.indexOf("(node.js:") !== -1;
    }

    function getFileNameAndLineNumber(stackLine) {
        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
        // In IE10 function name can have spaces ("Anonymous function") O_o
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [attempt1[1], Number(attempt1[2])];
        }

        // Anonymous functions: "at filename:lineNumber:columnNumber"
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [attempt2[1], Number(attempt2[2])];
        }

        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [attempt3[1], Number(attempt3[2])];
        }
    }

    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

        if (!fileNameAndLineNumber) {
            return false;
        }

        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];

        return fileName === qFileName &&
            lineNumber >= qStartingLine &&
            lineNumber <= qEndingLine;
    }

// discover own file name and line number range for filtering stack
// traces
    function captureLine() {
        if (!hasStacks) {
            return;
        }

        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split("\n");
            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }

            qFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }

    function deprecate(callback, name, alternative) {
        return function () {
            if (typeof console !== "undefined" &&
                typeof console.warn === "function") {
                console.warn(name + " is deprecated, use " + alternative +
                    " instead.", new Error("").stack);
            }
            return callback.apply(callback, arguments);
        };
    }

// end of shims
// beginning of real work

    /**
     * Constructs a promise for an immediate reference, passes promises through, or
     * coerces promises from different systems.
     * @param value immediate reference or promise
     */
    function Q(value) {
        // If the object is already a Promiz, return it directly.  This enables
        // the resolve function to both be used to created references from objects,
        // but to tolerably coerce non-promises to promises.
        if (value instanceof Promise) {
            return value;
        }

        // assimilate thenables
        if (isPromiseAlike(value)) {
            return coerce(value);
        } else {
            return fulfill(value);
        }
    }

    Q.resolve = Q;

    /**
     * Performs a task in a future turn of the event loop.
     * @param {Function} task
     */
    Q.nextTick = nextTick;

    /**
     * Controls whether or not long stack traces will be on
     */
    Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
    if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
    }

    /**
     * Constructs a {promise, resolve, reject} object.
     *
     * `resolve` is a callback to invoke with a more resolved value for the
     * promise. To fulfill the promise, invoke `resolve` with any value that is
     * not a thenable. To reject the promise, invoke `resolve` with a rejected
     * thenable, or invoke `reject` with the reason directly. To resolve the
     * promise to another thenable, thus putting it in the same state, invoke
     * `resolve` with that other thenable.
     */
    Q.defer = defer;
    function defer() {
        // if "messages" is an "Array", that indicates that the promise has not yet
        // been resolved.  If it is "undefined", it has been resolved.  Each
        // element of the messages array is itself an array of complete arguments to
        // forward to the resolved promise.  We coerce the resolution value to a
        // promise using the `resolve` function because it handles both fully
        // non-thenable values and other thenables gracefully.
        var messages = [], progressListeners = [], resolvedPromise;

        var deferred = object_create(defer.prototype);
        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, operands) {
            var args = array_slice(arguments);
            if (messages) {
                messages.push(args);
                if (op === "when" && operands[1]) { // progress operand
                    progressListeners.push(operands[1]);
                }
            } else {
                Q.nextTick(function () {
                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
                });
            }
        };

        // XXX deprecated
        promise.valueOf = function () {
            if (messages) {
                return promise;
            }
            var nearerValue = nearer(resolvedPromise);
            if (isPromise(nearerValue)) {
                resolvedPromise = nearerValue; // shorten chain
            }
            return nearerValue;
        };

        promise.inspect = function () {
            if (!resolvedPromise) {
                return {state: "pending"};
            }
            return resolvedPromise.inspect();
        };

        if (Q.longStackSupport && hasStacks) {
            try {
                throw new Error();
            } catch (e) {
                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
                // accessor around; that causes memory leaks as per GH-111. Just
                // reify the stack trace as a string ASAP.
                //
                // At the same time, cut off the first line; it's always just
                // "[object Promiz]\n", as per the `toString`.
                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            }
        }

        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
        // consolidating them into `become`, since otherwise we'd create new
        // promises with the lines `become(whatever(value))`. See e.g. GH-252.

        function become(newPromise) {
            resolvedPromise = newPromise;
            promise.source = newPromise;

            array_reduce(messages, function (undefined, message) {
                Q.nextTick(function () {
                    newPromise.promiseDispatch.apply(newPromise, message);
                });
            }, void 0);

            messages = void 0;
            progressListeners = void 0;
        }

        deferred.promise = promise;
        deferred.resolve = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(Q(value));
        };

        deferred.fulfill = function (value) {
            if (resolvedPromise) {
                return;
            }

            become(fulfill(value));
        };
        deferred.reject = function (reason) {
            if (resolvedPromise) {
                return;
            }

            become(reject(reason));
        };
        deferred.notify = function (progress) {
            if (resolvedPromise) {
                return;
            }

            array_reduce(progressListeners, function (undefined, progressListener) {
                Q.nextTick(function () {
                    progressListener(progress);
                });
            }, void 0);
        };

        return deferred;
    }

    /**
     * Creates a Node-style callback that will resolve or reject the deferred
     * promise.
     * @returns a nodeback
     */
    defer.prototype.makeNodeResolver = function () {
        var self = this;
        return function (error, value) {
            if (error) {
                self.reject(error);
            } else if (arguments.length > 2) {
                self.resolve(array_slice(arguments, 1));
            } else {
                self.resolve(value);
            }
        };
    };

    /**
     * @param resolver {Function} a function that returns nothing and accepts
     * the resolve, reject, and notify functions for a deferred.
     * @returns a promise that may be resolved with the given resolve and reject
     * functions, or rejected by a thrown exception in resolver
     */
    Q.Promise = promise; // ES6
    Q.promise = promise;
    function promise(resolver) {
        if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
            resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
            deferred.reject(reason);
        }
        return deferred.promise;
    }

    promise.race = race; // ES6
    promise.all = all; // ES6
    promise.reject = reject; // ES6
    promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
    Q.passByCopy = function (object) {
        //freeze(object);
        //passByCopies.set(object, true);
        return object;
    };

    Promise.prototype.passByCopy = function () {
        //freeze(object);
        //passByCopies.set(object, true);
        return this;
    };

    /**
     * If two promises eventually fulfill to the same value, promises that value,
     * but otherwise rejects.
     * @param x {Any*}
     * @param y {Any*}
     * @returns {Any*} a promise for x and y if they are the same, but a rejection
     * otherwise.
     *
     */
    Q.join = function (x, y) {
        return Q(x).join(y);
    };

    Promise.prototype.join = function (that) {
        return Q([this, that]).spread(function (x, y) {
            if (x === y) {
                // TODO: "===" should be Object.is or equiv
                return x;
            } else {
                throw new Error("Can't join: not the same: " + x + " " + y);
            }
        });
    };

    /**
     * Returns a promise for the first of an array of promises to become settled.
     * @param answers {Array[Any*]} promises to race
     * @returns {Any*} the first promise to be settled
     */
    Q.race = race;
    function race(answerPs) {
        return promise(function (resolve, reject) {
            // Switch to this once we can assume at least ES5
            // answerPs.forEach(function (answerP) {
            //     Q(answerP).then(resolve, reject);
            // });
            // Use this in the meantime
            for (var i = 0, len = answerPs.length; i < len; i++) {
                Q(answerPs[i]).then(resolve, reject);
            }
        });
    }

    Promise.prototype.race = function () {
        return this.then(Q.race);
    };

    /**
     * Constructs a Promise with a promise descriptor object and optional fallback
     * function.  The descriptor contains methods like when(rejected), get(name),
     * set(name, value), post(name, args), and delete(name), which all
     * return either a value, a promise for a value, or a rejection.  The fallback
     * accepts the operation name, a resolver, and any further arguments that would
     * have been forwarded to the appropriate method above had a method been
     * provided with the proper name.  The API makes no guarantees about the nature
     * of the returned object, apart from that it is usable whereever promises are
     * bought and sold.
     */
    Q.makePromise = Promise;
    function Promise(descriptor, fallback, inspect) {
        if (fallback === void 0) {
            fallback = function (op) {
                return reject(new Error(
                    "Promiz does not support operation: " + op
                ));
            };
        }
        if (inspect === void 0) {
            inspect = function () {
                return {state: "unknown"};
            };
        }

        var promise = object_create(Promise.prototype);

        promise.promiseDispatch = function (resolve, op, args) {
            var result;
            try {
                if (descriptor[op]) {
                    result = descriptor[op].apply(promise, args);
                } else {
                    result = fallback.call(promise, op, args);
                }
            } catch (exception) {
                result = reject(exception);
            }
            if (resolve) {
                resolve(result);
            }
        };

        promise.inspect = inspect;

        // XXX deprecated `valueOf` and `exception` support
        if (inspect) {
            var inspected = inspect();
            if (inspected.state === "rejected") {
                promise.exception = inspected.reason;
            }

            promise.valueOf = function () {
                var inspected = inspect();
                if (inspected.state === "pending" ||
                    inspected.state === "rejected") {
                    return promise;
                }
                return inspected.value;
            };
        }

        return promise;
    }

    Promise.prototype.toString = function () {
        return "[object Promiz]";
    };

    Promise.prototype.then = function (fulfilled, rejected, progressed) {
        var self = this;
        var deferred = defer();
        var done = false;   // ensure the untrusted promise makes at most a
                            // single call to one of the callbacks

        function _fulfilled(value) {
            try {
                return typeof fulfilled === "function" ? fulfilled(value) : value;
            } catch (exception) {
                return reject(exception);
            }
        }

        function _rejected(exception) {
            if (typeof rejected === "function") {
                makeStackTraceLong(exception, self);
                try {
                    return rejected(exception);
                } catch (newException) {
                    return reject(newException);
                }
            }
            return reject(exception);
        }

        function _progressed(value) {
            return typeof progressed === "function" ? progressed(value) : value;
        }

        Q.nextTick(function () {
            self.promiseDispatch(function (value) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_fulfilled(value));
            }, "when", [function (exception) {
                if (done) {
                    return;
                }
                done = true;

                deferred.resolve(_rejected(exception));
            }]);
        });

        // Progress propagator need to be attached in the current tick.
        self.promiseDispatch(void 0, "when", [void 0, function (value) {
            var newValue;
            var threw = false;
            try {
                newValue = _progressed(value);
            } catch (e) {
                threw = true;
                if (Q.onerror) {
                    Q.onerror(e);
                } else {
                    throw e;
                }
            }

            if (!threw) {
                deferred.notify(newValue);
            }
        }]);

        return deferred.promise;
    };

    Q.tap = function (promise, callback) {
        return Q(promise).tap(callback);
    };

    /**
     * Works almost like "finally", but not called for rejections.
     * Original resolution value is passed through callback unaffected.
     * Callback may return a promise that will be awaited for.
     * @param {Function} callback
     * @returns {Q.Promise}
     * @example
     * doSomething()
     *   .then(...)
     *   .tap(console.log)
     *   .then(...);
     */
    Promise.prototype.tap = function (callback) {
        callback = Q(callback);

        return this.then(function (value) {
            return callback.fcall(value).thenResolve(value);
        });
    };

    /**
     * Registers an observer on a promise.
     *
     * Guarantees:
     *
     * 1. that fulfilled and rejected will be called only once.
     * 2. that either the fulfilled callback or the rejected callback will be
     *    called, but not both.
     * 3. that fulfilled and rejected will not be called in this turn.
     *
     * @param value      promise or immediate reference to observe
     * @param fulfilled  function to be called with the fulfilled value
     * @param rejected   function to be called with the rejection exception
     * @param progressed function to be called on any progress notifications
     * @return promise for the return value from the invoked callback
     */
    Q.when = when;
    function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
    }

    Promise.prototype.thenResolve = function (value) {
        return this.then(function () {
            return value;
        });
    };

    Q.thenResolve = function (promise, value) {
        return Q(promise).thenResolve(value);
    };

    Promise.prototype.thenReject = function (reason) {
        return this.then(function () {
            throw reason;
        });
    };

    Q.thenReject = function (promise, reason) {
        return Q(promise).thenReject(reason);
    };

    /**
     * If an object is not a promise, it is as "near" as possible.
     * If a promise is rejected, it is as "near" as possible too.
     * If it's a fulfilled promise, the fulfillment value is nearer.
     * If it's a deferred promise and the deferred has been resolved, the
     * resolution is "nearer".
     * @param object
     * @returns most resolved (nearest) form of the object
     */

// XXX should we re-do this?
    Q.nearer = nearer;
    function nearer(value) {
        if (isPromise(value)) {
            var inspected = value.inspect();
            if (inspected.state === "fulfilled") {
                return inspected.value;
            }
        }
        return value;
    }

    /**
     * @returns whether the given object is a promise.
     * Otherwise it is a fulfilled value.
     */
    Q.isPromise = isPromise;
    function isPromise(object) {
        return object instanceof Promise;
    }

    Q.isPromiseAlike = isPromiseAlike;
    function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
    }

    /**
     * @returns whether the given object is a pending promise, meaning not
     * fulfilled or rejected.
     */
    Q.isPending = isPending;
    function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
    }

    Promise.prototype.isPending = function () {
        return this.inspect().state === "pending";
    };

    /**
     * @returns whether the given object is a value or fulfilled
     * promise.
     */
    Q.isFulfilled = isFulfilled;
    function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
    }

    Promise.prototype.isFulfilled = function () {
        return this.inspect().state === "fulfilled";
    };

    /**
     * @returns whether the given object is a rejected promise.
     */
    Q.isRejected = isRejected;
    function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
    }

    Promise.prototype.isRejected = function () {
        return this.inspect().state === "rejected";
    };

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
    var unhandledReasons = [];
    var unhandledRejections = [];
    var reportedUnhandledRejections = [];
    var trackUnhandledRejections = true;

    function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;

        if (!trackUnhandledRejections) {
            trackUnhandledRejections = true;
        }
    }

    function trackRejection(promise, reason) {
        if (!trackUnhandledRejections) {
            return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                if (array_indexOf(unhandledRejections, promise) !== -1) {
                    process.emit("unhandledRejection", reason, promise);
                    reportedUnhandledRejections.push(promise);
                }
            });
        }

        unhandledRejections.push(promise);
        if (reason && typeof reason.stack !== "undefined") {
            unhandledReasons.push(reason.stack);
        } else {
            unhandledReasons.push("(no stack) " + reason);
        }
    }

    function untrackRejection(promise) {
        if (!trackUnhandledRejections) {
            return;
        }

        var at = array_indexOf(unhandledRejections, promise);
        if (at !== -1) {
            if (typeof process === "object" && typeof process.emit === "function") {
                Q.nextTick.runAfter(function () {
                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
                    if (atReport !== -1) {
                        process.emit("rejectionHandled", unhandledReasons[at], promise);
                        reportedUnhandledRejections.splice(atReport, 1);
                    }
                });
            }
            unhandledRejections.splice(at, 1);
            unhandledReasons.splice(at, 1);
        }
    }

    Q.resetUnhandledRejections = resetUnhandledRejections;

    Q.getUnhandledReasons = function () {
        // Make a copy so that consumers can't interfere with our internal state.
        return unhandledReasons.slice();
    };

    Q.stopUnhandledRejectionTracking = function () {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
    };

    resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

    /**
     * Constructs a rejected promise.
     * @param reason value describing the failure
     */
    Q.reject = reject;
    function reject(reason) {
        var rejection = Promise({
            "when": function (rejected) {
                // note that the error has been handled
                if (rejected) {
                    untrackRejection(this);
                }
                return rejected ? rejected(reason) : this;
            }
        }, function fallback() {
            return this;
        }, function inspect() {
            return {state: "rejected", reason: reason};
        });

        // Note that the reason has not been handled.
        trackRejection(rejection, reason);

        return rejection;
    }

    /**
     * Constructs a fulfilled promise for an immediate reference.
     * @param value immediate reference
     */
    Q.fulfill = fulfill;
    function fulfill(value) {
        return Promise({
            "when": function () {
                return value;
            },
            "get": function (name) {
                return value[name];
            },
            "set": function (name, rhs) {
                value[name] = rhs;
            },
            "delete": function (name) {
                delete value[name];
            },
            "post": function (name, args) {
                // Mark Miller proposes that post with no name should apply a
                // promised function.
                if (name === null || name === void 0) {
                    return value.apply(void 0, args);
                } else {
                    return value[name].apply(value, args);
                }
            },
            "apply": function (thisp, args) {
                return value.apply(thisp, args);
            },
            "keys": function () {
                return object_keys(value);
            }
        }, void 0, function inspect() {
            return {state: "fulfilled", value: value};
        });
    }

    /**
     * Converts thenables to Q promises.
     * @param promise thenable promise
     * @returns a Q promise
     */
    function coerce(promise) {
        var deferred = defer();
        Q.nextTick(function () {
            try {
                promise.then(deferred.resolve, deferred.reject, deferred.notify);
            } catch (exception) {
                deferred.reject(exception);
            }
        });
        return deferred.promise;
    }

    /**
     * Annotates an object such that it will never be
     * transferred away from this process over any promise
     * communication channel.
     * @param object
     * @returns promise a wrapping of that object that
     * additionally responds to the "isDef" message
     * without a rejection.
     */
    Q.master = master;
    function master(object) {
        return Promise({
            "isDef": function () {
            }
        }, function fallback(op, args) {
            return dispatch(object, op, args);
        }, function () {
            return Q(object).inspect();
        });
    }

    /**
     * Spreads the values of a promised array of arguments into the
     * fulfillment callback.
     * @param fulfilled callback that receives variadic arguments from the
     * promised array
     * @param rejected callback that receives the exception if the promise
     * is rejected.
     * @returns a promise for the return value or thrown exception of
     * either callback.
     */
    Q.spread = spread;
    function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
    }

    Promise.prototype.spread = function (fulfilled, rejected) {
        return this.all().then(function (array) {
            return fulfilled.apply(void 0, array);
        }, rejected);
    };

    /**
     * The async function is a decorator for generator functions, turning
     * them into asynchronous generators.  Although generators are only part
     * of the newest ECMAScript 6 drafts, this code does not cause syntax
     * errors in older engines.  This code should continue to work and will
     * in fact improve over time as the language improves.
     *
     * ES6 generators are currently part of V8 version 3.19 with the
     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
     * for longer, but under an older Python-inspired form.  This function
     * works on both kinds of generators.
     *
     * Decorates a generator function such that:
     *  - it may yield promises
     *  - execution will continue when that promise is fulfilled
     *  - the value of the yield expression will be the fulfilled value
     *  - it returns a promise for the return value (when the generator
     *    stops iterating)
     *  - the decorated function returns a promise for the return value
     *    of the generator or the first rejected promise among those
     *    yielded.
     *  - if an error is thrown in the generator, it propagates through
     *    every following yield until it is caught, or until it escapes
     *    the generator function altogether, and is translated into a
     *    rejection for the promise returned by the decorated generator.
     */
    Q.async = async;
    function async(makeGenerator) {
        return function () {
            // when verb is "send", arg is a value
            // when verb is "throw", arg is an exception
            function continuer(verb, arg) {
                var result;

                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
                // engine that has a deployed base of browsers that support generators.
                // However, SM's generators use the Python-inspired semantics of
                // outdated ES6 drafts.  We would like to support ES6, but we'd also
                // like to make it possible to use generators in deployed browsers, so
                // we also support Python-style generators.  At some point we can remove
                // this block.

                if (typeof StopIteration === "undefined") {
                    // ES6 Generators
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        return reject(exception);
                    }
                    if (result.done) {
                        return Q(result.value);
                    } else {
                        return when(result.value, callback, errback);
                    }
                } else {
                    // SpiderMonkey Generators
                    // FIXME: Remove this case when SM does ES6 generators.
                    try {
                        result = generator[verb](arg);
                    } catch (exception) {
                        if (isStopIteration(exception)) {
                            return Q(exception.value);
                        } else {
                            return reject(exception);
                        }
                    }
                    return when(result, callback, errback);
                }
            }

            var generator = makeGenerator.apply(this, arguments);
            var callback = continuer.bind(continuer, "next");
            var errback = continuer.bind(continuer, "throw");
            return callback();
        };
    }

    /**
     * The spawn function is a small wrapper around async that immediately
     * calls the generator and also ends the promise chain, so that any
     * unhandled errors are thrown instead of forwarded to the error
     * handler. This is useful because it's extremely common to run
     * generators at the top-level to work with libraries.
     */
    Q.spawn = spawn;
    function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
    }

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
    /**
     * Throws a ReturnValue exception to stop an asynchronous generator.
     *
     * This interface is a stop-gap measure to support generator return
     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
     * generators like Chromium 29, just use "return" in your generator
     * functions.
     *
     * @param value the return value for the surrounding generator
     * @throws ReturnValue exception with the value.
     * @example
     * // ES6 style
     * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
     * // Older SpiderMonkey style
     * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
     */
    Q["return"] = _return;
    function _return(value) {
        throw new QReturnValue(value);
    }

    /**
     * The promised function decorator ensures that any promise arguments
     * are settled and passed as values (`this` is also settled and passed
     * as a value).  It will also ensure that the result of a function is
     * always a promise.
     *
     * @example
     * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
     * add(Q(a), Q(B));
     *
     * @param {function} callback The function to decorate
     * @returns {function} a function that has been decorated.
     */
    Q.promised = promised;
    function promised(callback) {
        return function () {
            return spread([this, all(arguments)], function (self, args) {
                return callback.apply(self, args);
            });
        };
    }

    /**
     * sends a message to a value in a future turn
     * @param object* the recipient
     * @param op the name of the message operation, e.g., "when",
     * @param args further arguments to be forwarded to the operation
     * @returns result {Promise} a promise for the result of the operation
     */
    Q.dispatch = dispatch;
    function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
    }

    Promise.prototype.dispatch = function (op, args) {
        var self = this;
        var deferred = defer();
        Q.nextTick(function () {
            self.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
    };

    /**
     * Gets the value of a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to get
     * @return promise for the property value
     */
    Q.get = function (object, key) {
        return Q(object).dispatch("get", [key]);
    };

    Promise.prototype.get = function (key) {
        return this.dispatch("get", [key]);
    };

    /**
     * Sets the value of a property in a future turn.
     * @param object    promise or immediate reference for object object
     * @param name      name of property to set
     * @param value     new value of property
     * @return promise for the return value
     */
    Q.set = function (object, key, value) {
        return Q(object).dispatch("set", [key, value]);
    };

    Promise.prototype.set = function (key, value) {
        return this.dispatch("set", [key, value]);
    };

    /**
     * Deletes a property in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of property to delete
     * @return promise for the return value
     */
    Q.del = // XXX legacy
        Q["delete"] = function (object, key) {
            return Q(object).dispatch("delete", [key]);
        };

    Promise.prototype.del = // XXX legacy
        Promise.prototype["delete"] = function (key) {
            return this.dispatch("delete", [key]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param value     a value to post, typically an array of
     *                  invocation arguments for promises that
     *                  are ultimately backed with `resolve` values,
     *                  as opposed to those backed with Urls
     *                  wherein the posted value can be any
     *                  JSON serializable object.
     * @return promise for the return value
     */
// bound locally because it is used by other methods
    Q.mapply = // XXX As proposed by "Redsandro"
        Q.post = function (object, name, args) {
            return Q(object).dispatch("post", [name, args]);
        };

    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
        Promise.prototype.post = function (name, args) {
            return this.dispatch("post", [name, args]);
        };

    /**
     * Invokes a method in a future turn.
     * @param object    promise or immediate reference for target object
     * @param name      name of method to invoke
     * @param ...args   array of invocation arguments
     * @return promise for the return value
     */
    Q.send = // XXX Mark Miller's proposed parlance
        Q.mcall = // XXX As proposed by "Redsandro"
            Q.invoke = function (object, name /*...args*/) {
                return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
            };

    Promise.prototype.send = // XXX Mark Miller's proposed parlance
        Promise.prototype.mcall = // XXX As proposed by "Redsandro"
            Promise.prototype.invoke = function (name /*...args*/) {
                return this.dispatch("post", [name, array_slice(arguments, 1)]);
            };

    /**
     * Applies the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param args      array of application arguments
     */
    Q.fapply = function (object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
    };

    Promise.prototype.fapply = function (args) {
        return this.dispatch("apply", [void 0, args]);
    };

    /**
     * Calls the promised function in a future turn.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q["try"] =
        Q.fcall = function (object /* ...args*/) {
            return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
        };

    Promise.prototype.fcall = function (/*...args*/) {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
    };

    /**
     * Binds the promised function, transforming return values into a fulfilled
     * promise and thrown errors into a rejected one.
     * @param object    promise or immediate reference for target function
     * @param ...args   array of application arguments
     */
    Q.fbind = function (object /*...args*/) {
        var promise = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };
    Promise.prototype.fbind = function (/*...args*/) {
        var promise = this;
        var args = array_slice(arguments);
        return function fbound() {
            return promise.dispatch("apply", [
                this,
                args.concat(array_slice(arguments))
            ]);
        };
    };

    /**
     * Requests the names of the owned properties of a promised
     * object in a future turn.
     * @param object    promise or immediate reference for target object
     * @return promise for the keys of the eventually settled object
     */
    Q.keys = function (object) {
        return Q(object).dispatch("keys", []);
    };

    Promise.prototype.keys = function () {
        return this.dispatch("keys", []);
    };

    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     * @param {Array*} an array (or promise for an array) of values (or
     * promises for values)
     * @returns a promise for an array of the corresponding values
     */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
    Q.all = all;
    function all(promises) {
        return when(promises, function (promises) {
            var pendingCount = 0;
            var deferred = defer();
            array_reduce(promises, function (undefined, promise, index) {
                var snapshot;
                if (
                    isPromise(promise) &&
                    (snapshot = promise.inspect()).state === "fulfilled"
                ) {
                    promises[index] = snapshot.value;
                } else {
                    ++pendingCount;
                    when(
                        promise,
                        function (value) {
                            promises[index] = value;
                            if (--pendingCount === 0) {
                                deferred.resolve(promises);
                            }
                        },
                        deferred.reject,
                        function (progress) {
                            deferred.notify({index: index, value: progress});
                        }
                    );
                }
            }, void 0);
            if (pendingCount === 0) {
                deferred.resolve(promises);
            }
            return deferred.promise;
        });
    }

    Promise.prototype.all = function () {
        return all(this);
    };

    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     * @param {Array*} an array containing values or promises for values
     * @returns a promise fulfilled with the value of the first resolved promise,
     * or a rejected promise if all promises are rejected.
     */
    Q.any = any;

    function any(promises) {
        if (promises.length === 0) {
            return Q.resolve();
        }

        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function (prev, current, index) {
            var promise = promises[index];

            pendingCount++;

            when(promise, onFulfilled, onRejected, onProgress);
            function onFulfilled(result) {
                deferred.resolve(result);
            }

            function onRejected() {
                pendingCount--;
                if (pendingCount === 0) {
                    deferred.reject(new Error(
                        "Can't get fulfillment value from any promise, all " +
                        "promises were rejected."
                    ));
                }
            }

            function onProgress(progress) {
                deferred.notify({
                    index: index,
                    value: progress
                });
            }
        }, undefined);

        return deferred.promise;
    }

    Promise.prototype.any = function () {
        return any(this);
    };

    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     * @param promises a promise for an array (or an array) of promises
     * (or values)
     * @return a promise for an array of promises
     */
    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
    function allResolved(promises) {
        return when(promises, function (promises) {
            promises = array_map(promises, Q);
            return when(all(array_map(promises, function (promise) {
                return when(promise, noop, noop);
            })), function () {
                return promises;
            });
        });
    }

    Promise.prototype.allResolved = function () {
        return allResolved(this);
    };

    /**
     * @see Promise#allSettled
     */
    Q.allSettled = allSettled;
    function allSettled(promises) {
        return Q(promises).allSettled();
    }

    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     * @param {Array[Any*]} values an array (or promise for an array) of values (or
     * promises for values)
     * @returns {Array[State]} an array of states for the respective values.
     */
    Promise.prototype.allSettled = function () {
        return this.then(function (promises) {
            return all(array_map(promises, function (promise) {
                promise = Q(promise);
                function regardless() {
                    return promise.inspect();
                }

                return promise.then(regardless, regardless);
            }));
        });
    };

    /**
     * Captures the failure of a promise, giving an oportunity to recover
     * with a callback.  If the given promise is fulfilled, the returned
     * promise is fulfilled.
     * @param {Any*} promise for something
     * @param {Function} callback to fulfill the returned promise if the
     * given promise is rejected
     * @returns a promise for the return value of the callback
     */
    Q.fail = // XXX legacy
        Q["catch"] = function (object, rejected) {
            return Q(object).then(void 0, rejected);
        };

    Promise.prototype.fail = // XXX legacy
        Promise.prototype["catch"] = function (rejected) {
            return this.then(void 0, rejected);
        };

    /**
     * Attaches a listener that can respond to progress notifications from a
     * promise's originating deferred. This listener receives the exact arguments
     * passed to ``deferred.notify``.
     * @param {Any*} promise for something
     * @param {Function} callback to receive any progress notifications
     * @returns the given promise, unchanged
     */
    Q.progress = progress;
    function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
    }

    Promise.prototype.progress = function (progressed) {
        return this.then(void 0, void 0, progressed);
    };

    /**
     * Provides an opportunity to observe the settling of a promise,
     * regardless of whether the promise is fulfilled or rejected.  Forwards
     * the resolution to the returned promise when the callback is done.
     * The callback can return a promise to defer completion.
     * @param {Any*} promise
     * @param {Function} callback to observe the resolution of the given
     * promise, takes no arguments.
     * @returns a promise for the resolution of the given promise when
     * ``fin`` is done.
     */
    Q.fin = // XXX legacy
        Q["finally"] = function (object, callback) {
            return Q(object)["finally"](callback);
        };

    Promise.prototype.fin = // XXX legacy
        Promise.prototype["finally"] = function (callback) {
            callback = Q(callback);
            return this.then(function (value) {
                return callback.fcall().then(function () {
                    return value;
                });
            }, function (reason) {
                // TODO attempt to recycle the rejection with "this".
                return callback.fcall().then(function () {
                    throw reason;
                });
            });
        };

    /**
     * Terminates a chain of promises, forcing rejections to be
     * thrown as exceptions.
     * @param {Any*} promise at the end of a chain of promises
     * @returns nothing
     */
    Q.done = function (object, fulfilled, rejected, progress) {
        return Q(object).done(fulfilled, rejected, progress);
    };

    Promise.prototype.done = function (fulfilled, rejected, progress) {
        var onUnhandledError = function (error) {
            // forward to a future turn so that ``when``
            // does not catch it and turn it into a rejection.
            Q.nextTick(function () {
                makeStackTraceLong(error, promise);
                if (Q.onerror) {
                    Q.onerror(error);
                } else {
                    throw error;
                }
            });
        };

        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
        var promise = fulfilled || rejected || progress ?
            this.then(fulfilled, rejected, progress) :
            this;

        if (typeof process === "object" && process && process.domain) {
            onUnhandledError = process.domain.bind(onUnhandledError);
        }

        promise.then(void 0, onUnhandledError);
    };

    /**
     * Causes a promise to be rejected if it does not get fulfilled before
     * some milliseconds time out.
     * @param {Any*} promise
     * @param {Number} milliseconds timeout
     * @param {Any*} custom error message or Error object (optional)
     * @returns a promise for the resolution of the given promise if it is
     * fulfilled before the timeout, otherwise rejected.
     */
    Q.timeout = function (object, ms, error) {
        return Q(object).timeout(ms, error);
    };

    Promise.prototype.timeout = function (ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function () {
            if (!error || "string" === typeof error) {
                error = new Error(error || "Timed out after " + ms + " ms");
                error.code = "ETIMEDOUT";
            }
            deferred.reject(error);
        }, ms);

        this.then(function (value) {
            clearTimeout(timeoutId);
            deferred.resolve(value);
        }, function (exception) {
            clearTimeout(timeoutId);
            deferred.reject(exception);
        }, deferred.notify);

        return deferred.promise;
    };

    /**
     * Returns a promise for the given value (or promised value), some
     * milliseconds after it resolved. Passes rejections immediately.
     * @param {Any*} promise
     * @param {Number} milliseconds
     * @returns a promise for the resolution of the given promise after milliseconds
     * time has elapsed since the resolution of the given promise.
     * If the given promise rejects, that is passed immediately.
     */
    Q.delay = function (object, timeout) {
        if (timeout === void 0) {
            timeout = object;
            object = void 0;
        }
        return Q(object).delay(timeout);
    };

    Promise.prototype.delay = function (timeout) {
        return this.then(function (value) {
            var deferred = defer();
            setTimeout(function () {
                deferred.resolve(value);
            }, timeout);
            return deferred.promise;
        });
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided as an array, and returns a promise.
     *
     *      Q.nfapply(FS.readFile, [__filename])
     *      .then(function (content) {
 *      })
     *
     */
    Q.nfapply = function (callback, args) {
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfapply = function (args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Passes a continuation to a Node function, which is called with the given
     * arguments provided individually, and returns a promise.
     * @example
     * Q.nfcall(FS.readFile, __filename)
     * .then(function (content) {
 * })
     *
     */
    Q.nfcall = function (callback /*...args*/) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
    };

    Promise.prototype.nfcall = function (/*...args*/) {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };

    /**
     * Wraps a NodeJS continuation passing function and returns an equivalent
     * version that returns a promise.
     * @example
     * Q.nfbind(FS.readFile, __filename)("utf-8")
     * .then(console.log)
     * .done()
     */
    Q.nfbind =
        Q.denodeify = function (callback /*...args*/) {
            var baseArgs = array_slice(arguments, 1);
            return function () {
                var nodeArgs = baseArgs.concat(array_slice(arguments));
                var deferred = defer();
                nodeArgs.push(deferred.makeNodeResolver());
                Q(callback).fapply(nodeArgs).fail(deferred.reject);
                return deferred.promise;
            };
        };

    Promise.prototype.nfbind =
        Promise.prototype.denodeify = function (/*...args*/) {
            var args = array_slice(arguments);
            args.unshift(this);
            return Q.denodeify.apply(void 0, args);
        };

    Q.nbind = function (callback, thisp /*...args*/) {
        var baseArgs = array_slice(arguments, 2);
        return function () {
            var nodeArgs = baseArgs.concat(array_slice(arguments));
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            function bound() {
                return callback.apply(thisp, arguments);
            }

            Q(bound).fapply(nodeArgs).fail(deferred.reject);
            return deferred.promise;
        };
    };

    Promise.prototype.nbind = function (/*thisp, ...args*/) {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
    };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback with a given array of arguments, plus a provided callback.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param {Array} args arguments to pass to the method; the callback
     * will be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nmapply = // XXX As proposed by "Redsandro"
        Q.npost = function (object, name, args) {
            return Q(object).npost(name, args);
        };

    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
        Promise.prototype.npost = function (name, args) {
            var nodeArgs = array_slice(args || []);
            var deferred = defer();
            nodeArgs.push(deferred.makeNodeResolver());
            this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
            return deferred.promise;
        };

    /**
     * Calls a method of a Node-style object that accepts a Node-style
     * callback, forwarding the given variadic arguments, plus a provided
     * callback argument.
     * @param object an object that has the named method
     * @param {String} name name of the method of object
     * @param ...args arguments to pass to the method; the callback will
     * be provided by Q and appended to these arguments.
     * @returns a promise for the value or error
     */
    Q.nsend = // XXX Based on Mark Miller's proposed "send"
        Q.nmcall = // XXX Based on "Redsandro's" proposal
            Q.ninvoke = function (object, name /*...args*/) {
                var nodeArgs = array_slice(arguments, 2);
                var deferred = defer();
                nodeArgs.push(deferred.makeNodeResolver());
                Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
                return deferred.promise;
            };

    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
        Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
            Promise.prototype.ninvoke = function (name /*...args*/) {
                var nodeArgs = array_slice(arguments, 1);
                var deferred = defer();
                nodeArgs.push(deferred.makeNodeResolver());
                this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
                return deferred.promise;
            };

    /**
     * If a function would like to support both Node continuation-passing-style and
     * promise-returning-style, it can end its internal promise chain with
     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
     * elects to use a nodeback, the result will be sent there.  If they do not
     * pass a nodeback, they will receive the result promise.
     * @param object a result (or a promise for a result)
     * @param {Function} nodeback a Node.js-style callback
     * @returns either the promise or nothing
     */
    Q.nodeify = nodeify;
    function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
    }

    Promise.prototype.nodeify = function (nodeback) {
        if (nodeback) {
            this.then(function (value) {
                Q.nextTick(function () {
                    nodeback(null, value);
                });
            }, function (error) {
                Q.nextTick(function () {
                    nodeback(error);
                });
            });
        } else {
            return this;
        }
    };

    Q.noConflict = function () {
        throw new Error("Q.noConflict only works when Q is used as a global");
    };

// All code before this point will be filtered from stack traces.
    var qEndingLine = captureLine();

    return Q;

});
//This allows Ad Framework to use DOMParser even if not running in a browser environment (e.g. VOLT or Node.js)
//version 0.1.19 https://github.com/jindw/xmldom
if (typeof DOMParser === "undefined") {

    if (typeof print === "function") {
        print("Loading DOMParser implementation...");
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
        console.log("Loading DOMParser implementation...");
    }

    var exp = {};

    (function (exports) {


        (function () {

            /*!
             @preserve
             xmldom (ported from node.js)
             https://github.com/jindw/xmldom/blob/master/LICENSE
             The MIT License (MIT)

             Copyright (c) <year> <copyright holders>

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated documentation files (the "Software"), to deal
             in the Software without restriction, including without limitation the rights
             to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             copies of the Software, and to permit persons to whom the Software is
             furnished to do so, subject to the following conditions:

             The above copyright notice and this permission notice shall be included in
             all copies or substantial portions of the Software.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            //[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
            //[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
            //[5]   	Name	   ::=   	NameStartChar (NameChar)*
            var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/ //\u10000-\uEFFFF
            var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\u00B7\u0300-\u036F\\ux203F-\u2040]");
            var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
            //var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
            //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

            //S_TAG,	S_ATTR,	S_EQ,	S_V
            //S_ATTR_S,	S_E,	S_S,	S_C
            var S_TAG = 0; //tag name offerring
            var S_ATTR = 1; //attr name offerring 
            var S_ATTR_S = 2; //attr name end and space offer
            var S_EQ = 3; //=space?
            var S_V = 4; //attr value(no quot value only)
            var S_E = 5; //attr value end and no space(quot end)
            var S_S = 6; //(attr value end || tag end ) && (space offer)
            var S_C = 7; //closed el<el />

            function XMLReader() {

            }

            XMLReader.prototype = {
                parse: function (source, defaultNSMap, entityMap) {
                    var domBuilder = this.domBuilder;
                    domBuilder.startDocument();
                    _copy(defaultNSMap, defaultNSMap = {})
                    parse(source, defaultNSMap, entityMap,
                        domBuilder, this.errorHandler);
                    domBuilder.endDocument();
                }
            }

            function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
                function fixedFromCharCode(code) {
                    // String.prototype.fromCharCode does not supports
                    // > 2 bytes unicode chars directly
                    if (code > 0xffff) {
                        code -= 0x10000;
                        var surrogate1 = 0xd800 + (code >> 10),
                            surrogate2 = 0xdc00 + (code & 0x3ff);

                        return String.fromCharCode(surrogate1, surrogate2);
                    } else {
                        return String.fromCharCode(code);
                    }
                }

                function entityReplacer(a) {
                    var k = a.slice(1, -1);
                    if (k in entityMap) {
                        return entityMap[k];
                    } else if (k.charAt(0) === '#') {
                        return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')))
                    } else {
                        errorHandler.error('entity not found:' + a);
                        return a;
                    }
                }

                function appendText(end) { //has some bugs
                    var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
                    locator && position(start);
                    domBuilder.characters(xt, 0, end - start);
                    start = end
                }

                function position(start, m) {
                    while (start >= endPos && (m = linePattern.exec(source))) {
                        startPos = m.index;
                        endPos = startPos + m[0].length;
                        locator.lineNumber++;
                        //console.log('line++:',locator,startPos,endPos)
                    }
                    locator.columnNumber = start - startPos + 1;
                }

                var startPos = 0;
                var endPos = 0;
                var linePattern = /.+(?:\r\n?|\n)|.*$/g
                var locator = domBuilder.locator;

                var parseStack = [{
                    currentNSMap: defaultNSMapCopy
                }]
                var closeMap = {};
                var start = 0;
                while (true) {
                    var i = source.indexOf('<', start);
                    if (i < 0) {
                        if (!source.substr(start).match(/^\s*$/)) {
                            var doc = domBuilder.document;
                            var text = doc.createTextNode(source.substr(start));
                            doc.appendChild(text);
                            domBuilder.currentElement = text;
                        }
                        return;
                    }
                    if (i > start) {
                        appendText(i);
                    }
                    switch (source.charAt(i + 1)) {
                        case '/':
                            var end = source.indexOf('>', i + 3);
                            var tagName = source.substring(i + 2, end);
                            var config = parseStack.pop();
                            var localNSMap = config.localNSMap;

                            if (config.tagName != tagName) {
                                errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName);
                            }
                            domBuilder.endElement(config.uri, config.localName, tagName);
                            if (localNSMap) {
                                for (var prefix in localNSMap) {
                                    domBuilder.endPrefixMapping(prefix);
                                }
                            }
                            end++;
                            break;
                        // end elment
                        case '?': // <?...?>
                            locator && position(i);
                            end = parseInstruction(source, i, domBuilder);
                            break;
                        case '!': // <!doctype,<![CDATA,<!--
                            locator && position(i);
                            end = parseDCC(source, i, domBuilder, errorHandler);
                            break;
                        default:
                            try {
                                locator && position(i);

                                var el = new ElementAttributes();

                                //elStartEnd
                                var end = parseElementStartPart(source, i, el, entityReplacer, errorHandler);
                                var len = el.length;
                                //position fixed
                                if (len && locator) {
                                    var backup = copyLocator(locator, {});
                                    for (var i = 0; i < len; i++) {
                                        var a = el[i];
                                        position(a.offset);
                                        a.offset = copyLocator(locator, {});
                                    }
                                    copyLocator(backup, locator);
                                }
                                if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                                    el.closed = true;
                                    if (!entityMap.nbsp) {
                                        errorHandler.warning('unclosed xml attribute');
                                    }
                                }
                                appendElement(el, domBuilder, parseStack);


                                if (el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed) {
                                    end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder)
                                } else {
                                    end++;
                                }
                            } catch (e) {
                                errorHandler.error('element parse error: ' + e);
                                end = -1;
                            }

                    }
                    if (end < 0) {
                        //TODO: ??sax???
                        appendText(i + 1);
                    } else {
                        start = end;
                    }
                }
            }

            function copyLocator(f, t) {
                t.lineNumber = f.lineNumber;
                t.columnNumber = f.columnNumber;
                return t;

            }

            /**
             * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
             * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
             */
            function parseElementStartPart(source, start, el, entityReplacer, errorHandler) {
                var attrName;
                var value;
                var p = ++start;
                var s = S_TAG; //status
                while (true) {
                    var c = source.charAt(p);
                    switch (c) {
                        case '=':
                            if (s === S_ATTR) { //attrName
                                attrName = source.slice(start, p);
                                s = S_EQ;
                            } else if (s === S_ATTR_S) {
                                s = S_EQ;
                            } else {
                                //fatalError: equal must after attrName or space after attrName
                                throw new Error('attribute equal must after attrName');
                            }
                            break;
                        case '\'':
                        case '"':
                            if (s === S_EQ) { //equal
                                start = p + 1;
                                p = source.indexOf(c, start)
                                if (p > 0) {
                                    value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                                    el.add(attrName, value, start - 1);
                                    s = S_E;
                                } else {
                                    //fatalError: no end quot match
                                    throw new Error('attribute value no end \'' + c + '\' match');
                                }
                            } else if (s == S_V) {
                                value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                                //console.log(attrName,value,start,p)
                                el.add(attrName, value, start);
                                //console.dir(el)
                                errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
                                start = p + 1;
                                s = S_E
                            } else {
                                //fatalError: no equal before
                                throw new Error('attribute value must after "="');
                            }
                            break;
                        case '/':
                            switch (s) {
                                case S_TAG:
                                    el.setTagName(source.slice(start, p));
                                case S_E:
                                case S_S:
                                case S_C:
                                    s = S_C;
                                    el.closed = true;
                                case S_V:
                                case S_ATTR:
                                case S_ATTR_S:
                                    break;
                                //case S_EQ:
                                default:
                                    throw new Error("attribute invalid close char('/')")
                            }
                            break;
                        case '': //end document
                            //throw new Error('unexpected end of input')
                            errorHandler.error('unexpected end of input');
                        case '>':
                            switch (s) {
                                case S_TAG:
                                    el.setTagName(source.slice(start, p));
                                case S_E:
                                case S_S:
                                case S_C:
                                    break; //normal
                                case S_V: //Compatible state
                                case S_ATTR:
                                    value = source.slice(start, p);
                                    if (value.slice(-1) === '/') {
                                        el.closed = true;
                                        value = value.slice(0, -1)
                                    }
                                case S_ATTR_S:
                                    if (s === S_ATTR_S) {
                                        value = attrName;
                                    }
                                    if (s == S_V) {
                                        errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                                        el.add(attrName, value.replace(/&#?\w+;/g, entityReplacer), start)
                                    } else {
                                        errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!')
                                        el.add(value, value, start)
                                    }
                                    break;
                                case S_EQ:
                                    throw new Error('attribute value missed!!');
                            }
                            //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
                            return p;
                        /*xml space '\x20' | #x9 | #xD | #xA; */
                        case '\u0080':
                            c = ' ';
                        default:
                            if (c <= ' ') { //space
                                switch (s) {
                                    case S_TAG:
                                        el.setTagName(source.slice(start, p)); //tagName
                                        s = S_S;
                                        break;
                                    case S_ATTR:
                                        attrName = source.slice(start, p)
                                        s = S_ATTR_S;
                                        break;
                                    case S_V:
                                        var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
                                        errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                                        el.add(attrName, value, start)
                                    case S_E:
                                        s = S_S;
                                        break;
                                    //case S_S:
                                    //case S_EQ:
                                    //case S_ATTR_S:
                                    //	void();break;
                                    //case S_C:
                                    //ignore warning
                                }
                            } else { //not space
                                //S_TAG,	S_ATTR,	S_EQ,	S_V
                                //S_ATTR_S,	S_E,	S_S,	S_C
                                switch (s) {
                                    //case S_TAG:void();break;
                                    //case S_ATTR:void();break;
                                    //case S_V:void();break;
                                    case S_ATTR_S:
                                        errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead!!')
                                        el.add(attrName, attrName, start);
                                        start = p;
                                        s = S_ATTR;
                                        break;
                                    case S_E:
                                        errorHandler.warning('attribute space is required"' + attrName + '"!!')
                                    case S_S:
                                        s = S_ATTR;
                                        start = p;
                                        break;
                                    case S_EQ:
                                        s = S_V;
                                        start = p;
                                        break;
                                    case S_C:
                                        throw new Error("elements closed character '/' and '>' must be connected to");
                                }
                            }
                    }
                    p++;
                }
            }

            /**
             * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
             */
            function appendElement(el, domBuilder, parseStack) {
                var tagName = el.tagName;
                var localNSMap = null;
                var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                var i = el.length;
                while (i--) {
                    var a = el[i];
                    var qName = a.qName;
                    var value = a.value;
                    var nsp = qName.indexOf(':');
                    if (nsp > 0) {
                        var prefix = a.prefix = qName.slice(0, nsp);
                        var localName = qName.slice(nsp + 1);
                        var nsPrefix = prefix === 'xmlns' && localName
                    } else {
                        localName = qName;
                        prefix = null
                        nsPrefix = qName === 'xmlns' && ''
                    }
                    //can not set prefix,because prefix !== ''
                    a.localName = localName;
                    //prefix == null for no ns prefix attribute 
                    if (nsPrefix !== false) { //hack!!
                        if (localNSMap == null) {
                            localNSMap = {}
                            //console.log(currentNSMap,0)
                            _copy(currentNSMap, currentNSMap = {})
                            //console.log(currentNSMap,1)
                        }
                        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                        a.uri = 'http://www.w3.org/2000/xmlns/'
                        domBuilder.startPrefixMapping(nsPrefix, value)
                    }
                }
                var i = el.length;
                while (i--) {
                    a = el[i];
                    var prefix = a.prefix;
                    if (prefix) { //no prefix attribute has no namespace
                        if (prefix === 'xml') {
                            a.uri = 'http://www.w3.org/XML/1998/namespace';
                        }
                        if (prefix !== 'xmlns') {
                            a.uri = currentNSMap[prefix]

                            //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
                        }
                    }
                }
                var nsp = tagName.indexOf(':');
                if (nsp > 0) {
                    prefix = el.prefix = tagName.slice(0, nsp);
                    localName = el.localName = tagName.slice(nsp + 1);
                } else {
                    prefix = null; //important!!
                    localName = el.localName = tagName;
                }
                //no prefix element has default namespace
                var ns = el.uri = currentNSMap[prefix || ''];
                domBuilder.startElement(ns, localName, tagName, el);
                //endPrefixMapping and startPrefixMapping have not any help for dom builder
                //localNSMap = null
                if (el.closed) {
                    domBuilder.endElement(ns, localName, tagName);
                    if (localNSMap) {
                        for (prefix in localNSMap) {
                            domBuilder.endPrefixMapping(prefix)
                        }
                    }
                } else {
                    el.currentNSMap = currentNSMap;
                    el.localNSMap = localNSMap;
                    parseStack.push(el);
                }
            }

            function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
                if (/^(?:script|textarea)$/i.test(tagName)) {
                    var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
                    var text = source.substring(elStartEnd + 1, elEndStart);
                    if (/[&<]/.test(text)) {
                        if (/^script$/i.test(tagName)) {
                            //if(!/\]\]>/.test(text)){
                            //lexHandler.startCDATA();
                            domBuilder.characters(text, 0, text.length);
                            //lexHandler.endCDATA();
                            return elEndStart;
                            //}
                        } //}else{//text area
                        text = text.replace(/&#?\w+;/g, entityReplacer);
                        domBuilder.characters(text, 0, text.length);
                        return elEndStart;
                        //}

                    }
                }
                return elStartEnd + 1;
            }

            function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
                //if(tagName in closeMap){
                var pos = closeMap[tagName];
                if (pos == null) {
                    //console.log(tagName)
                    pos = closeMap[tagName] = source.lastIndexOf('</' + tagName + '>')
                }
                return pos < elStartEnd;
                //} 
            }

            function _copy(source, target) {
                for (var n in source) {
                    target[n] = source[n]
                }
            }

            function parseDCC(source, start, domBuilder, errorHandler) { //sure start with '<!'
                var next = source.charAt(start + 2)
                switch (next) {
                    case '-':
                        if (source.charAt(start + 3) === '-') {
                            var end = source.indexOf('-->', start + 4);
                            //append comment source.substring(4,end)//<!--
                            if (end > start) {
                                domBuilder.comment(source, start + 4, end - start - 4);
                                return end + 3;
                            } else {
                                errorHandler.error("Unclosed comment");
                                return -1;
                            }
                        } else {
                            //error
                            return -1;
                        }
                    default:
                        if (source.substr(start + 3, 6) == 'CDATA[') {
                            var end = source.indexOf(']]>', start + 9);
                            domBuilder.startCDATA();
                            domBuilder.characters(source, start + 9, end - start - 9);
                            domBuilder.endCDATA()
                            return end + 3;
                        }
                        //<!DOCTYPE
                        //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
                        var matchs = split(source, start);
                        var len = matchs.length;
                        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                            var name = matchs[1][0];
                            var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
                            var sysid = len > 4 && matchs[4][0];
                            var lastMatch = matchs[len - 1]
                            domBuilder.startDTD(name, pubid && pubid.replace(/^(['"])(.*?)\1$/, '$2'),
                                sysid && sysid.replace(/^(['"])(.*?)\1$/, '$2'));
                            domBuilder.endDTD();

                            return lastMatch.index + lastMatch[0].length
                        }
                }
                return -1;
            }


            function parseInstruction(source, start, domBuilder) {
                var end = source.indexOf('?>', start);
                if (end) {
                    var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                    if (match) {
                        var len = match[0].length;
                        domBuilder.processingInstruction(match[1], match[2]);
                        return end + 2;
                    } else { //error
                        return -1;
                    }
                }
                return -1;
            }

            /**
             * @param source
             */
            function ElementAttributes(source) {

            }

            ElementAttributes.prototype = {
                setTagName: function (tagName) {
                    if (!tagNamePattern.test(tagName)) {
                        throw new Error('invalid tagName:' + tagName)
                    }
                    this.tagName = tagName
                },
                add: function (qName, value, offset) {
                    if (!tagNamePattern.test(qName)) {
                        throw new Error('invalid attribute:' + qName)
                    }
                    this[this.length++] = {
                        qName: qName,
                        value: value,
                        offset: offset
                    }
                },
                length: 0,
                getLocalName: function (i) {
                    return this[i].localName
                },
                getOffset: function (i) {
                    return this[i].offset
                },
                getQName: function (i) {
                    return this[i].qName
                },
                getURI: function (i) {
                    return this[i].uri
                },
                getValue: function (i) {
                    return this[i].value
                }
                //	,getIndex:function(uri, localName)){
                //		if(localName){
                //
                //		}else{
                //			var qName = uri
                //		}
                //	},
                //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
                //	getType:function(uri,localName){}
                //	getType:function(i){},
            }


            function _set_proto_(thiz, parent) {
                thiz.__proto__ = parent;
                return thiz;
            }

            if (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {
                _set_proto_ = function (thiz, parent) {
                    function p() {
                    };
                    p.prototype = parent;
                    p = new p();
                    for (parent in thiz) {
                        p[parent] = thiz[parent];
                    }
                    return p;
                }
            }

            function split(source, start) {
                var match;
                var buf = [];
                var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                reg.lastIndex = start;
                reg.exec(source); //skip <
                while (match = reg.exec(source)) {
                    buf.push(match);
                    if (match[1]) return buf;
                }
            }

            if (typeof require == 'function') {
                exports.XMLReader = XMLReader;
            }
        }())

        var XMLReader = exports.XMLReader;

        (function () {

            /*!
             @preserve
             xmldom (ported from node.js)
             https://github.com/jindw/xmldom/blob/master/LICENSE
             The MIT License (MIT)

             Copyright (c) <year> <copyright holders>

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated documentation files (the "Software"), to deal
             in the Software without restriction, including without limitation the rights
             to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             copies of the Software, and to permit persons to whom the Software is
             furnished to do so, subject to the following conditions:

             The above copyright notice and this permission notice shall be included in
             all copies or substantial portions of the Software.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */

            /*
             * DOM Level 2
             * Object DOMException
             * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
             */

            function copy(src, dest) {
                for (var p in src) {
                    dest[p] = src[p];
                }
            }

            /**
             ^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
             ^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
             */
            function _extends(Class, Super) {
                var pt = Class.prototype;
                if (Object.create) {
                    var ppt = Object.create(Super.prototype)
                    pt.__proto__ = ppt;
                }
                if (!(pt instanceof Super)) {
                    function t() {
                    };
                    t.prototype = Super.prototype;
                    t = new t();
                    copy(pt, t);
                    Class.prototype = pt = t;
                }
                if (pt.constructor != Class) {
                    if (typeof Class != 'function') {
                        try {
                            console.error("unknown Class:" + Class)
                        } catch (e) {
                        }
                    }
                    pt.constructor = Class
                }
            }

            var htmlns = 'http://www.w3.org/1999/xhtml';
            // Node Types
            var NodeType = {}
            var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
            var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
            var TEXT_NODE = NodeType.TEXT_NODE = 3;
            var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
            var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
            var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
            var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
            var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
            var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
            var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
            var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
            var NOTATION_NODE = NodeType.NOTATION_NODE = 12;

            // ExceptionCode
            var ExceptionCode = {}
            var ExceptionMessage = {};
            var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = ((ExceptionMessage[1] = "Index size error"), 1);
            var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = ((ExceptionMessage[2] = "DOMString size error"), 2);
            var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = ((ExceptionMessage[3] = "Hierarchy request error"), 3);
            var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = ((ExceptionMessage[4] = "Wrong document"), 4);
            var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = ((ExceptionMessage[5] = "Invalid character"), 5);
            var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = ((ExceptionMessage[6] = "No data allowed"), 6);
            var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7] = "No modification allowed"), 7);
            var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = ((ExceptionMessage[8] = "Not found"), 8);
            var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = ((ExceptionMessage[9] = "Not supported"), 9);
            var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = ((ExceptionMessage[10] = "Attribute in use"), 10);
            //level2
            var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = ((ExceptionMessage[11] = "Invalid state"), 11);
            var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = ((ExceptionMessage[12] = "Syntax error"), 12);
            var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = ((ExceptionMessage[13] = "Invalid modification"), 13);
            var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = ((ExceptionMessage[14] = "Invalid namespace"), 14);
            var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = ((ExceptionMessage[15] = "Invalid access"), 15);


            function DOMException(code, message) {
                if (message instanceof Error) {
                    var error = message;
                } else {
                    error = this;
                    Error.call(this, ExceptionMessage[code]);
                    this.message = ExceptionMessage[code];
                    if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
                }
                error.code = code;
                if (message) this.message = this.message + ": " + message;
                return error;
            };
            DOMException.prototype = Error.prototype;
            copy(ExceptionCode, DOMException)
            /**
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
             * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
             * The items in the NodeList are accessible via an integral index, starting from 0.
             */
            function NodeList() {
            };
            NodeList.prototype = {
                /**
                 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
                 * @standard level1
                 */
                length: 0,
                /**
                 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
                 * @standard level1
                 * @param index  unsigned long
                 *   Index into the collection.
                 * @return Node
                 *    The node at the indexth position in the NodeList, or null if that is not a valid index.
                 */
                item: function (index) {
                    return this[index] || null;
                }
            };

            function LiveNodeList(node, refresh) {
                this._node = node;
                this._refresh = refresh
                _updateLiveList(this);
            }

            function _updateLiveList(list) {
                var inc = list._node._inc || list._node.ownerDocument._inc;
                if (list._inc != inc) {
                    var ls = list._refresh(list._node);
                    //console.log(ls.length)
                    __set__(list, 'length', ls.length);
                    copy(ls, list);
                    list._inc = inc;
                }
            }

            LiveNodeList.prototype.item = function (i) {
                _updateLiveList(this);
                return this[i];
            }

            _extends(LiveNodeList, NodeList);
            /**
             *
             * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
             * NamedNodeMap objects in the DOM are live.
             * used for attributes or DocumentType entities
             */
            function NamedNodeMap() {
            };

            function _findNodeIndex(list, node) {
                var i = list.length;
                while (i--) {
                    if (list[i] === node) {
                        return i
                    }
                }
            }

            function _addNamedNode(el, list, newAttr, oldAttr) {
                if (oldAttr) {
                    list[_findNodeIndex(list, oldAttr)] = newAttr;
                } else {
                    list[list.length++] = newAttr;
                }
                if (el) {
                    newAttr.ownerElement = el;
                    var doc = el.ownerDocument;
                    if (doc) {
                        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                        _onAddAttribute(doc, el, newAttr);
                    }
                }
            }

            function _removeNamedNode(el, list, attr) {
                var i = _findNodeIndex(list, attr);
                if (i >= 0) {
                    var lastIndex = list.length - 1
                    while (i < lastIndex) {
                        list[i] = list[++i]
                    }
                    list.length = lastIndex;
                    if (el) {
                        var doc = el.ownerDocument;
                        if (doc) {
                            _onRemoveAttribute(doc, el, attr);
                            attr.ownerElement = null;
                        }
                    }
                } else {
                    throw DOMException(NOT_FOUND_ERR, new Error())
                }
            }

            NamedNodeMap.prototype = {
                length: 0,
                item: NodeList.prototype.item,
                getNamedItem: function (key) {
                    //		if(key.indexOf(':')>0 || key == 'xmlns'){
                    //			return null;
                    //		}
                    var i = this.length;
                    while (i--) {
                        var attr = this[i];
                        if (attr.nodeName == key) {
                            return attr;
                        }
                    }
                },
                setNamedItem: function (attr) {
                    var el = attr.ownerElement;
                    if (el && el != this._ownerElement) {
                        throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    }
                    var oldAttr = this.getNamedItem(attr.nodeName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },
                /* returns Node */
                setNamedItemNS: function (attr) { // raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
                    var el = attr.ownerElement,
                        oldAttr;
                    if (el && el != this._ownerElement) {
                        throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    }
                    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },

                /* returns Node */
                removeNamedItem: function (key) {
                    var attr = this.getNamedItem(key);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;


                }, // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

                //for level2
                removeNamedItemNS: function (namespaceURI, localName) {
                    var attr = this.getNamedItemNS(namespaceURI, localName);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;
                },
                getNamedItemNS: function (namespaceURI, localName) {
                    var i = this.length;
                    while (i--) {
                        var node = this[i];
                        if (node.localName == localName && node.namespaceURI == namespaceURI) {
                            return node;
                        }
                    }
                    return null;
                }
            };
            /**
             * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
             */
            function DOMImplementation(/* Object */ features) {
                this._features = {};
                if (features) {
                    for (var feature in features) {
                        this._features = features[feature];
                    }
                }
            };

            DOMImplementation.prototype = {
                hasFeature: function (/* string */ feature, /* string */ version) {
                    var versions = this._features[feature.toLowerCase()];
                    if (versions && (!version || version in versions)) {
                        return true;
                    } else {
                        return false;
                    }
                },
                // Introduced in DOM Level 2:
                createDocument: function (namespaceURI, qualifiedName, doctype) { // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
                    var doc = new Document();
                    doc.implementation = this;
                    doc.childNodes = new NodeList();
                    doc.doctype = doctype;
                    if (doctype) {
                        doc.appendChild(doctype);
                    }
                    if (qualifiedName) {
                        var root = doc.createElementNS(namespaceURI, qualifiedName);
                        doc.appendChild(root);
                    }
                    return doc;
                },
                // Introduced in DOM Level 2:
                createDocumentType: function (qualifiedName, publicId, systemId) { // raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
                    var node = new DocumentType();
                    node.name = qualifiedName;
                    node.nodeName = qualifiedName;
                    node.publicId = publicId;
                    node.systemId = systemId;
                    // Introduced in DOM Level 2:
                    //readonly attribute DOMString        internalSubset;

                    //TODO:..
                    //  readonly attribute NamedNodeMap     entities;
                    //  readonly attribute NamedNodeMap     notations;
                    return node;
                }
            };


            /**
             * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
             */

            function Node() {
            };

            Node.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                // Modified in DOM Level 2:
                insertBefore: function (newChild, refChild) { //raises
                    return _insertBefore(this, newChild, refChild);
                },
                replaceChild: function (newChild, oldChild) { //raises
                    this.insertBefore(newChild, oldChild);
                    if (oldChild) {
                        this.removeChild(oldChild);
                    }
                },
                removeChild: function (oldChild) {
                    return _removeChild(this, oldChild);
                },
                appendChild: function (newChild) {
                    return this.insertBefore(newChild, null);
                },
                hasChildNodes: function () {
                    return this.firstChild != null;
                },
                cloneNode: function (deep) {
                    return cloneNode(this.ownerDocument || this, this, deep);
                },
                // Modified in DOM Level 2:
                normalize: function () {
                    var child = this.firstChild;
                    while (child) {
                        var next = child.nextSibling;
                        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                            this.removeChild(next);
                            child.appendData(next.data);
                        } else {
                            child.normalize();
                            child = next;
                        }
                    }
                },
                // Introduced in DOM Level 2:
                isSupported: function (feature, version) {
                    return this.ownerDocument.implementation.hasFeature(feature, version);
                },
                // Introduced in DOM Level 2:
                hasAttributes: function () {
                    return this.attributes.length > 0;
                },
                lookupPrefix: function (namespaceURI) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        //console.dir(map)
                        if (map) {
                            for (var n in map) {
                                if (map[n] == namespaceURI) {
                                    return n;
                                }
                            }
                        }
                        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                // Introduced in DOM Level 3:
                lookupNamespaceURI: function (prefix) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        //console.dir(map)
                        if (map) {
                            if (prefix in map) {
                                return map[prefix];
                            }
                        }
                        el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                // Introduced in DOM Level 3:
                isDefaultNamespace: function (namespaceURI) {
                    var prefix = this.lookupPrefix(namespaceURI);
                    return prefix == null;
                }
            };


            function _xmlEncoder(c) {
                return c == '<' && '&lt;' ||
                    c == '>' && '&gt;' ||
                    c == '&' && '&amp;' ||
                    c == '"' && '&quot;' ||
                    '&#' + c.charCodeAt() + ';'
            }


            copy(NodeType, Node);
            copy(NodeType, Node.prototype);

            /**
             * @param callback return true for continue,false for break
             * @return boolean true: break visit;
             */
            function _visitNode(node, callback) {
                if (callback(node)) {
                    return true;
                }
                if (node = node.firstChild) {
                    do {
                        if (_visitNode(node, callback)) {
                            return true
                        }
                    } while (node = node.nextSibling)
                }
            }


            function Document() {
            }

            function _onAddAttribute(doc, el, newAttr) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns == 'http://www.w3.org/2000/xmlns/') {
                    //update namespace
                    el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value
                }
            }

            function _onRemoveAttribute(doc, el, newAttr, remove) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns == 'http://www.w3.org/2000/xmlns/') {
                    //update namespace
                    delete el._nsMap[newAttr.prefix ? newAttr.localName : '']
                }
            }

            function _onUpdateChild(doc, el, newChild) {
                if (doc && doc._inc) {
                    doc._inc++;
                    //update childNodes
                    var cs = el.childNodes;
                    if (newChild) {
                        cs[cs.length++] = newChild;
                    } else {
                        //console.log(1)
                        var child = el.firstChild;
                        var i = 0;
                        while (child) {
                            cs[i++] = child;
                            child = child.nextSibling;
                        }
                        cs.length = i;
                    }
                }
            }

            /**
             * attributes;
             * children;
             *
             * writeable properties:
             * nodeValue,Attr:value,CharacterData:data
             * prefix
             */
            function _removeChild(parentNode, child) {
                var previous = child.previousSibling;
                var next = child.nextSibling;
                if (previous) {
                    previous.nextSibling = next;
                } else {
                    parentNode.firstChild = next
                }
                if (next) {
                    next.previousSibling = previous;
                } else {
                    parentNode.lastChild = previous;
                }
                _onUpdateChild(parentNode.ownerDocument, parentNode);
                return child;
            }

            /**
             * preformance key(refChild == null)
             */
            function _insertBefore(parentNode, newChild, nextChild) {
                var cp = newChild.parentNode;
                if (cp) {
                    cp.removeChild(newChild); //remove and update
                }
                if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
                    var newFirst = newChild.firstChild;
                    if (newFirst == null) {
                        return newChild;
                    }
                    var newLast = newChild.lastChild;
                } else {
                    newFirst = newLast = newChild;
                }
                var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

                newFirst.previousSibling = pre;
                newLast.nextSibling = nextChild;


                if (pre) {
                    pre.nextSibling = newFirst;
                } else {
                    parentNode.firstChild = newFirst;
                }
                if (nextChild == null) {
                    parentNode.lastChild = newLast;
                } else {
                    nextChild.previousSibling = newLast;
                }
                do {
                    newFirst.parentNode = parentNode;
                } while (newFirst !== newLast && (newFirst = newFirst.nextSibling))
                _onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
                //console.log(parentNode.lastChild.nextSibling == null)
                if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                    newChild.firstChild = newChild.lastChild = null;
                }
                return newChild;
            }

            function _appendSingleChild(parentNode, newChild) {
                var cp = newChild.parentNode;
                if (cp) {
                    var pre = parentNode.lastChild;
                    cp.removeChild(newChild); //remove and update
                    var pre = parentNode.lastChild;
                }
                var pre = parentNode.lastChild;
                newChild.parentNode = parentNode;
                newChild.previousSibling = pre;
                newChild.nextSibling = null;
                if (pre) {
                    pre.nextSibling = newChild;
                } else {
                    parentNode.firstChild = newChild;
                }
                parentNode.lastChild = newChild;
                _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
                return newChild;
                //console.log("__aa",parentNode.lastChild.nextSibling == null)
            }

            Document.prototype = {
                //implementation : null,
                nodeName: '#document',
                nodeType: DOCUMENT_NODE,
                doctype: null,
                documentElement: null,
                _inc: 1,

                insertBefore: function (newChild, refChild) { //raises
                    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                        var child = newChild.firstChild;
                        while (child) {
                            var next = child.nextSibling;
                            this.insertBefore(child, refChild);
                            child = next;
                        }
                        return newChild;
                    }
                    if (this.documentElement == null && newChild.nodeType == 1) {
                        this.documentElement = newChild;
                    }

                    return _insertBefore(this, newChild, refChild), (newChild.ownerDocument = this), newChild;
                },
                removeChild: function (oldChild) {
                    if (this.documentElement == oldChild) {
                        this.documentElement = null;
                    }
                    return _removeChild(this, oldChild);
                },
                // Introduced in DOM Level 2:
                importNode: function (importedNode, deep) {
                    return importNode(this, importedNode, deep);
                },
                // Introduced in DOM Level 2:
                getElementById: function (id) {
                    var rtv = null;
                    _visitNode(this.documentElement, function (node) {
                        if (node.nodeType == 1) {
                            if (node.getAttribute('id') == id) {
                                rtv = node;
                                return true;
                            }
                        }
                    })
                    return rtv;
                },

                //document factory method:
                createElement: function (tagName) {
                    var node = new Element();
                    node.ownerDocument = this;
                    node.nodeName = tagName;
                    node.tagName = tagName;
                    node.childNodes = new NodeList();
                    var attrs = node.attributes = new NamedNodeMap();
                    attrs._ownerElement = node;
                    return node;
                },
                createDocumentFragment: function () {
                    var node = new DocumentFragment();
                    node.ownerDocument = this;
                    node.childNodes = new NodeList();
                    return node;
                },
                createTextNode: function (data) {
                    var node = new Text();
                    node.ownerDocument = this;
                    node.appendData(data)
                    return node;
                },
                createComment: function (data) {
                    var node = new Comment();
                    node.ownerDocument = this;
                    node.appendData(data)
                    return node;
                },
                createCDATASection: function (data) {
                    var node = new CDATASection();
                    node.ownerDocument = this;
                    node.appendData(data)
                    return node;
                },
                createProcessingInstruction: function (target, data) {
                    var node = new ProcessingInstruction();
                    node.ownerDocument = this;
                    node.tagName = node.target = target;
                    node.nodeValue = node.data = data;
                    return node;
                },
                createAttribute: function (name) {
                    var node = new Attr();
                    node.ownerDocument = this;
                    node.name = name;
                    node.nodeName = name;
                    node.localName = name;
                    node.specified = true;
                    return node;
                },
                createEntityReference: function (name) {
                    var node = new EntityReference();
                    node.ownerDocument = this;
                    node.nodeName = name;
                    return node;
                },
                // Introduced in DOM Level 2:
                createElementNS: function (namespaceURI, qualifiedName) {
                    var node = new Element();
                    var pl = qualifiedName.split(':');
                    var attrs = node.attributes = new NamedNodeMap();
                    node.childNodes = new NodeList();
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.tagName = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else {
                        //el.prefix = null;
                        node.localName = qualifiedName;
                    }
                    attrs._ownerElement = node;
                    return node;
                },
                // Introduced in DOM Level 2:
                createAttributeNS: function (namespaceURI, qualifiedName) {
                    var node = new Attr();
                    var pl = qualifiedName.split(':');
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.name = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    node.specified = true;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else {
                        //el.prefix = null;
                        node.localName = qualifiedName;
                    }
                    return node;
                }
            };
            _extends(Document, Node);


            function Element() {
                this._nsMap = {};
            };
            Element.prototype = {
                nodeType: ELEMENT_NODE,
                hasAttribute: function (name) {
                    return this.getAttributeNode(name) != null;
                },
                getAttribute: function (name) {
                    var attr = this.getAttributeNode(name);
                    return attr && attr.value || '';
                },
                getAttributeNode: function (name) {
                    return this.attributes.getNamedItem(name);
                },
                setAttribute: function (name, value) {
                    var attr = this.ownerDocument.createAttribute(name);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr)
                },
                removeAttribute: function (name) {
                    var attr = this.getAttributeNode(name)
                    attr && this.removeAttributeNode(attr);
                },

                //four real opeartion method
                appendChild: function (newChild) {
                    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
                        return this.insertBefore(newChild, null);
                    } else {
                        return _appendSingleChild(this, newChild);
                    }
                },
                setAttributeNode: function (newAttr) {
                    return this.attributes.setNamedItem(newAttr);
                },
                setAttributeNodeNS: function (newAttr) {
                    return this.attributes.setNamedItemNS(newAttr);
                },
                removeAttributeNode: function (oldAttr) {
                    return this.attributes.removeNamedItem(oldAttr.nodeName);
                },
                //get real attribute name,and remove it by removeAttributeNode
                removeAttributeNS: function (namespaceURI, localName) {
                    var old = this.getAttributeNodeNS(namespaceURI, localName);
                    old && this.removeAttributeNode(old);
                },

                hasAttributeNS: function (namespaceURI, localName) {
                    return this.getAttributeNodeNS(namespaceURI, localName) != null;
                },
                getAttributeNS: function (namespaceURI, localName) {
                    var attr = this.getAttributeNodeNS(namespaceURI, localName);
                    return attr && attr.value || '';
                },
                setAttributeNS: function (namespaceURI, qualifiedName, value) {
                    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr)
                },
                getAttributeNodeNS: function (namespaceURI, localName) {
                    return this.attributes.getNamedItemNS(namespaceURI, localName);
                },

                getElementsByTagName: function (tagName) {
                    return new LiveNodeList(this, function (base) {
                        var ls = [];
                        _visitNode(base, function (node) {
                            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
                                ls.push(node);
                            }
                        });
                        return ls;
                    });
                },
                getElementsByTagNameNS: function (namespaceURI, localName) {
                    return new LiveNodeList(this, function (base) {
                        var ls = [];
                        _visitNode(base, function (node) {
                            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {
                                ls.push(node);
                            }
                        });
                        return ls;
                    });
                }
            };
            Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
            Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


            _extends(Element, Node);

            function Attr() {
            };
            Attr.prototype.nodeType = ATTRIBUTE_NODE;
            _extends(Attr, Node);


            function CharacterData() {
            };
            CharacterData.prototype = {
                data: '',
                substringData: function (offset, count) {
                    return this.data.substring(offset, offset + count);
                },
                appendData: function (text) {
                    text = this.data + text;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                },
                insertData: function (offset, text) {
                    this.replaceData(offset, 0, text);

                },
                appendChild: function (newChild) {
                    //if(!(newChild instanceof CharacterData)){
                    throw new Error(ExceptionMessage[3])
                    //}
                    //return Node.prototype.appendChild.apply(this, arguments)
                },
                deleteData: function (offset, count) {
                    this.replaceData(offset, count, "");
                },
                replaceData: function (offset, count, text) {
                    var start = this.data.substring(0, offset);
                    var end = this.data.substring(offset + count);
                    text = start + text + end;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                }
            }
            _extends(CharacterData, Node);

            function Text() {
            };
            Text.prototype = {
                nodeName: "#text",
                nodeType: TEXT_NODE,
                splitText: function (offset) {
                    var text = this.data;
                    var newText = text.substring(offset);
                    text = text.substring(0, offset);
                    this.data = this.nodeValue = text;
                    this.length = text.length;
                    var newNode = this.ownerDocument.createTextNode(newText);
                    if (this.parentNode) {
                        this.parentNode.insertBefore(newNode, this.nextSibling);
                    }
                    return newNode;
                }
            }
            _extends(Text, CharacterData);

            function Comment() {
            };
            Comment.prototype = {
                nodeName: "#comment",
                nodeType: COMMENT_NODE
            }
            _extends(Comment, CharacterData);

            function CDATASection() {
            };
            CDATASection.prototype = {
                nodeName: "#cdata-section",
                nodeType: CDATA_SECTION_NODE
            }
            _extends(CDATASection, CharacterData);


            function DocumentType() {
            };
            DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
            _extends(DocumentType, Node);

            function Notation() {
            };
            Notation.prototype.nodeType = NOTATION_NODE;
            _extends(Notation, Node);

            function Entity() {
            };
            Entity.prototype.nodeType = ENTITY_NODE;
            _extends(Entity, Node);

            function EntityReference() {
            };
            EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
            _extends(EntityReference, Node);

            function DocumentFragment() {
            };
            DocumentFragment.prototype.nodeName = "#document-fragment";
            DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
            _extends(DocumentFragment, Node);


            function ProcessingInstruction() {
            }

            ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
            _extends(ProcessingInstruction, Node);

            function XMLSerializer() {
            }

            XMLSerializer.prototype.serializeToString = function (node) {
                var buf = [];
                serializeToString(node, buf);
                return buf.join('');
            }
            Node.prototype.toString = function () {
                return XMLSerializer.prototype.serializeToString(this);
            }

            function serializeToString(node, buf) {
                switch (node.nodeType) {
                    case ELEMENT_NODE:
                        var attrs = node.attributes;
                        var len = attrs.length;
                        var child = node.firstChild;
                        var nodeName = node.tagName;
                        var isHTML = htmlns === node.namespaceURI
                        buf.push('<', nodeName);
                        for (var i = 0; i < len; i++) {
                            serializeToString(attrs.item(i), buf, isHTML);
                        }
                        if (child || isHTML && !/^(?:meta|link|img|br|hr|input|button)$/i.test(nodeName)) {
                            buf.push('>');
                            //if is cdata child node
                            if (isHTML && /^script$/i.test(nodeName)) {
                                if (child) {
                                    buf.push(child.data);
                                }
                            } else {
                                while (child) {
                                    serializeToString(child, buf);
                                    child = child.nextSibling;
                                }
                            }
                            buf.push('</', nodeName, '>');
                        } else {
                            buf.push('/>');
                        }
                        return;
                    case DOCUMENT_NODE:
                    case DOCUMENT_FRAGMENT_NODE:
                        var child = node.firstChild;
                        while (child) {
                            serializeToString(child, buf);
                            child = child.nextSibling;
                        }
                        return;
                    case ATTRIBUTE_NODE:
                        return buf.push(' ', node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
                    case TEXT_NODE:
                        return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));
                    case CDATA_SECTION_NODE:
                        return buf.push('<![CDATA[', node.data, ']]>');
                    case COMMENT_NODE:
                        return buf.push("<!--", node.data, "-->");
                    case DOCUMENT_TYPE_NODE:
                        var pubid = node.publicId;
                        var sysid = node.systemId;
                        buf.push('<!DOCTYPE ', node.name);
                        if (pubid) {
                            buf.push(' PUBLIC "', pubid);
                            if (sysid && sysid != '.') {
                                buf.push('" "', sysid);
                            }
                            buf.push('">');
                        } else if (sysid && sysid != '.') {
                            buf.push(' SYSTEM "', sysid, '">');
                        } else {
                            var sub = node.internalSubset;
                            if (sub) {
                                buf.push(" [", sub, "]");
                            }
                            buf.push(">");
                        }
                        return;
                    case PROCESSING_INSTRUCTION_NODE:
                        return buf.push("<?", node.target, " ", node.data, "?>");
                    case ENTITY_REFERENCE_NODE:
                        return buf.push('&', node.nodeName, ';');
                    //case ENTITY_NODE:
                    //case NOTATION_NODE:
                    default:
                        buf.push('??', node.nodeName);
                }
            }

            function importNode(doc, node, deep) {
                var node2;
                switch (node.nodeType) {
                    case ELEMENT_NODE:
                        node2 = node.cloneNode(false);
                        node2.ownerDocument = doc;
                    //var attrs = node2.attributes;
                    //var len = attrs.length;
                    //for(var i=0;i<len;i++){
                    //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
                    //}
                    case DOCUMENT_FRAGMENT_NODE:
                        break;
                    case ATTRIBUTE_NODE:
                        deep = true;
                        break;
                    //case ENTITY_REFERENCE_NODE:
                    //case PROCESSING_INSTRUCTION_NODE:
                    ////case TEXT_NODE:
                    //case CDATA_SECTION_NODE:
                    //case COMMENT_NODE:
                    //	deep = false;
                    //	break;
                    //case DOCUMENT_NODE:
                    //case DOCUMENT_TYPE_NODE:
                    //cannot be imported.
                    //case ENTITY_NODE:
                    //case NOTATION_NODE:
                    //can not hit in level3
                    //default:throw e;
                }
                if (!node2) {
                    node2 = node.cloneNode(false); //false
                }
                node2.ownerDocument = doc;
                node2.parentNode = null;
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(importNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }

            //
            //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
            //					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
            function cloneNode(doc, node, deep) {
                var node2 = new node.constructor();
                for (var n in node) {
                    var v = node[n];
                    if (typeof v != 'object') {
                        if (v != node2[n]) {
                            node2[n] = v;
                        }
                    }
                }
                if (node.childNodes) {
                    node2.childNodes = new NodeList();
                }
                node2.ownerDocument = doc;
                switch (node2.nodeType) {
                    case ELEMENT_NODE:
                        var attrs = node.attributes;
                        var attrs2 = node2.attributes = new NamedNodeMap();
                        var len = attrs.length
                        attrs2._ownerElement = node2;
                        for (var i = 0; i < len; i++) {
                            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                        }
                        break;
                        ;
                    case ATTRIBUTE_NODE:
                        deep = true;
                }
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(cloneNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }

            function __set__(object, key, value) {
                object[key] = value
            }

            //do dynamic
            try {
                if (Object.defineProperty) {
                    Object.defineProperty(LiveNodeList.prototype, 'length', {
                        get: function () {
                            _updateLiveList(this);
                            return this.$$length;
                        }
                    });
                    Object.defineProperty(Node.prototype, 'textContent', {
                        get: function () {
                            return getTextContent(this);
                        },
                        set: function (data) {
                            switch (this.nodeType) {
                                case 1:
                                case 11:
                                    while (this.firstChild) {
                                        this.removeChild(this.firstChild);
                                    }
                                    if (data || String(data)) {
                                        this.appendChild(this.ownerDocument.createTextNode(data));
                                    }
                                    break;
                                default:
                                    //TODO:
                                    this.data = data;
                                    this.value = value;
                                    this.nodeValue = data;
                            }
                        }
                    })

                    function getTextContent(node) {
                        switch (node.nodeType) {
                            case 1:
                            case 11:
                                var buf = [];
                                node = node.firstChild;
                                while (node) {
                                    if (node.nodeType !== 7 && node.nodeType !== 8) {
                                        buf.push(getTextContent(node));
                                    }
                                    node = node.nextSibling;
                                }
                                return buf.join('');
                            default:
                                return node.nodeValue;
                        }
                    }

                    __set__ = function (object, key, value) {
                        //console.log(value)
                        object['$$' + key] = value
                    }
                }
            } catch (e) { //ie8
            }

            if (typeof require == 'function') {
                exports.DOMImplementation = DOMImplementation;
                exports.XMLSerializer = XMLSerializer;
            }

        }())

        var DOMImplementation = exports.DOMImplementation;
        var XMLSerializer = exports.XMLSerializer;

        (function () {

            /*!
             @preserve
             xmldom (ported from node.js)
             https://github.com/jindw/xmldom/blob/master/LICENSE
             The MIT License (MIT)

             Copyright (c) <year> <copyright holders>

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated documentation files (the "Software"), to deal
             in the Software without restriction, including without limitation the rights
             to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             copies of the Software, and to permit persons to whom the Software is
             furnished to do so, subject to the following conditions:

             The above copyright notice and this permission notice shall be included in
             all copies or substantial portions of the Software.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            function DOMParser(options) {
                this.options = options || {
                        locator: {}
                    };

            }

            DOMParser.prototype.parseFromString = function (source, mimeType) {
                var options = this.options;
                var sax = new XMLReader();
                var domBuilder = options.domBuilder || new DOMHandler(); //contentHandler and LexicalHandler
                var errorHandler = options.errorHandler;
                var locator = options.locator;
                var defaultNSMap = options.xmlns || {};
                var entityMap = {
                    'lt': '<',
                    'gt': '>',
                    'amp': '&',
                    'quot': '"',
                    'apos': "'"
                }
                if (locator) {
                    domBuilder.setDocumentLocator(locator)
                }

                sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
                sax.domBuilder = options.domBuilder || domBuilder;
                if (/\/x?html?$/.test(mimeType)) {
                    entityMap.nbsp = '\xa0';
                    entityMap.copy = '\xa9';
                    defaultNSMap[''] = 'http://www.w3.org/1999/xhtml';
                }
                if (source) {
                    sax.parse(source, defaultNSMap, entityMap);
                } else {
                    sax.errorHandler.error("invalid document source");
                }
                return domBuilder.document;
            }

            function buildErrorHandler(errorImpl, domBuilder, locator) {
                if (!errorImpl) {
                    if (domBuilder instanceof DOMHandler) {
                        return domBuilder;
                    }
                    errorImpl = domBuilder;
                }
                var errorHandler = {}
                var isCallback = errorImpl instanceof Function;
                locator = locator || {}

                function build(key) {
                    var fn = errorImpl[key];
                    if (!fn) {
                        if (isCallback) {
                            fn = errorImpl.length == 2 ? function (msg) {
                                errorImpl(key, msg)
                            } : errorImpl;
                        } else {
                            var i = arguments.length;
                            while (--i) {
                                if (fn = errorImpl[arguments[i]]) {
                                    break;
                                }
                            }
                        }
                    }
                    errorHandler[key] = fn && function (msg) {
                            fn(msg + _locator(locator));
                        } || function () {
                        };
                }

                build('warning', 'warn');
                build('error', 'warn', 'warning');
                build('fatalError', 'warn', 'warning', 'error');
                return errorHandler;
            }

            /**
             * +ContentHandler+ErrorHandler
             * +LexicalHandler+EntityResolver2
             * -DeclHandler-DTDHandler
             *
             * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
             * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
             * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
             */
            function DOMHandler() {
                this.cdata = false;
            }

            function position(locator, node) {
                node.lineNumber = locator.lineNumber;
                node.columnNumber = locator.columnNumber;
            }

            /**
             * @see org.xml.sax.ContentHandler#startDocument
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
             */
            DOMHandler.prototype = {
                startDocument: function () {
                    this.document = new DOMImplementation().createDocument(null, null, null);
                    if (this.locator) {
                        this.document.documentURI = this.locator.systemId;
                    }
                },
                startElement: function (namespaceURI, localName, qName, attrs) {
                    var doc = this.document;
                    var el = doc.createElementNS(namespaceURI, qName || localName);
                    var len = attrs.length;
                    appendElement(this, el);
                    this.currentElement = el;

                    this.locator && position(this.locator, el)
                    for (var i = 0; i < len; i++) {
                        var namespaceURI = attrs.getURI(i);
                        var value = attrs.getValue(i);
                        var qName = attrs.getQName(i);
                        var attr = doc.createAttributeNS(namespaceURI, qName);
                        if (attr.getOffset) {
                            position(attr.getOffset(1), attr)
                        }
                        attr.value = attr.nodeValue = value;
                        el.setAttributeNode(attr)
                    }
                },
                endElement: function (namespaceURI, localName, qName) {
                    var current = this.currentElement
                    var tagName = current.tagName;
                    this.currentElement = current.parentNode;
                },
                startPrefixMapping: function (prefix, uri) {
                },
                endPrefixMapping: function (prefix) {
                },
                processingInstruction: function (target, data) {
                    var ins = this.document.createProcessingInstruction(target, data);
                    this.locator && position(this.locator, ins)
                    appendElement(this, ins);
                },
                ignorableWhitespace: function (ch, start, length) {
                },
                characters: function (chars, start, length) {
                    chars = _toString.apply(this, arguments)
                    //console.log(chars)
                    if (this.currentElement && chars) {
                        if (this.cdata) {
                            var charNode = this.document.createCDATASection(chars);
                            this.currentElement.appendChild(charNode);
                        } else {
                            var charNode = this.document.createTextNode(chars);
                            this.currentElement.appendChild(charNode);
                        }
                        this.locator && position(this.locator, charNode)
                    }
                },
                skippedEntity: function (name) {
                },
                endDocument: function () {
                    this.document.normalize();
                },
                setDocumentLocator: function (locator) {
                    if (this.locator = locator) { // && !('lineNumber' in locator)){
                        locator.lineNumber = 0;
                    }
                },
                //LexicalHandler
                comment: function (chars, start, length) {
                    chars = _toString.apply(this, arguments)
                    var comm = this.document.createComment(chars);
                    this.locator && position(this.locator, comm)
                    appendElement(this, comm);
                },

                startCDATA: function () {
                    //used in characters() methods
                    this.cdata = true;
                },
                endCDATA: function () {
                    this.cdata = false;
                },

                startDTD: function (name, publicId, systemId) {
                    var impl = this.document.implementation;
                    if (impl && impl.createDocumentType) {
                        var dt = impl.createDocumentType(name, publicId, systemId);
                        this.locator && position(this.locator, dt)
                        appendElement(this, dt);
                    }
                },
                /**
                 * @see org.xml.sax.ErrorHandler
                 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
                 */
                warning: function (error) {
                    try {
                        console.warn(error, _locator(this.locator));
                    } catch (e) {
                    }
                },
                error: function (error) {
                    try {
                        console.error(error, _locator(this.locator));
                    } catch (e) {
                    }
                },
                fatalError: function (error) {
                    try {
                        console.error(error, _locator(this.locator));
                    } catch (e) {
                    }
                    throw error;
                }
            }

            function _locator(l) {
                if (l) {
                    return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']'
                }
            }

            function _toString(chars, start, length) {
                if (typeof chars == 'string') {
                    return chars.substr(start, length)
                } else { //java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
                    if (chars.length >= start + length || start) {
                        return new java.lang.String(chars, start, length) + '';
                    }
                    return chars;
                }
            }

            /*
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
             * used method of org.xml.sax.ext.LexicalHandler:
             *  #comment(chars, start, length)
             *  #startCDATA()
             *  #endCDATA()
             *  #startDTD(name, publicId, systemId)
             *
             *
             * IGNORED method of org.xml.sax.ext.LexicalHandler:
             *  #endDTD()
             *  #startEntity(name)
             *  #endEntity(name)
             *
             *
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
             * IGNORED method of org.xml.sax.ext.DeclHandler
             * 	#attributeDecl(eName, aName, type, mode, value)
             *  #elementDecl(name, model)
             *  #externalEntityDecl(name, publicId, systemId)
             *  #internalEntityDecl(name, value)
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
             * IGNORED method of org.xml.sax.EntityResolver2
             *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
             *  #resolveEntity(publicId, systemId)
             *  #getExternalSubset(name, baseURI)
             * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
             * IGNORED method of org.xml.sax.DTDHandler
             *  #notationDecl(name, publicId, systemId) {};
             *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
             */
            "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
                DOMHandler.prototype[key] = function () {
                    return null
                }
            })

            /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
            function appendElement(hander, node) {
                if (!hander.currentElement) {
                    hander.document.appendChild(node);
                } else {
                    hander.currentElement.appendChild(node);
                }
            } //appendChild and setAttributeNS are preformance key

            if (typeof require == 'function') {
                //var XMLReader = require('sax').XMLReader;
                //var DOMImplementation = exports.DOMImplementation = require('dom').DOMImplementation;
                //exports.XMLSerializer = require('dom').XMLSerializer;
                exports.DOMParser = DOMParser;
            }

        }())

        var DOMParser = exports.DOMParser;

    }(exp))

    adfw.DOMParser = exp.DOMParser;
    adfw.XMLSerializer = exp.XMLSerializer;
    adfw.DOMImplementation = exp.DOMImplementation;
    adfw.XMLReader = exp.XMLReader;

    //print('DOMParser: ' + DOMParser);
}
else {
    adfw.DOMParser = DOMParser;
    adfw.XMLSerializer = XMLSerializer;
    if (typeof console !== "undefined" && typeof console.log === "function") {
        //console.log("Using native DOMParser implementation...");

    }
}
/*!
 * @preserve
 * Samsung Ad Framework
 * This software may be used only on Samsung Smart-TVs. It may not be reverse-engineered, unminified, forked, modified, sold or used in any platform other than Samsung Smart-TVs.
 *
 */
//The Config is where all configuration parameters of the Ad Framework are stored and set.
adfw.Config = (function () {
    "use strict";
    var Obj = function (options) {
        this.configuration = {};
        this.setDefaults();
    };

    //Enum for behavior if resuming playback at a specific point of the content.
    Obj.prototype.RESUME_ADBREAK_BEHAVIOR = {
        PLAY_ONE: "PLAY_ONE",
        PLAY_ALL: "PLAY_ALL",
        PLAY_NONE: "PLAY_NONE",
    };

    //Enum for behavior if RW is used to go back before the trigger point of midrolls. Should we replay?
    Obj.prototype.RW_MIDROLL_BEHAVIOR = {
        RESTORE_ONE: "RESTORE_ONE",
        RESTORE_ALL: "RESTORE_ALL",
        RESTORE_NONE: "RESTORE_NONE"
    };

    //Enum for behavior if FF is used to go past several midrolls. Should we play first, last, all, or none?
    Obj.prototype.FF_MIDROLL_BEHAVIOR = {
        PLAY_ONE: "PLAY_ONE",
        PLAY_ALL: "PLAY_ALL",
        PLAY_NONE: "PLAY_NONE"
    };

    //Enum for the position of the Visual Overlay - the SkipUI and NonLinearUI.
    Obj.prototype.OVERLAY_POSITION = {
        TOP_LEFT: "TOP_LEFT",
        TOP_RIGHT: "TOP_RIGHT",
        BOTTOM_LEFT: "BOTTOM_LEFT",
        BOTTOM_RIGHT: "BOTTOM_RIGHT",
        DISABLED: "DISABLED"
    };

    //This configuration is loaded upon initialization of the Config.
    Obj.prototype._standardConfiguration = {

        /*
         MAX_VAST_WRAPPER_DEPTH (Depth|Integer)
         Maximum wrapper depth that the parser will try before giving up as a "no ad".
         */
        MAX_VAST_WRAPPER_DEPTH: 5,

        /*
         ADBREAK_LAZY_LOAD (Boolean)
         If true, then the ad framework will wait until AD_RETRIEVAL_TIMEOUT + AD_PREBUFFER_ADVANCE_TIME before resolving VMAP <AdTagURI> VAST Urls.
         Setting this to TRUE will make it easier for ad servers to keep track of VAST calls since they won't come at once - rather, they'll happen on an as-needed basis.
         Setting this to FALSE will load all VAST tags at the same time VMAP is parsed.
         */
        ADBREAK_LAZY_LOAD: true,

        /*
         AD_RETRIEVAL_TIMEOUT (Milliseconds|Integer)
         The maximum time the XML parser will wait for ad requests to resolve, before giving up as a "no ad".
         */
        AD_RETRIEVAL_TIMEOUT: 7000,

        /*
         AJAX_TIMEOUT (Milliseconds|Integer)
         The maximum time to wait for any one AJAX call.
         */
        AJAX_TIMEOUT: 10000,

        /*
         PLAY_ALL_ADS (Boolean)
         TRUE: All ads in the adbreak will play, no matter what. Overrides MAXIMUM_ADBREAK_DURATION.
         FALSE (w/ ad pod): Plays the ad pod in the break (if duration permits), and then ends the ad break
         FALSE (no ad pod): Tries to keep the duration of the adbreak around or less than the target adbreak duration.
         */
        PLAY_ALL_ADS: true,

        /*
         TARGET_ADBREAK_DURATION (Milliseconds|Integer)
         Applies only if PLAY_ALL_ADS is false. Applies only to ad buffets (ad pods override this option).
         The player will play ads from the buffet until this approximate duration has been reached.
         It allows some squish time, adbreaks may go over, or go under this number.
         */
        TARGET_ADBREAK_DURATION: 120 * 1000,

        /*
         MAXIMUM_ADBREAK_DURATION (Milliseconds|Integer)
         The player will play ads from the adbreak, stopping before this maximum duration has been reached.
         Applies only if PLAY_ALL_ADS is false. This option will apply even to ad pods, cutting leaving off ads from the pod if necessary.
         Please note that this option calculates the duration by the time reported in the VAST, so it may not accurately reflect buffering time or encoding variance.
         */
        MAXIMUM_ADBREAK_DURATION: 240 * 1000,

        /*
         AGGRESSIVE_DURATION_ENFORCEMENT (Milliseconds|Integer)
         This option influences MAXIMUM_ADBREAK_DURATION.
         Instead of relying on the reported ad durations in the VAST, it uses an internal timer.
         This internal timer will cut off the adbreak (even if an ad is in progress) after MAXIMUM_ADBREAK_DURATION has been reached.
         Useful if you are playing a live stream and absolutely need to resume at the right time, or are dealing with inaccurate duration reports in VAST.
         */
        AGGRESSIVE_DURATION_ENFORCEMENT: false,

        /*
         AGGRESSIVE_DURATION_ENFORCEMENT_CUSHION (Milliseconds|Integer)
         The maximum amount of time an adbreak is allowed to go over the MAXIMUM_ADBREAK_DURATION allotment before it is cut off prematurely.
         */
        AGGRESSIVE_DURATION_ENFORCEMENT_CUSHION: 1000,

        /*
         RESUME_ADBREAK_BEHAVIOR (adfw.Config.RESUME_ADBREAK_BEHAVIOR)
         Defines the behavior if the playback is resumed from a specific point of the content, and VMAP has been loaded.
         PLAY_ONE	: Plays one of the adbreaks that was scheduled. Skips all others. No guarantee is possible on which midroll is played.
         PLAY_ALL	: Plays all adbreaks. Not really recommended because it could impact user experience.
         PLAY_NONE	: Plays none of the adbreaks.
         */
        RESUME_ADBREAK_BEHAVIOR: Obj.prototype.RESUME_ADBREAK_BEHAVIOR.PLAY_NONE,

        /*
         RESUME_ADBREAK_BEHAVIOR_SKIPS_PREROLLS_TOO (Boolean)
         Describes whether RESUME_ADBREAK_BEHAVIOR applies to prerolls too (if false, only applies to midrolls)
         */
        RESUME_ADBREAK_BEHAVIOR_SKIPS_PREROLLS_TOO: true,

        /*
         FF_MIDROLL_BEHAVIOR (adfw.Config.FF_MIDROLL_BEHAVIOR)
         Defines the behavior if the user fast forwards past the trigger points of multiple midrolls.
         PLAY_ONE	: Plays one of the midrolls that was scheduled. Skips all others. No guarantee is possible on which midroll is played.
         PLAY_ALL	: Plays all midrolls. Not really recommended because it could impact user experience.
         PLAY_NONE	: Plays none of the midrolls. Not really recommended because the user could simply FF past the midroll to skip it.
         */
        FF_MIDROLL_BEHAVIOR: Obj.prototype.FF_MIDROLL_BEHAVIOR.PLAY_ONE,

        /*
         RW_MIDROLL_BEHAVIOR (adfw.Config.RW_MIDROLL_BEHAVIOR)
         Defines the behavior if the user rewinds past the trigger points of multiple midrolls.
         RESTORE_ONE	: Restores one previously played midroll. No guarantee is possible on which midroll is played.
         RESTORE_ALL	: Restores all previously played midrolls.
         RESTORE_NONE	: Restores none of the midrolls.
         */
        RW_MIDROLL_BEHAVIOR: Obj.prototype.RW_MIDROLL_BEHAVIOR.RESTORE_NONE,

        /*
         REWIND_BEFORE_RESUME (Seconds|Integer)
         When ending an adbreak and resuming the content, rewind this many seconds
         */
        REWIND_BEFORE_RESUME: 0,

        /*
         PREBUFFER_ENABLED (Boolean)
         If the current platform supports prebuffering, should prebuffering be attempted?
         */
        PREBUFFER_ENABLED: true,

        /*
         CONTENT_PREBUFFER_ADVANCE_TIME (Milliseconds|Integer)
         While playing the content, start prebuffering ads X milliseconds before the ad starts
         */
        CONTENT_PREBUFFER_ADVANCE_TIME: 15000,

        /*
         AD_PREBUFFER_ADVANCE_TIME (Milliseconds|Integer)
         When playing linear ads, start buffering the next ad or the content X milliseconds before the ad ends
         */
        AD_PREBUFFER_ADVANCE_TIME: 10000,

        /*
         OVERLAY_POSITION (adfw.Config.OVERLAY_POSITION)
         Specifies the position of the visual overlay (NonLinear ads and skip buttons for skippable linear ads)
         TOP_LEFT: Displays the visual overlay on the top left of the video frame.
         TOP_RIGHT: Displays the visual overlay on the top right of the video frame.
         BOTTOM_LEFT: Displays the visual overlay on the bottom left of the video frame.
         BOTTOM_RIGHT: Displays the visual overlay on the bottom right of the video frame.
         DISABLED: No visual overlay will display on screen.
         */
        OVERLAY_POSITION: Obj.prototype.OVERLAY_POSITION.BOTTOM_RIGHT,

        /*
         ICONS_ENABLED (Boolean)
         Specifies whether the display of icons shall be automatic.
         */
        ICONS_ENABLED: false,

        /*
         NONLINEAR_ADS_ENABLED (Boolean)
         Specifies whether the display of nonlinear ads shall be allowed.
         */
        NONLINEAR_ADS_ENABLED: true,

        /*
         NONLINEAR_DEFAULT_DISPLAY_TIME (Milliseconds|Integer)
         Target time to display a NonLinear ad if there is no minSuggestedDuration
         */
        NONLINEAR_DEFAULT_DISPLAY_TIME: 15000,

        /*
         NONLINEAR_MAXIMUM_DISPLAY_TIME (Milliseconds|Integer)
         Maximum time to display a NonLinear ad regardless of its minSuggestedDuration
         */
        NONLINEAR_MAXIMUM_DISPLAY_TIME: 60000,

        /*
         NONLINEAR_MAXIMUM_VIDEO_COVERAGE_RATIO (Ratio|Fraction of One)
         Maximum height of screen to cover with NonLinear ad before the framework scales the ad down.
         Ads will be rejected if they do not have a resource that can display lower than this ratio.
         Scaling only applies if the NonLinear ad specifies that it is scalable.
         */
        NONLINEAR_MAXIMUM_VIDEO_COVERAGE_RATIO: 0.15,

        /*
         NONLINEAR_TARGET_VIDEO_COVERAGE_RATIO (Ratio|Fraction of One)
         Target height of screen to cover with NonLinear ad.
         Applies during the selection of a NonLinear resource (does not affect scaling)
         */
        NONLINEAR_TARGET_VIDEO_COVERAGE_RATIO: 0.10,

        /*
         NONLINEAR_MINIMUM_VIDEO_COVERAGE_RATIO (Ratio|Fraction of One)
         Minimum height of screen to cover with NonLinear ad before the framework scales the ad up.
         Only applies if the NonLinear ad specifies that it is scalable.
         */
        NONLINEAR_MINIMUM_VIDEO_COVERAGE_RATIO: 0.05,

        /*
         NONLINEAR_RESOURCE_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for NonLinear Ad resources to load before timing them out.
         */
        NONLINEAR_RESOURCE_TIMEOUT: 5000,

        /*
         BUFFERED_RESOURCE_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for Buffered resources to start playback before timing them out.
         Use this as a failsafe device to prevent video from getting stuck due to weird glitches in the SEF player.
         Set to 0 to disable.
         */
        BUFFERED_RESOURCE_TIMEOUT: 25000,

        /*
         LINEAR_RESOURCE_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for Linear Ad resources to start playback or report buffering progress before timing them out.
         If a LINEAR_RESOURCE_TIMEOUT has occurred within the last 60 seconds, this value will automatically be reduced to LINEAR_RESOURCE_REPEAT_TIMEOUT.
         Set to 0 to disable.
         */
        LINEAR_RESOURCE_TIMEOUT: 30000,

        /*
         LINEAR_RESOURCE_REPEAT_TIMEOUT (Milliseconds|Integer)
         Only used if a LINEAR_RESOURCE_TIMEOUT has occurred within the last 60 seconds.
         Length of time that the ad framework will wait for Linear Ad resources to start playback or report buffering progress before timing them out.
         */
        LINEAR_RESOURCE_REPEAT_TIMEOUT: 10000,

        /*
         COMPANION_AD_ENABLE (Boolean)
         The ad framework will stop handling all COMPANION Ad if set to false.
         */
        COMPANION_AD_ENABLE: true,

        /*
         VPAID_ENABLE (Boolean)
         The ad framework will stop handling all VPAID Ad if set to false.
         */
        VPAID_ENABLE: true,

        /*
         VPAID_DEFAULT_LOAD_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for a VPAID ad to start before timing them out.
         */
        VPAID_DEFAULT_LOAD_TIMEOUT: 10000,

        /*
         VPAID_DEFAULT_START_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for a VPAID ad unit to send back AdStarted event after calling startAd() before timing them ou
         */
        VPAID_DEFAULT_START_TIMEOUT: 10000,

        /*
         VPAID_DEFAULT_STOP_TIMEOUT (Milliseconds|Integer)
         Length of time that the ad framework will wait for a VPAID ad unit to send back AdStopped event after calling stopAd() before timing them out.
         */
        VPAID_DEFAULT_STOP_TIMEOUT: 10000,

        /*
         VPAID_DEFAULT_ADLINEARCHANGE_TIMEOUT (Milliseconds|Integer)
         Receiving AdLinearChange event with adLinear set to true but never receiving AdLinearChange event with adLinear set to false (excluding ad pause/resume time) will need to trigger an error.
         Length of time cushion to allow a NonLinear click-to-linear ad to play before killing it.
         The ad framework will allow for the reported duration of the linear ad, plus the time cushion.

         */
        VPAID_DEFAULT_ADLINEAR_TIMEOUT: 10000,

        /*
         PLAYBACK_FAILURE_RETRY_COUNT (Count|Integer)
         Number of times the ad framework will attempt to recover from a playback failure before giving up.
         The failure count resets after 60 seconds of no further reported errors.
         */
        PLAYBACK_FAILURE_RETRY_COUNT: 0,

        /*
         PLAYBACK_FAILURE_RETRY_DELAY (Milliseconds|Integer)
         Number of times the ad framework will attempt to recover from a Content playback failure before giving up.
         The failure count resets after 60 seconds of no further reported errors.
         */
        PLAYBACK_FAILURE_RETRY_DELAY: 1000,

        /*
         START_BITRATE (Bits Per Second|Integer) OR "AUTO"
         The ad framework will attempt to start all streaming ads at the specified bitrate.
         Upon clicking the video, the proper tracking events will be fired, and an iFrame opened to the ad's clickthrough website.
         Set to 0 to disable.
         */
        START_BITRATE: "AUTO",

        /*
         START_BITRATE_AUTO_RATIO (Ratio|Fraction of One)
         If START_BITRATE is set to "AUTO", then the framework will begin buffering the next ad at the bitrate of the currently streaming video, multiplied by this ratio.
         */
        START_BITRATE_AUTO_RATIO: 0.9,

        /*
         DISABLE_AD_INSERTION (Boolean)
         The ad framework will stop all adbreak triggering for the time being.
         All adbreaks that would have been triggered while this setting is true will be skipped.
         Useful during EAS messages.
         */
        DISABLE_AD_INSERTION: false,

        /*
         MIDROLL_TRIM_LIMIT (Integer)
         The ad framework will start removing already-played midrolls from the midroll list if the midrolls length is over this limit.
         */
        MIDROLL_TRIM_LIMIT: 20,

        /*
         ADAPTIVE_CONTENT (Boolean)
         If set to true, the framework will assume the given content is of an adaptive streaming enabled protocol (HLS, DASH, Smooth).
         The framework will prebuffer content based on the adaptive streaming algorithm (instead of starting at the lowest possible bitrate each time).
         WARNING: If this option is enabled for progressive content (i.e. MP4 files), it may cause playback errors.
         */
        ADAPTIVE_CONTENT: false,

        /*
         PRIORITIZE_ADAPTIVE_ADS (Boolean)
         If set to true, the framework will prioritize adaptive streaming mediafiles instead of progressive mediafiles. If false, then the framework will prefer progressive ads when possible.
         */
        PRIORITIZE_ADAPTIVE_ADS: true,

        /*
         DISABLE_TRACKING_EVENTS (Boolean)
         If set to true, no VAST/VMAP tracking events will be sent. Useful only for development purposes!
         */
        DISABLE_TRACKING_EVENTS: false,

        /*
         DEBUG_CONSOLE_LOGS
         and
         DEBUG_ALERTS (Boolean)
         If set to true, logs will be output via the related medium.
         */
        DEBUG_CONSOLE_LOGS: true,
        DEBUG_ALERTS: false,

        /*
         DEBUG_ENABLE_ILLEGAL_AD_SKIP
         If set to true, you can press FF to skip linear ads even if they're not skippable.
         */
        DEBUG_ENABLE_ILLEGAL_AD_SKIP: false,
    };

    /*
     * Sets configuration values. Can be used in 2 ways:
     * 	set(KEY, VALUE)
     * or
     * 	set({
     * 		KEY1: VALUE1,
     * 		KEY2: VALUE2
     * 	})
     */
    Obj.prototype.set = function (params, params2) {

        if (typeof params === "string" && adfw.Config._standardConfiguration.hasOwnProperty(params) && typeof params2 !== "undefined" && isFinite(params2)) {
            this.configuration[params] = params2;
            //adfw.Events.dispatchEvent("DEBUG_MESSAGE", { message: "[CONFIG] " + typeof(params) + " Set: " + params + "=" + params2});
        } else if(typeof params === "object" && typeof params2 === "undefined"){
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    this.configuration[key] = params[key];
                    //adfw.Events.dispatchEvent("DEBUG_MESSAGE", { message: "[CONFIG] " + typeof(params) + " Set: " + key + "=" + params[key]});
                }else{
                    throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");
                    //return;
                }
            }
        }else{
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");
            //return;
        }
    };

    //Gets a configuration value based on its String key.
    Obj.prototype.get = function (key) {
        if(this.configuration[key] == undefined){
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");
            //return;
        }
        return this.configuration[key];
    };

    //Returns all config values to defaults
    Obj.prototype.setDefaults = function () {
        this.set(this._standardConfiguration);
    };

    return new Obj();
})();
//Generic event dispatcher that allows listen(eventName, function, runOnce), dispatch(eventName, params), and remove(eventName, function).
adfw.GenericEventDispatcher = (function () {
    var Obj = function () {
        this._eventMap = {};
    };

    //Listens for the 'key' (event) using the specified function. If runOnce is true, the function will be removed upon first execution.
    Obj.prototype.addListener = function (key, func, runOnce) {
        if (typeof func !== "function" || !key) {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"missing function or key: " + key + " | " + func);
        }
        var isValidEventName = false;
        if (this.getAdapterType)
            isValidEventName = adfw.PlayerAdapter.Events.hasOwnProperty(key);
        else
            isValidEventName = adfw.Events.hasOwnProperty(key);

        if (!isValidEventName) {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"key: " + key + " is not valid event name");
        }
        if (!this._eventMap.hasOwnProperty(key)) {
            this._eventMap[key] = [];
        }

        runOnce = (runOnce === true) ? true : false;
        var handler = {
            func: func,
            runOnce: runOnce
        };
        this._eventMap[key].push(handler);
    };

    //Removes a function from the listeners map. If no event name is given, the function is removed from all listener maps.
    Obj.prototype.removeListener = function (event, funcToRemove) {
        try {

            var currentFunc = null;

            if (typeof event === "undefined" ) {
                throw new adfw.Utils.WebAPIExceptionForAdfw ('TYPE_MISMATCH_ERR', "EventDispatcher.removeListener() called with empty argument list");
            }
            else if (typeof funcToRemove === "undefined" && typeof event === "string") {
                this._eventMap[event] = [];
            }
            else if (typeof funcToRemove === "undefined" && typeof event === "function") {
                funcToRemove = event;
                for (var eventList in this._eventMap) {
                    if (this._eventMap.hasOwnProperty(eventList)) {
                        for (var i = 0; i < this._eventMap[eventList].length; i++) {
                            currentFunc = this._eventMap[eventList][i].func;
                            if (funcToRemove === currentFunc) {
                                this._eventMap[eventList].splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            } else if (typeof funcToRemove === "function" && typeof event === "string") {
                //Remove function from one list ("event")
                for (var x = 0; x < this._eventMap[event].length; x++) {
                    currentFunc = this._eventMap[event][x].func;
                    if (funcToRemove === currentFunc) {
                        this._eventMap[event].splice(x, 1);
                        break;
                    }
                }
            } else{
                throw new adfw.Utils.WebAPIExceptionForAdfw ('TYPE_MISMATCH_ERR', "EventDispatcher.removeListener() called with wrong event type or function type");
            }
        } catch (e) {
            throw  new adfw.Utils.WebAPIExceptionForAdfw ('TYPE_MISMATCH_ERR', "EventDispatcher.removeListener() exception: " + e);
        }
    };

    //Dispatches an event with an optional param map to all listening functions.
    Obj.prototype.dispatchEvent = function (event, params) {
        //console.log('RORS:dispatchEvent:', event, params);
        if (typeof event === "undefined" || !event) {
            throw "Attempted to throw invalid event: " + event;
        }
        params = params || {};
        if (this._eventMap.hasOwnProperty(event)) {
            var executeList = [];
            var removeList = [];
            var errorList = [];
            var x;
            for (var i = 0; i < this._eventMap[event].length; i++) {
                var currentFunc = this._eventMap[event][i].func;
                if (this._eventMap[event][i].runOnce) {
                    removeList.push(currentFunc);
                }
                executeList.push(currentFunc);
            }
            for (x = 0; x < executeList.length; x++) {
                var currentFunc = executeList[x];
                try {
                    currentFunc.call(this, event, params);
                }
                catch (e) {
                    try {
                        var msg = "Event Dispatcher caught an exception: " + e;// + "\n" + "Event Dispatcher will delete this function: " + currentFunc;
                        if (typeof(console) !== "undefined" && typeof(console.log) === "function") {
                            console.log(msg);
                        }
                        else if (typeof(print) === "function") {
                            print(msg);
                        }
                    }
                    catch (e) {
                    }
                    errorList.push(currentFunc);
                }
            }
            for (x = 0; x < removeList.length; x++) {
                this.removeListener(event, removeList[x]);
            }
            for (x = 0; x < errorList.length; x++) {
                try {
                    //this.remove(event, errorList[x]);
                }
                catch (e) {
                }
            }
        }
    };

    //Deletes all listeners.
    Obj.prototype.reset = function () {
        try {
            for (var key in this._eventMap) {
                if (this._eventMap.hasOwnProperty(key)) {
                    delete this._eventMap[key];
                }
            }
        } catch (e) {
        }
        this._eventMap = {};
    };
    return Obj;
}());

//An implementation of GenericEventDispatcher that includes a map of event types.
adfw.Events = new adfw.GenericEventDispatcher();
(function () {
    var events = {

        PLAYBACK_TIME: "PLAYBACK_TIME", // ms:Integer
        AD_PLAYBACK_TIME: "AD_PLAYBACK_TIME", // ms:Integer, secondsUntilSkippable:Integer
        CONTENT_PLAYBACK_TIME: "CONTENT_PLAYBACK_TIME", // ms:Integer

        ADBREAK_INSERTION_SUCCESS: "ADBREAK_INSERTION_SUCCESS", // message:String
        ADBREAK_INSERTION_FAILURE: "ADBREAK_INSERTION_FAILURE", // message:String

        PLAYBACK_COMPLETE: "PLAYBACK_COMPLETE",

        LINEAR_AD_PREBUFFER_START: "LINEAR_AD_PREBUFFER_START", // adObject: Ad, title: String, description: String, advertiser: String, skippable: boolean, apiFramework: String , url: String, icons: Array
        LINEAR_AD_START: "LINEAR_AD_START", // adObject: Ad, title: String, description: String, advertiser: String, skippable: boolean, apiFramework: String , url: String, icons: Array
        LINEAR_AD_END: "LINEAR_AD_END", //Linear ad has ended (but not necessarily run to completion)
        LINEAR_AD_COMPLETE: "LINEAR_AD_COMPLETE", //Linear ad has played all the way through

        NONLINEAR_AD_START: "NONLINEAR_AD_START",
        NONLINEAR_AD_END: "NONLINEAR_AD_END",

        ADBREAK_START: "ADBREAK_START", //triggerTime: Milliseconds, isLinear: Boolean, extensions, globalExtensions, adbreak: AdBreak, linearDuration: Number, linearAdCount: Number
        ADBREAK_END: "ADBREAK_END",

        CONTENT_PREBUFFER_START: "CONTENT_PREBUFFER_START", // ms:Integer, url:String
        CONTENT_SUSPEND: "CONTENT_SUSPEND", // ms:Integer, url:String
        CONTENT_START: "CONTENT_START", // ms:Integer, url:String
        CONTENT_INIT_COMPLETE: "CONTENT_INIT_COMPLETE",
		
        IFRAME_OPEN: "IFRAME_OPEN", // src: String
        IFRAME_CLOSE: "IFRAME_CLOSE",

        TRACKING_EVENT: "TRACKING_EVENT", // event:String, url:String
        ERROR_TRACKER: "ERROR_TRACKER", // code:Integer, message:String, url:String

        COMPANION_ADS_CREATIVE_DETECTED: "COMPANION_ADS_CREATIVE_DETECTED",
        COMPANION_AD_FAILED_REQUIRED_ALL: "COMPANION_AD_FAILED_REQUIRED_ALL",
        COMPANION_AD_FAILED_REQUIRED_ANY: "COMPANION_AD_FAILED_REQUIRED_ANY",
        COMPANION_AD_START: "COMPANION_AD_START",

        VPAID_COMPLETE: "VPAID_COMPLETE",
        VPAID_LINEARITY_CHANGE: "VPAID_LINEARITY_CHANGE", // isLinear:Boolean, wrapper:VPAIDWrapper

        VPAID_ERROR: "VPAID_ERROR", // message:String
        VPAID_LINEAR_PLAYBACK_TIME: "VPAID_LINEAR_PLAYBACK_TIME",

        PARSING_ERROR: "PARSING_ERROR", // code:Integer, message:String
        UNRECOVERABLE_PLAYBACK_ERROR: "UNRECOVERABLE_PLAYBACK_ERROR", // type:String, code:String, url:String, message:String
        RECOVERABLE_PLAYBACK_ERROR: "RECOVERABLE_PLAYBACK_ERROR", // type:String, code:String, url:String, message:String
        VSUITE_PLAYBACK_ERROR: "VSUITE_PLAYBACK_ERROR", // code:Integer, message:String, url:String, contentPlayhead: Integer

        SUBTITLE: "SUBTITLE", // duration:Integer, text:String, attributes:Array<AVPlaySubtitleAttribute>
        SPARSE_TRACK: "SPARSE_TRACK", // time:Integer, data:String, raw: String

        //player adapter specific events
        BUFFERING_START: "BUFFERING_START",   
        BUFFERING_PROGRESS: "BUFFERING_PROGRESS",
        BUFFERING_COMPLETE: "BUFFERING_COMPLETE",
        
        PREBUFFERING_BUFFERING_START: "PREBUFFERING_BUFFERING_START",
        PREBUFFERING_BUFFERING_PROGRESS: "PREBUFFERING_BUFFERING_PROGRESS",
        PREBUFFERING_BUFFERING_COMPLETE: "PREBUFFERING_BUFFERING_COMPLETE",

        //Debug stuff
        PLAYBACK_TYPE: "PLAYBACK_TYPE", // type:String
        DEBUG_MESSAGE: "DEBUG_MESSAGE", // message:String
        
        //To know  there is a valid tracking server
        RESPONSE_FROM_TRACKING_SERVER: "RESPONSE_FROM_TRACKING_SERVER",



    };
    for (var key in events) {
        if (events.hasOwnProperty(key)) {
            adfw.Events[key] = events[key];
        }
    }
}());

//"Macros" are templates used in the IAB tracking URIs. When encountered, the player must replace these macros with the appropriate information before submitting the request.
adfw.MacroHelper = (function () {
    var Obj = function () {
    };

    "use strict";

    Obj.prototype.Macros = {
        ERRORCODE: new RegExp("(\\[|%5B)ERROR_?CODE(\\]|%5D)", "ig"), //Replaced with one of the error code Enum values.
        //There's a discrepancy in the IAB spec of whether the ERRORCODE and ERRORMESSAGE have an underscore in it or not, so we account for both cases
        ERRORMESSAGE: new RegExp("(\\[|%5B)ERROR_?MESSAGE(\\]|%5D)", "ig"), //Replaced with an error message at the video player's discretion
        CONTENTPLAYHEAD: new RegExp("(\\[|%5B)CONTENTPLAYHEAD(\\]|%5D)", "ig"), //Replaced with the current time offset of the video content (not the ad). "HH:MM:SS.mmm"
        CACHEBUSTING: new RegExp("(\\[|%5B)CACHEBUSTING(\\]|%5D)", "ig"), //Replaced with a random 8 digit number, this forces the browser to request the tracking URI even if already cached.
        TIMESTAMP: new RegExp("(\\[|%5B)TIMESTAMP(\\]|%5D)", "ig"), //Replaced with standardized timestamp "YYYY-MM-DDTHH:MM:SS.mmm[-|+]##". "[-|+]##"" indicates timexzone offset, e.g.: +05 
        ASSETURI: new RegExp("(\\[|%5B)ASSETURI(\\]|%5D)", "ig"), //Replaced with the URI of the Ad asset being played.
    };

    //Replace all macros in an error Url with the errorcode, errormessage, and cachebuster
    Obj.prototype.replaceErrorMacros = function (uri, code, message, contentPlayhead, adAssetURI) {

        if (contentPlayhead) {
            contentPlayhead = adfw.Utils.convertMS(contentPlayhead);
            uri = uri.replace(this.Macros.CONTENTPLAYHEAD, encodeURIComponent(contentPlayhead));
        } else {
            uri = uri.replace(this.Macros.CONTENTPLAYHEAD, "UNDEFINED");
        }

        if (adAssetURI) {
            uri = uri.replace(this.Macros.ASSETURI, encodeURIComponent(adAssetURI));
        } else {
            uri = uri.replace(this.Macros.ASSETURI, "UNDEFINED");
        }
        if (typeof code === "string" || typeof code === "number") {
            uri = uri.replace(this.Macros.ERRORCODE, encodeURIComponent(code));
        } else {
            uri = uri.replace(this.Macros.ERRORCODE, encodeURIComponent("UNDEFINED"));
        }
        if (typeof message === "string") {
            uri = uri.replace(this.Macros.ERRORMESSAGE, encodeURIComponent(message));
        } else {
            uri = uri.replace(this.Macros.ERRORMESSAGE, encodeURIComponent("UNDEFINED"));
        }
        uri = uri.replace(this.Macros.CACHEBUSTING, encodeURIComponent(adfw.Utils.pad(Math.floor(Math.random() * (99999999 - 0 + 1) + 0), 8)));
        return uri;
    };


    // Replace all macros in a tracking Url with the contentPlayhead,
    // adAssetURI, and cachebuster
    Obj.prototype.replaceTrackingMacros = function (uri, contentPlayhead, adAssetURI) {

        if (contentPlayhead) {
            contentPlayhead = adfw.Utils.convertMS(contentPlayhead);
            uri = uri.replace(this.Macros.CONTENTPLAYHEAD, encodeURIComponent(contentPlayhead));
        } else {
            uri = uri.replace(this.Macros.CONTENTPLAYHEAD, "UNDEFINED");
        }

        if (adAssetURI) {
            uri = uri.replace(this.Macros.ASSETURI, encodeURIComponent(adAssetURI));
        } else {
            uri = uri.replace(this.Macros.ASSETURI, "UNDEFINED");
        }
        uri = uri.replace(this.Macros.CACHEBUSTING, encodeURIComponent(adfw.Utils.pad(Math.floor(Math.random() * (99999999 - 0 + 1) + 0), 8)));

        uri = uri.replace(this.Macros.TIMESTAMP, encodeURIComponent(adfw.Utils.iabTimestamp()));

        return uri;
    };

    return new Obj();
})();

//The Utils namespace is for storing common functions that are accessed by multiple other namespaces.
adfw.Utils = (function () {
    "use strict";

    //Stuff that's not public but we use internal to the utilities class
    var flatTimeOffsetRegex = /\s*(\d+):(\d+):(\d+):?\.?(\d+)?\s*/;

    //MIME type regexes
    var regexHLS = /(application\/x-mpegUrl\s*$)|(vnd\.apple\.mpegUrl\s*$)|(audio\/x-mpegurl\s*$)/i;
    var regexSmooth = /(vnd\.ms-sstr\+xml\s*$)/i;
    var regexDash = /(dash\+xml\s*$)/i;
    var regexXML = /(text\/xml\s*$)/i;
    var regexGIF = /(image\/gif\s*$)/i;
    var regexJPEG = /(image\/jpe?g\s*$)/i;
    var regexPNG = /(image\/png\s*$)/i;
    var regexJS = /(application\/x?-?javascript\s*$)/i;
    var regexAVI = /(video\/avi)/i;
    var regexMP4 = /(video\/mp4)/i;
    var regexFlash = /(application\/x?-?shockwave-flash\s*$)|(video\/x?-?flv\s*$)/i;

    var VOLT_USER_AGENT = "Samsung Smart TV (VOLT) AdSDK/0.1.0";

    var Obj = function () {
        this._startTime = new Date().getTime();
    };

    Obj.prototype.getStartTime = function () {
        return this._startTime;
    };

    Obj.prototype.getTotalRuntime = function () {
        var now = new Date();
        return now.getTime() - this._startTime;
    };

    Obj.prototype.log = function (str, prefix) {
        if (!prefix) {
            prefix = "[ADFW UTILS]";
        }
        str = prefix + " " + str;

        adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {
            message: str
        });

        if (typeof(window) !== "undefined" && typeof(console) === "object" && typeof(console.log) === "function") {
            if (adfw.Config.get("DEBUG_CONSOLE_LOGS") === true) {
		/*For printing calling line enable the below code after fixing issue*/
                /*var caller_line = (new Error).stack.split("\n")[3]; //first  2 level stack are useless 
                //var stack = (new Error).stack.toString().split(/\r\n|\n/);
                var subStrings =  caller_line.split(":");
                var line = subStrings[subStrings.length-2];
                console.log("[Line("+line+")]"+str);*/
                console.log(str);
            }
            if (adfw.Config.get("DEBUG_ALERTS") === true) {
                alert(str);
            }
        }
        else {
            if (typeof(print) === "function") {
                print(str);
            }
            if (typeof (Log) === 'object' && typeof(Log.slogd) === 'function') {
                Log.slogd(str); //Added for 2016 VOLT
            }
        }

    };
    Obj.prototype.error = function (str, prefix) {
        var caller_line = (new Error).stack.split("\n")[3]; //first  2 level stack are useless 
        //var stack = (new Error).stack.toString().split(/\r\n|\n/);
        var subStrings =  caller_line.split(":");
        var line = subStrings[subStrings.length-2];
        console.log("[Line("+line+")]"+str);
        this.log("[ERROR] [Line("+line+")]" + str, prefix);
    };

    //Why doesn't Javascript have this built-in??
    Obj.prototype.parseBoolean = function (string) {
        if (typeof string === "boolean") {
            return string;
        } else if (typeof string === "number") {
            if (string > 0) {
                return true;
            } else {
                return false;
            }
        } else if (typeof string == "string") {
            switch (string.toLowerCase().trim()) {
                case "true":
                case "yes":
                case "1":
                    return true;
                case "false":
                case "no":
                case "0":
                case null:
                    return false;
                default:
                    throw ("failed to parse boolean from " + string);
            }
        }

    };

    // Provide IAB VAST 4.0 standard timestamp.
    Obj.prototype.iabTimestamp = function () {
        var now = new Date();

        var year = now.getFullYear();
        var month = this.pad(now.getMonth() + 1, 2);
        var date = this.pad(now.getDate(), 2);

        var hours = this.pad(now.getHours(), 2);
        var minutes = this.pad(now.getMinutes(), 2);
        var seconds = this.pad(now.getSeconds(), 2);
        var milliseconds = this.pad(now.getMilliseconds(), 3);

        var timezoneOffset = now.getTimezoneOffset();
        var timezoneOffsetHours = this.pad(Math.abs(Math.floor(timezoneOffset / 60)), 2);
        var timezoneOffsetMinutes = this.pad(Math.abs(Math.floor(timezoneOffset % 60)), 2);
        var timezoneOffsetSign = (timezoneOffset < 0) ? '+' : '-';

        var timeDelimiter = ':';
        var timePrefix = 'T';
        var dateDelimiter = '-';

        var timestamp = year
            + dateDelimiter + month
            + dateDelimiter + date
            + timePrefix + hours
            + timeDelimiter + minutes
            + timeDelimiter + seconds
            + timeDelimiter + milliseconds
            + timezoneOffsetSign + timezoneOffsetHours
            + timeDelimiter + timezoneOffsetMinutes;

        return timestamp;
    };

    //MIME Checkers: Returns true if a given string matches a certain MIME type.
    Obj.prototype.isImageMIME = function (string) {
        return (this.isGIFMIME(string) || this.isJPEGMIME(string) || this.isPNGMIME(string));
    };
    Obj.prototype.isJSMIME = function (string) {
        return regexJS.test(string);
    };
    Obj.prototype.isFlashMIME = function (string) {
        return regexFlash.test(string);
    };
    Obj.prototype.isGIFMIME = function (string) {
        return regexGIF.test(string);
    };
    Obj.prototype.isJPEGMIME = function (string) {
        return regexJPEG.test(string);
    };
    Obj.prototype.isPNGMIME = function (string) {
        return regexPNG.test(string);
    };
    Obj.prototype.isHLSMIME = function (string) {
        return regexHLS.test(string);
    };
    Obj.prototype.isXMLMIME = function (string) {
        return regexXML.test(string);
    };
    Obj.prototype.isSmoothMIME = function (string) {
        return regexSmooth.test(string);
    };
    Obj.prototype.isDASHMIME = function (string) {
        return regexDash.test(string);
    };
    Obj.prototype.isMP4MIME = function (string) {
        return regexMP4.test(string);
    };
    Obj.prototype.isAVIMIME = function (string) {
        return regexAVI.test(string);
    };

    //Converts "HH:MM:SS:mmm" to milliseconds
    Obj.prototype.convertHMS = function (hmsString) {

        if (typeof hmsString !== "string") {
            return hmsString;
        }

        if (flatTimeOffsetRegex.test(hmsString)) {
            var timeArray = flatTimeOffsetRegex.exec(hmsString);
            //this.log("Time array: " + timeArray[1] + ":" + timeArray[2] + ":" + timeArray[3] + ":" + timeArray[4]);
            var ms = parseInt(timeArray[3], 10) * 1000 + parseInt(timeArray[2], 10) * 1000 * 60 + parseInt(timeArray[1], 10) * 1000 * 60 * 60; //Convert HH:MM:SS to millis
            if (timeArray[4]) {
                ms += parseInt(timeArray[4], 10);
            } //ms parameter is optional, HH:MM:SS is not
            return ms;
        } else {
            return null;
        }
    };

    //Converts milliseconds to "HH:MM:SS:mmm"
    Obj.prototype.convertMS = function (ms) {

        if (typeof ms !== "number") {
            return ms;
        }

        var temp = null;

        temp = this.integerDivision(ms, 3600000);
        var hours = this.pad(temp.quotient, 2);
        ms = temp.remainder;

        temp = this.integerDivision(ms, 60000);
        var minutes = this.pad(temp.quotient, 2);
        ms = temp.remainder;

        temp = this.integerDivision(ms, 1000);
        var seconds = this.pad(temp.quotient, 2);

        var hmsString;

        if (temp.remainder) {
            ms = this.pad(temp.remainder, 3);
            hmsString = hours + ":" + minutes + ":" + seconds + "." + ms;
        } else {
            hmsString = hours + ":" + minutes + ":" + seconds;
        }
        return hmsString;
    };

    //Given an integer and a desired string length, Returns a String padded with zeroes. Usage: pad(5, 3) //"005"
    Obj.prototype.pad = function (original, width, padString) {
        padString = padString || "0";
        original = "" + original;
        return original.length >= width ? original : new Array(width - original.length + 1).join(padString) + original;
    };

    //Given a numerator and denominator, returns a quotient and remainder
    Obj.prototype.integerDivision = function (numerator, denominator) {
        var quo = Math.floor(numerator / denominator);
        var rem = numerator % denominator;
        return ({
            quotient: quo,
            remainder: rem
        });
    };

    //Sends an async GET to a tracker's Url. It does not wait for or care about the result.
    Obj.prototype.fireTrackerUrl = function (url) {
        var self = this;

        if (!url) {
            this.error("Unable to submit EventXHR. Tracker Url not available...");
            return false;
        }

        if (adfw.Config.get("DISABLE_TRACKING_EVENTS") === true) {
            var x = url;
            if (x.length > 83) {
                try {
                    x = x.substring(0, 80) + "...";
                } catch (e) {
                }
            }
            if (!this.suppressWarnings) {
                this.suppressWarnings = 0;
            }

            if (this.suppressWarnings < 2) {
                this.log("WARNING: Tracking events are being suppressed because DISABLE_TRACKING_EVENTS is enabled");
                this.suppressWarnings++;
            }

            return false;
        }

        try {
            var limitAdTrack = webapis.adinfo.isLATEnabled();
        } catch (error) {
            console.log("WARNING: Tracking events are being suppressed because isLATEnabled throw error code = " + error.code);
            console.log("Please check http://developer.samsung.com/privilege/adinfo is added in privilege or not");
            return false;
        }
        if(limitAdTrack == true){
            this.log("WARNING: Tracking events are being suppressed because of no user permission");
            return false;
        }

        if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_VOLT) {
            var req = new ResourceRequest(url);
            req.async = true;
            req.addHeader("User-Agent", VOLT_USER_AGENT);
            req.complete = function (response, status) {
                //this.log("tracked: " + status + " " + url);
            }
            req.process();
        } else if (typeof(XMLHttpRequest) !== "undefined") {
            try {
                var xmlhttp = new XMLHttpRequest();
                xmlhttp.open("GET", url, true);
                xmlhttp.timeout = 10000;
                xmlhttp.onreadystatechange = function () {
                    if (xmlhttp.readyState == 4) {
                        adfw.Events.dispatchEvent("RESPONSE_FROM_TRACKING_SERVER", {readState: xmlhttp.readyState,
                                                status: xmlhttp.status, trackerUrl: url });
                        if (xmlhttp.status == 200) {
                            //self.log("tracked: " + url);
                            xmlhttp = null;
                        }
                    }
                };
                xmlhttp.ontimeout = function (e) {
                    xmlhttp = null;
                };
                xmlhttp.onerror = function (e) {
                    xmlhttp = null;
                };
                xmlhttp.send();
            } catch (e) {
                this.error("Unable to load XHR due to Exception: " + e);
            }
        } else {
            this.error("Unable to submit Event XHR. XMLHttpRequest not available...");
        }
    };

    Obj.prototype.ajax = function (url, timeout) {
        if (!url) {
            return adfw.Q.reject();
        }
        var self = this;

        //self.log("Attempting to AJAX: " + url);
        timeout = timeout || adfw.Config.get("AJAX_TIMEOUT") || 4444;

        var deferred = adfw.Q.defer();

        try {
            if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_VOLT) {
                var req = new ResourceRequest(url);
                req.async = true;
                req.addHeader("User-Agent", VOLT_USER_AGENT);
                req.complete = function (response, status) {
                    if (status == "success" || status == 200) {

                        var formattedResponse = {
                            responseText: response.data
                        };
                        if (response.data) {
                            try {
                                formattedResponse.responseXML = new adfw.DOMParser().parseFromString(response.data);
                            } catch (e) {
                                self.log("Failed to parse response XML from AJAX, it might be just text:\n" + e + "\n" + response.data);
                            }
                        }
                        deferred.resolve(formattedResponse);
                    } else {
                        deferred.reject("ajax request failed: " + status + " " + response.data);
                    }
                }
                req.process();
            } else if (typeof(XMLHttpRequest) !== "undefined") {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.timeout = timeout;
                xhr.onreadystatechange = function () {
                    if (xhr.readyState == 4) {
                        if (xhr.status == 200) {
                            deferred.resolve(xhr);
                        }
                    }
                };
                xhr.ontimeout = function (e) {
                    self.log("ajax timeout");
                    deferred.reject("ajax request timed out");
                    try {
                        xhr.destroy();
                        xhr = null;
                    } catch (e) {
                    }
                };
                xhr.onerror = function (e) {
                    self.log('error during AJAX retrieval');
                    deferred.reject(e);
                    try {
                        xhr.destroy();
                        xhr = null;
                    } catch (e) {
                    }
                };
                xhr.send();
                xhr.timeout = timeout;
            }
        } catch (e) {
            deferred.reject("exception: " + e);
        }

        return deferred.promise;
    };

    Obj.prototype.bindHelper = function (func, scope) {
        this.log("bindHelper called, binding " + func + " to " + scope);
        if (typeof func !== 'function') {
            // closest thing possible to the ECMAScript 5
            // internal IsCallable function
            throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs = Array.prototype.slice.call(arguments, 1),
            fToBind = func,
            fNOP = function () {
            },
            fBound = function () {
                return fToBind.apply(func instanceof fNOP && scope ? func : scope,
                    aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        fNOP.prototype = func.prototype || {};
        fBound.prototype = new fNOP();

        return fBound;
    };

    //A replacement for Function.prototype.bind - ensures that a function gets bound, whether or not Function.prototype.bind exists
    Obj.prototype.bind = function (f, scope) {
        var functionPrototypeBindExists = typeof(Function.prototype.bind) === 'function';
        var functionBindExists = typeof(f.bind) === 'function';
        var is2012 = adfw.OrsayWebkitUtils.is2012Model();

        // console.log("functionPrototypeBindExists? " + functionPrototypeBindExists);
        // console.log("functionBindExists? " + functionBindExists);
        // console.log("functionBind= (" + typeof(f.bind) + ") " + f.bind);
        // console.log("is2012? " + is2012);
        // console.log("useragent? " + navigator.userAgent);

        var useNativeBind = (functionPrototypeBindExists && functionBindExists && !is2012)
        try {
            if (useNativeBind) {
                //this.log("using native bind...");
                return f.bind(scope);
            }
            else {
                //this.log("using polyfill bind...");
                return this.bindHelper(f, scope);
            }
        }
        catch (e) {
            this.error("Failed to " + (useNativeBind ? "native" : "polyfill") + " bind function " + f + " to scope: " + scope + " due to " + e);
            throw e;
        }
    };

    //given an input, tries to return a string with information about the input
    Obj.prototype.getInspectionString = function (obj) {
        try {
            var str = '';
            var type = typeof(obj);

            str += '[' + type + '] ';

            if (type === 'function') {
                str += obj;
            }
            else if (type === 'object') {
                try {
                    if (obj === null) {
                        str += 'null';
                    }
                    else if (obj instanceof Error) {
                        str += '(' + obj.name + ') ' + obj.message + ' :: ' + obj.stack;
                    }
                    else {
                        var tmp = JSON.stringify(obj);
                        if (!tmp || tmp === '{}') {
                            throw new Error('no data');
                        }
                        str += tmp;
                    }
                }
                catch (e) {
                    try {
                        var keys = Object.keys(obj);
                        if (!keys || !keys.length) {
                            throw new Error('no keys');
                        }
                        var tmp = '(unstringifiable) {';
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            if (typeof key === 'string') {
                                tmp += '"' + key + '": ';
                            }
                            else {
                                tmp += key;
                            }
                            if (typeof obj[key] === 'string') {
                                tmp += '"' + obj[key] + '", ';
                            }
                            else {
                                tmp += obj[key] + ', ';
                            }
                        }
                        tmp = tmp.substring(0, tmp.length - 2);
                        tmp += '}';
                        str += tmp;
                    }
                    catch (e) {
                        str += '(unstringifiable) ' + obj;
                    }
                }
            }
            else {
                str += obj;
            }
            return str;
        }
        catch (e) {
            return 'failed to get inspection string: ' + e;
        }
    };

    Obj.prototype.stackTrace = function () {
        this.log(new Error().stack);
    };

    Obj.prototype.WebAPIExceptionForAdfw = function(param1,param2){
        this.code = adfw.Utils.WebAPIExceptionCodeForAdfw[param1];
        this.name = adfw.Utils.WebAPIExceptionNameForAdfw[param1];
        this.message = param2;
    };
    Obj.prototype.WebAPIExceptionCodeForAdfw = {
        NOT_FOUND_ERR: 8,
        TYPE_MISMATCH_ERR : 17,
        SECURITY_ERR: 18,
        INVALID_VALUES_ERR : 26,
        IO_ERR: 101,
        UNKNOWN_ERR : 9999
    };
    Obj.prototype.WebAPIExceptionNameForAdfw = {
        NOT_FOUND_ERR: 'NotFoundError',
        TYPE_MISMATCH_ERR : 'TypeMismatchError',
        SECURITY_ERR: 'SecurityError',
        INVALID_VALUES_ERR : 'InvalidValuesError',
        IO_ERR: 'IOError',
        UNKNOWN_ERR : 'UnknownError'
    };
    
    return new Obj();
})();
adfw.Utils.Timer = (function () {
    var Obj = function (callback, delay) {
        if (typeof callback !== 'function' || typeof delay !== 'number' || delay < 1) {
            throw "Need callback and delay";
        }
        this.callback = callback;
        this.reset(delay);
    };

    Obj.prototype.pause = function () {
        clearTimeout(this.timerID);
        this.remaining -= new Date() - this.startDate;
    };
    Obj.prototype.resume = function () {
        clearTimeout(this.timerID);
        this.startDate = new Date();
        this.timerID = setTimeout(this.callback, this.remaining);
    };
    Obj.prototype.reset = function (newDelay) {
        this.delay = newDelay || this.delay;
        this.remaining = this.delay;
        this.resume();
    };
    Obj.prototype.clear = function () {
        clearTimeout(this.timerID);
        this.remaining = null;
        this.startDate = null;
    };

    return Obj;
}());

adfw.Ad = (function () {
    "use strict";
    var Obj = function (options) {

        this.uid = (function () {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
            }

            return "ad_" + s4() + s4();
        })();

        //Required variables
        this._impressionTrackers = options.impressionTrackers || [];
        this.creatives = options.creatives || [];
        this.adSystem = options.adSystem;
        this.adTitle = options.adTitle;

        //Optional variables
        this.advertiser = options.advertiser;
        this.errorTrackers = options.errorTrackers || [];
        this.sequence = options.sequence;
        this.originalSequence = options.originalSequence;
        this.id = options.id;
        this.description = options.description;
        this.pricing = options.pricing;
        this.survey = options.survey;
        this.extensions = options.extensions;
        this.internalExtensions = options.internalExtensions;

        this._type = options.type; // type of ad. Currently only stores 'inline' if it is inline.

        //Always starts off false (duh)
        this._played = false;
        this._skipped = false;
        this._errored = false;
        this._isPrebuffered = false;

        this._sanityCheck();
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };

    Obj.prototype.handleImpression = function (contentPlayhead, adAssetURI) {
        this._impressionTrackers.forEach(function (tracker) {
            if (tracker.shouldFire("impression")) {
                tracker.fireTracker(contentPlayhead, adAssetURI);
            }
        });
    };

    Obj.prototype._getCreativeType = function (creativeType) {
        var ret = null;
        for (var i = 0; i < this.creatives.length; i++) {
            var it = this.creatives[i];
            if (it instanceof creativeType) {
                ret = it;
                break;
            }
        }
        return ret;
    };

    Obj.prototype.handleError = function (code, message, contentPlayhead, adAssetURI) {
        if (this.errorTrackers) {
            for (var i = 0; i < this.errorTrackers.length; i++) {
                this.errorTrackers[i].fireError(code, message, contentPlayhead, adAssetURI);
            }

        }
    };

    Obj.prototype.isLinear = function () {
        var linearCreativeExists = this.getLinearCreative() ? true : false;
        //alert(linearCreativeExists + " | " + this.getLinearCreative());
        return (linearCreativeExists);
    };

    Obj.prototype.getLinearCreative = function () {
        if (typeof this._linearCreative === 'undefined') {
            this._linearCreative = this._getCreativeType(adfw.LinearCreative);
        }
        return this._linearCreative;
    };

    Obj.prototype.getNonLinearCreative = function () {
        if (typeof this._nonLinearCreative === 'undefined') {
            this._nonLinearCreative = this._getCreativeType(adfw.NonLinearCreative);
        }
        return this._nonLinearCreative;
    };

    Obj.prototype.getCompanionCreativeArray = function () {
        if (typeof this._companionCreativeArray === 'undefined') {
            this._companionCreativeArray = [];
            for (var i = 0; i < this.creatives.length; i++) {
                var it = this.creatives[i];
                if (it instanceof adfw.CompanionCreative) {

                    this._companionCreativeArray.push(it);
                }
            }
        }
        return this._companionCreativeArray;
    };

    Obj.prototype.isPrebuffered = function () {
        return this._isPrebuffered;
    };

    Obj.prototype.setPrebuffered = function () {
        this._isPrebuffered = true;
    };

    Obj.prototype.isPlayed = function () {
        return this._played;
    };

    Obj.prototype.setPlayed = function () {
        this._played = true;
    };

    Obj.prototype.unsetPlayed = function () {
        this._played = false;
        this._impressionTrackers.forEach(function (tracker) {
            tracker.unsetFired();
        });
        this.creatives.forEach(function (creative) {
            var trackers = creative.getTrackers();
            trackers.forEach(function (tracker) {
                tracker.unsetFired();
            });
        });
    };

    Obj.prototype.isSkipped = function () {
        return this._skipped;
    };

    Obj.prototype.unsetSkipped = function () {
        this._skipped = false;
    };
    Obj.prototype.setSkipped = function () {
        this._skipped = true;
    };

    Obj.prototype.isErrored = function () {
        return this._errored;
    };

    Obj.prototype.setErrored = function () {
        this._errored = true;
    };

    Obj.prototype.toString = function () {
        var str = "Ad";
        str += "\n\t adTitle=" + this.adTitle;
        str += "\n\t adSystem=" + this.adSystem;
        str += "\n\t creatives=" + this.creatives.length;
        str += "\n\t impressionTrackers=" + this._impressionTrackers.length;
        str += "\n\t errorTrackers=" + this.errorTrackers.length;
        str += "\n\t advertiser=" + this.advertiser;
        str += "\n\t sequence=" + this.sequence + " (" + this.originalSequence + ")";
        str += "\n\t played=" + this.isPlayed();
        str += "\n\t errored=" + this.isErrored();
        return str;
    };

    //Makes sure things are the types that they should be - should be rerun after each modification of the Ad
    Obj.prototype._sanityCheck = function () {
        if (!(this._impressionTrackers instanceof Array)) {
            this._impressionTrackers = [];
        }
        if (!(this.creatives instanceof Array)) {
            this.creatives = [];
        }
        if (!(this.errorTrackers instanceof Array)) {
            this.errorTrackers = [];
        }
        if (this.sequence) {
            try {
                this.sequence = parseInt(this.sequence, 10);
            } catch (e) {
                this.sequence = null;
            }
        }
    };

    //Sorting function is based on sequence in an ad pod
    Obj.Sort = function (a, b) {
        if (a.sequence && b.sequence) {
            return a.sequence - b.sequence;
        }
        else if (a.sequence) {
            return -1;
        }
        else if (b.sequence) {
            return 1;
        }
        else {
            return 0;
        }
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW AD]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW AD]");
    };

    return Obj;
})();

adfw.AdBreak = (function () {
    "use strict";
    var Obj = function (options) {
        
        var self = this;

        if (!options.offset) {
            //throw("Failed to create Adbreak: Missing time offset value");
            options.offset = 0;
        }

        //Required variables
        if (options.offset instanceof adfw.Offset) {
            this._offset = options.offset;
        }
        else {
            this._offset = new adfw.Offset(options.offset);
        }
        this._breakType = options.breakType;

        //Variables that are not technically required but they're pretty much always there

        //This promise indicates the retrieval of ads (VMAP may specify that VAST tags are located elsewhere - in this case we load them later)
        this._hasTriedToResolve = false;
        this.renewAdResolveDeferred();

        //this.log("options.ads: " + options.ads);
        //this.log("options.lazyVASTResolver: " + options.lazyVASTResolver);
        this._ads = options.ads;
        if (this._ads && this._ads.length) {
            this._ads.sort(adfw.Ad.Sort);
            this._hasTriedToResolve = true;
            this.resolvedAdsDeferred.resolve();
        }
        else if (typeof options.lazyVASTResolver !== 'undefined' && options.lazyVASTResolver instanceof adfw.LazyVASTResolver) {
            //The lazy resolver will resolve ads just-in-time
            this.lazyVASTResolver = options.lazyVASTResolver;
            this._ads = [];
        }
        else {
            //No ad scenario
            this.resolvedAdsDeferred.resolve();
            this._hasTriedToResolve = true;
            this._ads = [];
        }

        this._eventTrackers = options.eventTrackers;
        this._errorTrackers = options.errorTrackers;

        //Optional variables
        this._breakID = options.breakID;
        this._adSourceID = options.adSourceID;

        this._allowMultipleAds = true;
        if (typeof options.allowMultipleAds !== "undefined") {
            try {
                this._allowMultipleAds = adfw.Utils.parseBoolean(options.allowMultipleAds);
            }
            catch (e) {
                this._allowMultipleAds = true;
            }
        }
        if (this._allowMultipleAds && (this.getAds().length && this.getAds().length > 1)) {

        }

        if (typeof options.followRedirects !== "undefined") {
            try {
                this._followRedirects = adfw.Utils.parseBoolean(options.followRedirects);
            }
            catch (e) {
                this._followRedirects = true;
            }
        }

        this._extensions = options.extensions || {};
        this._extensions.local = this._extensions.local || [];
        this._extensions.global = this._extensions.global || [];

        this._played = false;
        this._skipped = false;

        var repeatAfterMS = options.repeatAfter;
        if (typeof options.repeatAfter === "string" && options.repeatAfter) {
            repeatAfterMS = adfw.Utils.convertHMS(options.repeatAfter);
        }
        if (typeof repeatAfterMS === "number" && repeatAfterMS > 1000) {
            this._repeatAfter = repeatAfterMS;
        }

        if (typeof options.adBreakXMLString === "string" && options.adBreakXMLString) {
            this._adBreakXMLString = options.adBreakXMLString;
        }

        if (typeof options.parsingContext === "object" && options.parsingContext) {
            this._parsingContext = options.parsingContext;
        }
    };

    Obj.prototype.resolve = function () {
        var self = this;
        if (this.hasTriedToResolve() || (this._ads && this._ads.length)) {
            return false;
        }
        this._hasTriedToResolve = true;
        //this.log("LazyVastResolver: " + this.lazyVASTResolver);
        this.lazyVASTResolver.resolve()
            .then(self.resolvedAdsDeferred.resolve)
            .catch(function (e) {
                self.log("Lazy-load failed: " + e);
                self.resolvedAdsDeferred.resolve([]);
            });
    };

    Obj.prototype.isResolved = function () {
        return this.resolvedAdsDeferred ? !this.resolvedAdsDeferred.promise.isPending() : true;
    };

    Obj.prototype.whenReady = function (fun) {
        return this.getAdResolvePromise()
            .then(fun);
    };

    Obj.prototype.getAdResolvePromise = function () {
        return this.resolvedAdsDeferred.promise;
    };

    Obj.prototype.renewAdResolveDeferred = function () {
        var self = this;

        if (this.resolvedAdsDeferred) {
            this.resolvedAdsDeferred.reject();
        }

        this.resolvedAdsDeferred = adfw.Q.defer();
        return this.resolvedAdsDeferred.promise
            .then(function (adList) {
                if (adList instanceof Array && adList.length && adList[0] instanceof adfw.Ad) {
                    //self.log("Lazy-load complete: " + adList.length);
                    self._ads = adList;
                    self._ads.sort(adfw.Ad.Sort);
                }
            });
    };

    Obj.prototype.hasTriedToResolve = function () {
        return this._hasTriedToResolve;
    };

    //Returns a boolean that specifies whether this ad break is set to repeat.
    Obj.prototype.isRepeating = function () {
        var truth = (typeof(this._repeatAfter) === "number" && typeof(this._adBreakXMLString) === "string" && typeof(this._parsingContext) === "object");
        return truth;
    };

    //Given a current time in milliseconds, return a promise for a duplicate repeating ad break.
    //The duplicate ad break will have all of the data that this ad break contains, except that it will re-parse its AdSource node (to get new ads from the ad server).
    Obj.prototype.createRepeatingAdBreakPromise = function (currentMS) {

        //this.log("SPAWN " + this.toString());

        var self = this;

        if (!this.isRepeating() || typeof(currentMS) !== "number") {
            var errorMessage = "Missing properties that are required for a repeating ad break. Aborting..."
            this.error(errorMessage);
            return adfw.Q.reject(errorMessage);
        }

        //This is a replication of the original XML node that this ad break was parsed from
        var parsedXML = new adfw.DOMParser().parseFromString(this._adBreakXMLString, "text/xml");
        this.log("createRepeatingAdBreakPromise - adBreakXMLString = " + this._adBreakXMLString);

        var adBreakNode = null;
        if (parsedXML) {
            var adBreakNodes = parsedXML.getElementsByTagName("AdBreak");
			
            if(adBreakNodes.length === 0)
            {
                adBreakNodes = parsedXML.getElementsByTagName("vmap:AdBreak");
            }
			
            if (adBreakNodes && adBreakNodes.length) {
                adBreakNode = adBreakNodes[0];
            }
        }

        //Check if we have a valid ad break node to parse
        if (!adBreakNode) {
            var errorMessage = "Could not schedule repeating adbreak: to find an ad break node...";
            this.error(errorMessage);
            return adfw.Q.reject(errorMessage);
        }

        //This is the content offset that the repeating ad break will occur at
        var repeatMS = currentMS + this._repeatAfter;

        return adfw.Parser.parseVMAPAdBreakNodeAsync(adBreakNode, this._parsingContext)
            .then(function (newAdBreak) {
                self.log("Successfully created repeating adbreak: " + newAdBreak);
                newAdBreak.setOffset(repeatMS);
                return newAdBreak;
            })
            .catch(function (result) {
                self.log("Failed to create repeating adbreak: " + result);
            });
    };

    //Clears repeat data from this ad break (saving memory)
    Obj.prototype.deleteRepeatData = function () {
        this._parsingContext = null;
        this._repeatAfter = null;
        this._adBreakXMLString = null;
    };

    //Set the datetime that this ad break started.
    Obj.prototype.setStartTime = function (date) {
        this.date = date;
    };

    //Get the datetime that this ad break started at.
    Obj.prototype.getStartTime = function (date) {
        return this.date;
    };

    Obj.prototype.hasPod = function () {
        if (typeof this._hasAdPod === "undefined") {
            if (this.getAds().length && this.getAds()[0].sequence) {
                this._hasAdPod = true;
            }
            else {
                this._hasAdPod = false;
            }
        }
        return this._hasAdPod;
    };

    //Is any ad within this adbreak linear?
    Obj.prototype.isLinear = function () {
        var isLinear = false;
        for (var i = 0; i < this.getAds().length; i++) {
            var ad = this.getAds()[i];
            if (ad.isLinear() && !ad.isPlayed() && !ad.isSkipped() && !ad.isErrored()) {
                isLinear = true;
                break;
            }
        }
        return isLinear;
    };

    Obj.prototype.getNextAd = function () {
        // console.trace();
        var alreadyPlayedDuration = 0;
        var nextAdDuration = 0;
        var nextAd = null;
        for (var i = 0; i < this.getAds().length; i++) {
            var ad = this.getAds()[i];
            if (ad.isPlayed()) {
                var linearCreative = ad.getLinearCreative();
                if (linearCreative && linearCreative.duration) {
                    alreadyPlayedDuration += linearCreative.duration;
                }
            } else if (ad.isErrored()) {
                //Skip the ad since it's errored
            }
            else {
                nextAd = ad;
                if (nextAd.getLinearCreative() && nextAd.getLinearCreative().duration) {
                    nextAdDuration = nextAd.getLinearCreative().duration;
                }
                break;
            }
        }

        //Total duration of already played ads and the next ad to be played
        var totalAdbreakDuration = alreadyPlayedDuration + nextAdDuration;

        if (!nextAd) {
            //No more ads in adbreak
            return null;
        }

        if (!nextAd.getLinearCreative() && nextAd.getNonLinearCreative()) {
            //No linear creative, just return the ad because we don't have to calculate the duration and maximum ad length and blah blah
            return nextAd;
        }

        else if (adfw.Config.get("PLAY_ALL_ADS") === true) {
            //We're playing all ads in the adbreak, no matter what.
            //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "PLAY_ALL_ADS is on - playing all ads in adbreak..." });
            return nextAd;
        }
        else if (adfw.Config.get("MAXIMUM_ADBREAK_DURATION") > 4000 && adfw.Config.get("MAXIMUM_ADBREAK_DURATION") < totalAdbreakDuration) {
            //We've exceeded the maximum adbreak duration, so we will end the adbreak even if there is a pod in progress.
            //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Ending adbreak: Adbreak Duration " + totalAdbreakDuration + " exceeds maximum of " + adfw.Config.get("MAXIMUM_ADBREAK_DURATION") });
            return null;
        }
        else if (this.hasPod()) {
            if (typeof nextAd.sequence === "number") {
                //We've got the next ad in the pod, let's play it (since we already checked for MAXIMUM_ADBREAK_DURATION earlier)
                //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Continuing adbreak: Playing from pod..." });
                return nextAd;
            }
            else {
                //We finished the ad pod, let's skip the buffet
                //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Ending adbreak: Ad pod is complete" });
                return null;
            }
        }
        else if (adfw.Config.get("TARGET_ADBREAK_DURATION") > 4000) {

            var target = adfw.Config.get("TARGET_ADBREAK_DURATION");
            var maxSquishTime = 60000;

            if (totalAdbreakDuration > target + maxSquishTime) {
                //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Ending adbreak: Adbreak Duration " + totalAdbreakDuration + " exceeds target of " + target + " (squish time exceeded)" });
                return null;
            }
            else if (totalAdbreakDuration > target) {
                if (Math.abs(target - totalAdbreakDuration) > target - alreadyPlayedDuration) {
                    //This ad break has no ad pods to respect. The total duration of the buffet played so far exceeds our target duration, so we will end the adbreak.
                    //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Ending adbreak: Adbreak Duration " + totalAdbreakDuration + " exceeds target of " + target + " (gain:" + Math.abs(target - totalAdbreakDuration) + " loss:" + (target - alreadyPlayedDuration) + ")" });
                    return null;
                }
                else {
                    //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Continuing adbreak: Adbreak Duration " + totalAdbreakDuration + " is close enough to the target of " + target + " (gain:" + Math.abs(target - totalAdbreakDuration) + " loss:" + (target - alreadyPlayedDuration) + ")" });
                    return nextAd;
                }
            }
            else {
                //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Continuing adbreak: Playing from buffet." });
                return nextAd;
            }
        }
        else {
            //None of the above apply. Just play the next ad.
            //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, { message: "Continuing adbreak: Playing from buffet with no target duration" });
            return nextAd;
        }
    };

    Obj.prototype.handleEvent = function (id, adPlayhead, adDuration, contentPlayhead, adAssetURI) {
        this._eventTrackers.forEach(function (tracker) {
            if (tracker.shouldFire(id, adPlayhead, adDuration)) {
                tracker.fireTracker(contentPlayhead, adAssetURI);
            }
        });
    };

    Obj.prototype.handleBreakStart = function () {
        this.handleEvent("breakStart");
    };

    Obj.prototype.handleBreakEnd = function () {
        this.handleEvent("breakEnd");
        this.setPlayed();
    };

    Obj.prototype.handleError = function (code, message, contentPlayhead, adAssetURI) {
        if (this._errorTrackers) {
            for (var i = 0; i < this._errorTrackers.length; i++) {
                this._errorTrackers[i].fireError(code, message, contentPlayhead, adAssetURI);
            }
        }
    };

    /**
     * Get an Array of ads contained within this ad break.
     * @return {Array}
     */
    Obj.prototype.getAds = function () {
        return this._ads;
    };

    Obj.prototype.getLinearAdCount = function () {
        var linearDuration = 0;
        var linearAdCount = 0;
        if (this.isLinear()) {
            var ads = this.getAds();
            ads.forEach(function (ad) {
                if (ad.isLinear()) {
                    linearAdCount++;
                    var linearCreative = ad.getLinearCreative();
                    var adDuration = linearCreative.getDuration();
                    linearDuration += adDuration;
                }
            });
        }
        return linearAdCount;
    };

    Obj.prototype.getLinearDuration = function () {
        var linearDuration = 0;
        var linearAdCount = 0;
        if (this.isLinear()) {
            var ads = this.getAds();
            ads.forEach(function (ad) {
                if (ad.isLinear()) {
                    linearAdCount++;
                    var linearCreative = ad.getLinearCreative();
                    var adDuration = linearCreative.getDuration();
                    linearDuration += adDuration;
                }
            });
        }
        return linearDuration;
    };

    Obj.prototype.getOffset = function () {
        return this._offset;
    };

    Obj.prototype.setOffset = function (offset) {
        if (!offset) {
            return false;
        }
        if (offset instanceof adfw.Offset) {
            this._offset = offset;
        }
        else {
            var newOffset = new adfw.Offset(offset);
            if (newOffset) {
                this._offset = newOffset;
            }
            else {
                return false;
            }
        }
    };

    Obj.prototype.isPlayed = function () {
        return this._played;
    };

    Obj.prototype.setPlayed = function () {
        this._played = true;
    };

    Obj.prototype.unsetPlayed = function () {
        this._played = false;
        this._eventTrackers.forEach(function (tracker) {
            tracker.unsetFired();
        });
        if (this.lazyVASTResolver) {
            this.renewAdResolveDeferred();
            this._hasTriedToResolve = false;
            this._ads = [];
        }
        else {
            this._ads.forEach(function (ad) {
                ad.unsetPlayed();
            });
        }


    };

    //"Skipped" means that we have fast-forwarded past this midroll's trigger point and are not playing the midroll.
    Obj.prototype.isSkipped = function () {
        return this._skipped;
    };
    Obj.prototype.setSkipped = function () {
        this._skipped = true;
    };
    //If we rewind back to before the skipped midroll's position, we can restore it.
    Obj.prototype.unsetSkipped = function () {
        this._skipped = false;
        if (this.lazyVASTResolver && this._hasTriedToResolve) {
            this.renewAdResolveDeferred();
            this._hasTriedToResolve = false;
            this._ads = [];
        }
    };

    Obj.prototype.test = function (playhead, duration) {
        return (!this.isPlayed()) && !this.isSkipped() && this.getOffset().test(playhead, duration);
    };

    Obj.prototype.toString = function () {
        var str = "AdBreak";
        str += "\n\t offset=" + this.getOffset().toString();
        str += "\n\t breakType=" + this._breakType;
        str += "\n\t ads=" + this.getAds().length;
        str += "\n\t eventTrackers=" + this._eventTrackers.length;
        str += "\n\t errorTrackers=" + this._errorTrackers.length;
        str += "\n\t breakID=" + this._breakID;
        str += "\n\t adSourceID=" + this._adSourceID;
        str += "\n\t allowMultipleAds=" + this._allowMultipleAds;
        str += "\n\t followRedirects=" + this._followRedirects;
        str += "\n\t played=" + this.isPlayed();
        if (this._extensions.global) {
            str += "\n\t extensions (global)=" + this._extensions.global.length;
        }
        if (this._extensions.local) {
            str += "\n\t extensions (local)=" + this._extensions.local.length;
        }
        if (this._repeatAfter) {
            str += "\n\t repeatAfter=" + this._repeatAfter;
        }
        return str;
    };

    //Gets a sorting function based on the given Playhead and Duration (necessary to calculate percentage offsets)
    Obj.prototype.getSortFunction = function (duration) {
        return function (a, b) {
            if (a.getOffset().getType() === adfw.Offset.OffsetType.STATIC_OFFSET_START) {
                return -1;
            }
            else if (a.getOffset().getType() === adfw.Offset.OffsetType.STATIC_OFFSET_END) {
                return 1;
            }
            else {
                return a.getOffset().getTriggerMS(duration) - b.getOffset().getTriggerMS(duration);
            }
        };
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW ADBREAK]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW ADBREAK]");
    }

    return Obj;
})();

adfw.LazyVASTResolver = (function () {
    "use strict";
    var Obj = function (input, context) {
        if (!input) {
            throw "Invalid input: " + url;
        }
        if (typeof context !== "object") {
            context = {};
        }

        this.input = input;
        this.context = context;
    };

    Obj.prototype.resolve = function () {
        return adfw.Parser.parse(this.input, this.context);
    };

    Obj.prototype.toString = function () {
        var str = "LazyVASTResolver";
        str += "\n\t input=" + this.input;
        str += "\n\t context=" + this.context;
        return str;
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW LAZYVASTRESOLVER]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW LAZYVASTRESOLVER]");
    }

    return Obj;
})();
/**
 Creatives
 Creative
 CompanionAds // HTML companion ads to be displayed alongside the player.
 Companion
 StaticResource || HTMLResource || IFrameResource
 TrackingEvents
 Tracking
 CompanionClickThrough
 */

/**
 * @brief Companion Model.
 * @details A BluePrint of Companion Model
 * @return Null
 */
adfw.Companion = (function () {
    "use strict";
    var Obj = function (options) {
        if (!options.width || !options.height) {
            throw "Companion Ad MUST specify width/height!";
        }
        if (!options.resources) {
            throw "Companion Ad MUST specify Resources Object!";
        }
        this.width = parseInt(options.width, 10); //(required) the pixel width of the placement slot for which the creative is intended
        this.height = parseInt(options.height, 10);
        this.resources = options.resources || [];

        //<--Optional Attribute
        this.id = options.id;
        this.assetWidth = options.assetWidth ? parseInt(options.assetWidth, 10) : 0; //the pixel width of the creative
        this.assetHeight = options.assetHeight ? parseInt(options.assetHeight, 10) : 0;
        this.expandedWidth = options.expandedWidth ? parseInt(options.expandedWidth, 10) : 0; //Max allowable width
        this.expandedHeight = options.expandedHeight ? parseInt(options.expandedHeight, 10) : 0; //Max allowable height
        this.adSlotID = options.adSlotID; //used to identify desired placement on a publisher's page
        //Optional Attribute-->

        this.altText = options.altText;

        //Ad Parameters for VPAID
        this.apiFramework = options.apiFramework;
        this.adParameters = options.adParameters;
        this.Rejected = false;
        this.Showed = false;
        this.eventTrackers = options.eventTrackers || [];
        this.removeCompanionErrorStaticImageResource();
    };
    /**
     * [handleEvent]
     * @param  {[type]} id              [description]
     * @param  {[type]} adPlayhead      [description]
     * @param  {[type]} adDuration      [description]
     * @param  {[type]} contentPlayhead [description]
     * @param  {[type]} adAssetURI      [description]
     * @return {[type]}                 [description]
     */
    Obj.prototype.handleEvent = function (id, adPlayhead, adDuration, contentPlayhead, adAssetURI) {
        this.eventTrackers.forEach(function (tracker) {
            if (tracker.shouldFire(id, adPlayhead, adDuration)) {
                tracker.fireTracker(contentPlayhead, adAssetURI);
            }
        });
    };

    /**
     * @brief getWidth
     * @details Getter for this.width
     * @return {[INTEGER]} [width]
     */
    Obj.prototype.getWidth = function () {
        return this.width;
    };

    /**
     * [getHeight]
     * @return {[INTEGER]} [height]
     */
    Obj.prototype.getHeight = function () {
        return this.height;
    };

    /**
     * [getID]
     * @return {[STRING]} [id]
     */
    Obj.prototype.getID = function () {
        return this.id;
    };

    /**
     * [getAdSlotID]
     * @return {[STRING]} [adSlotID]
     */
    Obj.prototype.getAdSlotID = function () {
        return this.adSlotID;
    };

    /**
     * [getResources]
     * @return {[CompanionResource Array]} [resources]
     */
    Obj.prototype.getResources = function () {
        return this.resources || [];
    };

    /**
     * [getAltText]
     * @return {[STRING]} [altText]
     */
    Obj.prototype.getAltText = function () {
        return this.altText;
    };

    var PriorityMap = {
        STATIC_IMAGE: 1,
        HTML: 2,
        IFRAME: 3,
        STATIC_JS: 4,
        STATIC_FLASH: 5
    };

    /**
     * [resourceComparer comparer function]
     * @param  {[CompanionResource]} a [CompanionResource]
     * @param  {[CompanionResource]} b [CompanionResource]
     * @return {[INTEGER]}
     */
    var resourceComparer = function (a, b) {
        var ap = PriorityMap[a.type];
        var bp = PriorityMap[b.type];
        if (!bp) {
            return 1;
        }
        if (!ap) {
            return -1;
        }
        return ap - bp;
    };


    Obj.prototype.removeCompanionErrorStaticImageResource = function () {
        for (var i = 0; i < this.resources.length; i++) {
            var resource = this.resources[i];
            if (resource.getType() == "STATIC_IMAGE") {
                var tempImg = document.createElement("img");
                tempImg.onerror = function (resources, resource) {
                    return function () {
                        resources.splice(resources.indexOf(resource), 1);
                    }
                }(this.resources, resource);
                tempImg.src = resource.getContent();
            }
        }
    }

    Obj.prototype.getPriorityCompanionResource = function () {
        if (!this.resources) {
            return null;
        }
        if (!this._priorityResource) {
            this._priorityResource = function () {
                if (!this.resources.length) return null;
                //Sort the Object with priority map
                this.resources.sort(resourceComparer);
                this.resources[0].getCompiledHtmlElement(this);

                return this.resources[0];
            }.call(this);
        }
        return this._priorityResource;
    };

    Obj.prototype.getAssetURI = function () {
        return this.getPriorityCompanionResource() ? this.getPriorityCompanionResource().asset_url : null;
    };

    Obj.prototype.setRejected = function () {
        this.Rejected = true;
    };

    Obj.prototype.isRejected = function () {
        return this.Rejected;
    };

    Obj.prototype.setCreatedView = function () {
        if (this.Rejected) {
            this.Showed = false;
            return;
        }
        this.Showed = true;
    };

    Obj.prototype.isShowed = function () {
        return (this.Rejected) ? false : this.Showed;
    };


    return Obj;
})();

adfw.CompanionResource = (function () {
    "use strict";
    var Obj = function (options) {
        if (!options.content) {
            throw "Companion Ad MUST specify content";
        } else if (!options.resourceCategory) {
            throw "Companion Ad Static Resource MUST specify TYPE";
        } else if ("STATIC" == options.resourceCategory && !options.creativeType) {
            throw "Companion Ad Static Resource MUST specify creativeType";
        } else if ("STATIC" == options.resourceCategory && !options.clickThrough) {
            throw "Companion Ad Static Resource MUST specify clickThroughUrl";
        }
        //(required)
        this.content = options.content;

        //(required) [STATIC,IFRAME,HTML]
        this.resourceCategory = options.resourceCategory;

        //(required only if StaticResource [IMAGE,JS,FLASH]
        this.creativeType = function (creativeType) {
            if (!creativeType) return null;
            if ((/javascript/gi).test(creativeType)) {
                return "JS";
            } else if ((/flash/gi).test(creativeType)) {
                return "FLASH";
            } else {
                return "IMAGE";
            }
        }(options.creativeType);

        //Clickthrough and clicktracking information
        //(required only if StaticResource
        this.clickThrough = options.clickThrough;
        this.clickTrackers = options.clickTrackers;

        this.asset_url = "";
        this.type = function (_this) {
            if (!_this.creativeType) {
                return _this.resourceCategory;
            } else {
                return _this.resourceCategory + "_" + _this.creativeType;
            }
        }(this);
    };

    var PriorityMap = {
        STATIC_IMAGE: 1,
        HTML: 2,
        IFRAME: 3,
        STATIC_JS: 4,
        STATIC_FLASH: 5
    };

    Obj.prototype.getContent = function () {
        return this.content;
    }

    Obj.prototype.getCompiledHtmlElement = function (companion) {
        if (!this.content) {
            return null;
        }

        if (!this.compiledElement) {

            this.compiledElement = function () {

                if (this.type == "HTML") {
                    return this.content;
                } else if (this.type == "STATIC_IMAGE") {
                    this.asset_url = this.content;
                    return function () {
                        return "<a href='#' class='companionAdStaticResource'>" +
                            "<img src='" + this.content + "' width='" + companion.getWidth() + "' height='" + companion.getHeight() + "' alt='" + companion.getAltText() + "' />" +
                            "</a>";
                    }.call(this);

                } else if (this.type == "IFRAME") {
                    this.asset_url = this.content;
                    return function (content) {
                        return "<iframe src='" + this.content + "' width='" + companion.getWidth() + "' height='" + companion.getHeight() + "'></iframe>";
                    }.call(this);
                } else if (this.type == "STATIC_JS") {
                    this.asset_url = this.content;
                    return function (content) {
                        return "<script src='" + this.content + "'><script>";
                    }.call(this);
                } else if (this.type == "STATIC_FLASH") {
                    this.asset_url = this.content;
                    return this.content;
                }

                return this.content;

            }.call(this);
        }
        return this.compiledElement;
    }
    Obj.prototype.getResourceCategory = function () {
        return this.resourceCategory;
    }
    Obj.prototype.getCreativeType = function () {
        return this.creativeType;
    };
    Obj.prototype.getClickThrough = function () {
        return this.clickThrough;
    }
    Obj.prototype.getClickTrackers = function () {
        return this.clickTrackers;
    }
    Obj.prototype.getType = function () {
        return this.type;
    };

    //On click, fire all click trackers
    Obj.prototype.handleClick = function () {
        if (!this.clickTrackers) {
            return;
        }
        for (var i = 0; i < this.clickTrackers.length; i++) {
            this.clickTrackers[i].fireTracker(adfw.Controller.getState().currentContentPlayhead(), this.content);
        }
    };
    return Obj;
})();

adfw.Creative = (function () {
    "use strict";
    var Obj = function (options) {
        this.id = options.id;

        if (options.sequence) {
            try {
                this.sequence = parseInt(options.sequence, 10);
                if (isNaN(this.sequence)) {
                    this.sequence = null;
                }
            } catch (e) {
                this.sequence = null;
            }
        }

        this.adID = options.adID;
        this.apiFramework = options.apiFramework;
        this.adParameters = options.adParameters;
        this.eventTrackers = options.eventTrackers || [];

        this._sanityCheck();
    };

    Obj.prototype.getTrackers = function () {
        return this.eventTrackers;
    };

    Obj.prototype.handleEvent = function (id, adPlayhead, adDuration, contentPlayhead, adAssetURI) {
        //adfw.Utils.log("handling event: id=" + id + " | ph=" + adPlayhead + " | d=" + adDuration + " | uri=" + adAssetURI);
        var self = this;
        this.eventTrackers.forEach(function (tracker) {
            if (tracker.shouldFire(id, adPlayhead, adDuration)) {
                tracker.fireTracker(contentPlayhead, adAssetURI);
                //self.log("Tracker fired: " + id + " | " + adPlayhead + " | " + adDuration);
            }
        });
    };

    Obj.prototype.handleProgress = function (id, adPlayhead, adDuration, contentPlayhead, adAssetURI) {
        this.handleEvent("progress", adPlayhead, adDuration, contentPlayhead, adAssetURI);
        this.handleEvent("start", adPlayhead, adDuration, contentPlayhead, adAssetURI);
        this.handleEvent("creativeView", adPlayhead, adDuration, contentPlayhead, adAssetURI);
    };

    //Makes sure internal state is how it should be - used after a merge
    Obj.prototype._sanityCheck = function () {
        if (this.sequence) {
            try {
                this.sequence = parseInt(this.sequence, 10);
            } catch (e) {
                this.sequence = null;
            }
        }
        this.eventTrackers = this.eventTrackers || [];
    };

    //Regular creatives aren't skippable
    Obj.prototype.isSkippable = function () {
        return false;
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW CREATIVE]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW CREATIVE]");
    }

    return Obj;
})();

/*
 var linearCreativeObject = new adfw.LinearCreative({
 //General Creative stuff
 id: String,
 sequence: Integer,
 adID: String,
 apiFramework: String,
 //Variables specific to Linears
 clickTrackers
 duration: Integer (ms),
 mediaFiles: [adfw.LinearMediaFile],
 trackers: [adfw.Tracker],
 skipOffset: String
 icons: TODO
 });
 */
/*
 var linearCreativeObject = new adfw.LinearCreative({
 //General Creative stuff
 id: String,
 sequence: Integer,
 adID: String,
 apiFramework: String,
 //Variables specific to Linears
 clickTrackers
 duration: Integer (ms),
 mediaFiles: [adfw.LinearMediaFile],
 trackers: [adfw.Tracker],
 skipOffset: String
 icons: TODO
 });
 */
adfw.LinearCreative = (function () {
    "use strict";
    var parent = adfw.Creative;

    var Obj = function (options) {
        parent.call(this, options);
        this.duration = parseInt(options.duration, 10);
        this.mediaFiles = options.mediaFiles;
        this.icons = options.icons;
        this.clickTrackers = options.clickTrackers;
        this.clickThrough = options.clickThrough;

        if (typeof options.skipOffset === "string" && options.skipOffset) {
            this.skipOffset = new adfw.Offset(options.skipOffset);
        } else {
            this.skipOffset = null;
        }

        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype = Object.create(adfw.Creative.prototype);
    Obj.constructor = Obj;

    Obj.prototype.getClickThrough = function () {
        if (this.clickThrough && this.clickThrough.length > 1) {
            return this.clickThrough;
        } else {
            return null;
        }
    };

    //Handles tracking events for a click on the video
    Obj.prototype.handleClick = function () {
        if (!this.clickTrackers) {
            return;
        }
        for (var i = 0; i < this.clickTrackers.length; i++) {
            var playhead = 0;
            try {
                playhead = adfw.Controller.getState().currentContentPlayhead();
            } catch (e) {
            }
            this.clickTrackers[i].fireTracker(playhead, this.getOptimalMediaFile().getUrl());
        }
    };

    //Picks the best linear media file to play based on the platform.
    Obj.prototype.getOptimalMediaFile = function () {

        if (!this._optimalMediaFile) {
            var hlsStream = null;
            var smoothStream = null;
            var dashStream = null;
            var progressives = [];

            
            for (var i = 0; i < this.mediaFiles.length; i++) {
                var type = this.mediaFiles[i].getType();
                if (this.mediaFiles[i].isInteractiveCreativeFile) {
                    this._interactive = this.mediaFiles[i];
                    continue;
                }
                if (type === adfw.LinearMediaFile.Types.PROGRESSIVE) {
                    progressives.push(this.mediaFiles[i]);
                } else if (type === adfw.LinearMediaFile.Types.SMOOTH) {
                    smoothStream = this.mediaFiles[i];
                } else if (type === adfw.LinearMediaFile.Types.DASH) {
                    dashStream = this.mediaFiles[i];
                } else if (type === adfw.LinearMediaFile.Types.HLS) {
                    hlsStream = this.mediaFiles[i];
                }
            }

            //Known Samsung Smart TV adapters get Smooth Streaming
            var adapterType = adfw.Controller.getPlayer().getAdapterType();
            if (adapterType === adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_WEBKIT_AVPLAY ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_D2TV ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_LWPLAYER ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_VIDEOWIDGET_V1 ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_VIDEOWIDGET_V2 ||
                adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_TVPLUS_IP
            ) {
                if (smoothStream) {
                    this._optimalMediaFile = smoothStream;
                } else if (dashStream) {
                    this._optimalMediaFile = dashStream;
                } else if (hlsStream) {
                    this._optimalMediaFile = hlsStream;
                } else if (progressives) {
                    this._optimalMediaFile = this.getOptimalProgressiveFile(progressives);
                }
            }
            //Unknown platforms get a progressive file
            else {
                if (progressives) {
                    this._optimalMediaFile = this.getOptimalProgressiveFile(progressives);
                }
            }

            //If adaptive ads are deprioritized, then grab a progressive instead
            if (adfw.Config.get("PRIORITIZE_ADAPTIVE_ADS") === false && progressives) {
                this._optimalMediaFile = this.getOptimalProgressiveFile(progressives);
            }
        }
        return this._optimalMediaFile;
    };

    Obj.prototype.getOptimalProgressiveFile = function (progressives) {
        var optimal = null;
        for (var x = 0; x < progressives.length; x++) {
            if (!optimal) {
                optimal = progressives[x];
            } else {
                if ((adfw.Utils.isAVIMIME(progressives[x].getMIMEType()) || adfw.Utils.isMP4MIME(progressives[x].getMIMEType())) && !(adfw.Utils.isAVIMIME(optimal) || adfw.Utils.isMP4MIME(optimal))) {
                    //AVI or MP4 would be better
                    optimal = progressives[x];
                } else if (progressives[x].width > optimal.width) {
                    //Larger would be better
                    optimal = progressives[x];
                } else if (progressives[x].getBitrate() > optimal.getBitrate()) {
                    //Higher bitrate would be better (if our network is constrained, well too bad, we can't calculate the bitrate)
                    optimal = progressives[x];
                }
            }
        }
        return optimal;
    };

    Obj.prototype.getInteractiveCreativeFile = function () {

        for (var i = 0; i < this.mediaFiles.length; i++) {
            if (this.mediaFiles[i].isInteractiveCreativeFile) {
                this._interactive = this.mediaFiles[i];
                return this._interactive;
            }
        }
        return null;
    };

    //Picks the best linear industry icons.
    Obj.prototype.getIcons = function () {
        return this.icons;
    };

    Obj.prototype.isSkippable = function () {
        if (this.skipOffset && this.skipOffset instanceof adfw.Offset) {
            return true;
        } else {
            return false;
        }
    };

    Obj.prototype.canSkipNow = function (contentPlayhead, contentDuration) {
        //adfw.Utils.log("canSkipNow: " + contentPlayhead + " | " + contentDuration);
        if (this.isSkippable() && (typeof contentDuration === "number") && (typeof contentPlayhead === "number") && this.skipOffset.test(contentPlayhead, contentDuration)) {
            return true;
        } else {
            return false;
        }
    };

    Obj.prototype.getDuration = function () {
        return this.duration;
    };

    Obj.prototype.getSkipMS = function (adPlayhead, adDuration) {
        if (this.skipOffset) {

            var skipMS = this.skipOffset.getTriggerMS(adDuration);
            return skipMS;
        } else {
            return null;
        }
    };

    Obj.prototype.toString = function () {
        var str = "LinearCreative";
        str += "\n\t adID=" + this.adID;
        str += "\n\t id=" + this.id;
        str += "\n\t sequence=" + this.sequence;
        str += "\n\t adID=" + this.adID;
        str += "\n\t apiFramework=" + this.apiFramework;
        str += "\n\t eventTrackers=" + this.eventTrackers.length;
        str += "\n\t clickThrough=" + this.getClickThrough();
        str += "\n\t clickTrackingUrls=" + this.clickTrackers.length;
        str += "\n\t duration=" + this.duration;
        str += "\n\t mediaFiles=" + this.mediaFiles.length;
        str += "\n\t icons=" + this.icons;
        str += "\n\t skipoffset=" + this.skipOffset;

        return str;
    };

    return Obj;
})();

adfw.NonLinearCreative = (function () {
    "use strict";
    var Obj = function (options) {
        adfw.Creative.call(this, options);
        this.variations = options.variations;
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype = Object.create(adfw.Creative.prototype);
    Obj.constructor = Obj;

    Obj.prototype.toString = function () {
        var str = "NonLinearCreative";
        str += "\n\t adID=" + this.adID;
        str += "\n\t id=" + this.id;
        str += "\n\t sequence=" + this.sequence;
        str += "\n\t adID=" + this.adID;
        str += "\n\t apiFramework=" + this.apiFramework;
        str += "\n\t eventTrackers=" + this.eventTrackers.length;

        str += "\n\t variations=" + this.variations.length;

        return str;
    };

    //Gets the best variation available
    Obj.prototype.getBestVariation = function () {
        //if(!this.bestVariation) {
        this.variations.sort(adfw.NonLinearVariation.Sort);
        this.bestVariation = this.variations[0];
        //}
        return this.bestVariation;
    };

    return Obj;
})();

adfw.CompanionCreative = (function () {
    "use strict";

    var Obj = function (options) {
        adfw.Creative.call(this, options);
        this.companions = options.companions;
        this.required = options.required; //[all,any,none] Companions Ad should be displayed

        //adfw.Utils.log("CREATED: \n" + this.toString());
    };

    Obj.prototype = Object.create(adfw.Creative.prototype);
    Obj.constructor = Obj;

    Obj.prototype.toString = function () {
        var str = "CompanionCreative";
        str += "\n\t adID=" + this.adID;
        str += "\n\t id=" + this.id;
        str += "\n\t sequence=" + this.sequence;
        str += "\n\t apiFramework=" + this.apiFramework;
        str += "\n\t eventTrackers=" + this.eventTrackers.length;
        str += "\n\t companions=" + this.companions.length;
        str += "\n\t required=" + this.required;
        return str;
    };

    Obj.prototype.getRequired = function () {
        return this.required;
    };

    return Obj;
})();

//This file enumerates all of the error codes possible in the V-Suite standards and their meanings.
adfw.Errors = {
    //Codes 00-99: Framework Defined Errors
    0: "Empty or problematic VAST",
    1: "Empty or problematic VMAP",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: "",
    10: "",
    11: "",
    12: "",
    13: "",
    14: "",
    15: "",
    16: "",
    17: "",
    18: "",
    19: "",
    20: "",
    21: "",
    22: "",
    23: "",
    24: "",
    25: "",
    26: "",
    27: "",
    28: "",
    29: "",

    //Code 100+: V-SUITE Parsing errors
    100: "XML parsing error",
    101: "VAST schema validation error",
    102: "VAST version of response not supported",
    300: "General Wrapper error",
    301: "Timeout of VAST URI provided in Wrapper element, or of VAST URI provided in a subsequent Wrapper element. (URI was either unavailable or reached a timeout as defined by the video player.)",
    302: "Wrapper limit reached, as defined by the video player. Too many Wrapper responses have been received with no InLine response",
    303: "No Ads VAST response after one or more Wrappers",
    1000: "VMAP schema error",
    1001: "VMAP version of response not supported",
    1002: "VMAP parsing error",
    1004: "General ad response document error",
    1005: "Ad response template type not supported",
    1006: "Ad response document extraction or parsing error",
    1007: "Ad response document retrieval timeout",
    1008: "Ad response document retrieval error (e.g., HTTP server responded with error code)",

    //Code 100+: V-SUITE Playback errors
    200: "Trafficking error. Video player received an Ad type that it was not expecting and/or cannot display",
    201: "Video player expecting different linearity",
    202: "Video player expecting different duration",
    203: "Video player expecting different size",
    304: "InLine response returned ad unit that failed to result in ad display within defined time limit.",
    400: "General Linear error. Video player is unable to display the Linear Ad",
    401: "File not found. Unable to find Linear/MediaFile from URI",
    402: "Timeout of MediaFile URI",
    403: "Couldn't find MediaFile that is supported by this video player, based on the attributes of the MediaFile element",
    405: "Problem displaying MediaFile. Video player found a MediaFile with supported type but couldn't display it. MediaFile may include: unsupported codecs, different MIME type than MediaFile@type, unsupported delivery method, etc",
    409: "Interactive unit in the InteractiveCreativeFile node was not executed.",
    500: "General NonLinearAds error",
    501: "Unable to display NonLinear Ad because creative dimensions do not align with creative display area (i.e. creative dimension too large)",
    502: "Unable to fetch NonLinearAds/NonLinear resource",
    503: "Couldn't find NonLinear resource with supported type",
    600: "General CompanionAds error",
    601: "Unable to display Companion because creative dimensions do not fit within Companion display area (i.e., no available space)",
    602: "Unable to display Required Companion",
    603: "Unable to fetch CompanionAds/Companion resource",
    604: "Couldn't find Companion resource with supported type",
    900: "Undefined Error",
    901: "General VPAID error",
    902: "VPAID Disabled",

    //Code 1000+: VMAP Errors
    1003: "AdBreak type not supported",
};

/**
 * @brief Icon Model.
 * @details A BluePrint of Icon Model
 * @return Null
 */
adfw.Icon = (function () {
    "use strict";
    var Obj = function (options) {
        if (!options.program) {
            throw "Industry Icon MUST specify program attribute!";
        }
        if (!options.width || !options.height) {
            throw "Industry Icon MUST specify width/height!";
        }
        if (!options.xPosition || !options.yPosition) {
            throw "Industry Icon MUST specify xPosition/yPosition!";
        }
        if (!options.resources) {
            throw "Industry Icon MUST specify Resources Object!";
        }

        this.program = options.program; //(required) Identifies the industry initiative that the icon supports
        this.width = parseInt(options.width, 10); //(required) The width (in pixels) of the icon to be overlaid on the Ad
        this.height = parseInt(options.height, 10);
        this.xPosition = options.xPosition; //(required) "left", "right" or a numeric value (in pixels)
        this.yPosition = options.yPosition; //(required) "top", "bottom" or a numeric value (in pixels)
        this.resources = options.resources || [];

        this.depth = options.depth || 0; //Parsing depth, this will help determine which icon to use in case not all icons can be displayed

        //<--Optional Attribute
        this.offset = (options.offset) ? new adfw.Offset(options.offset) : null; //Start time (in HH:MM:SS or HH:MM:SS.mmm format)
        this.duration = options.duration || null; // The amount of time (in HH:MM:SS or HH:MM:SS.mmm format)

        //Optional Attribute-->

        //Ad Parameters for VPAID
        this.apiFramework = options.apiFramework;

        //??
        this.Rejected = false;
        this.Showed = false;
        this.eventTrackers = options.eventTrackers || [];
    };

    /**
     * @brief getProgram
     * @details Getter for this.program
     * @return program in STRING
     */
    Obj.prototype.getProgram = function () {
        return this.program;
    };

    /**
     * @brief getWidth
     * @details Getter for this.width
     * @return width in INTEGER
     */
    Obj.prototype.getWidth = function () {
        return this.width;
    };

    /**
     * @brief getHeight
     * @details Getter for this.height
     * @return height in INTEGER
     */
    Obj.prototype.getHeight = function () {
        return this.height;
    };

    /**
     * @brief getX
     * @details Getter for this.xPosition - "left", "right" or a numeric value (in pixels)
     * @return xPosition in STRING
     */
    Obj.prototype.getX = function () {
        return this.xPosition;
    };

    /**
     * @brief getY
     * @details Getter for this.xPosition - "top", "bottom" or a numeric value (in pixels)
     * @return yPosition in STRING
     */
    Obj.prototype.getY = function () {
        return this.yPosition;
    };

    /**
     * @brief getOffset
     * @details Getter for this.offset
     * @return offset in STRING
     */
    Obj.prototype.getOffset = function () {
        return this.offset;
    };

    /**
     * @brief getDuration
     * @details Getter for this.duration
     * @return duration in STRING
     */
    Obj.prototype.getDuration = function () {
        return this.duration;
    };

    /**
     * @brief getDuration
     * @details Getter for this.duration
     * @return duration in STRING
     */
    Obj.prototype.getResources = function () {
        return this.resources || [];
    };

    var PriorityMap = {
        STATIC_IMAGE: 1,
        HTML: 2,
        IFRAME: 3,
        STATIC_JS: 4,
        STATIC_FLASH: 5
    };

    var resourceComparer = function (a, b) {
        var ap = PriorityMap[a.type];
        var bp = PriorityMap[b.type];
        if (!bp) {
            return 1;
        }
        if (!ap) {
            return -1;
        }
        return ap - bp;
    };

    Obj.prototype.getPriorityIconResource = function () {
        if (!this.resources) {
            return null;
        }
        if (!this._priorityResource) {
            this._priorityResource = function () {
                //Sort the Object with priority map
                this.resources.sort(resourceComparer);
                this.resources[0].getCompiledHtmlElement(this);

                return this.resources[0];
            }.call(this);
        }
        return this._priorityResource;
    };


    Obj.prototype.handleEvent = function (id, adPlayhead, adDuration, contentPlayhead, adAssetURI) {
        this.eventTrackers.forEach(function (tracker) {
            if (tracker.shouldFire(id, adPlayhead, adDuration)) {
                tracker.fireTracker(contentPlayhead, adAssetURI);
            }
        });
    };

    return Obj;
})();

/**
 * @brief IconResource Model.
 * @details A BluePrint of IconResource Model
 * @return Null
 */
adfw.IconResource = (function () {
    "use strict";
    var Obj = function (options) {
        if (!options.content) {
            throw "Icon MUST specify content";
        } else if (!options.resourceCategory) {
            throw "Icon Static Resource MUST specify TYPE";
        } else if ("STATIC" == options.resourceCategory && !options.creativeType) {
            throw "Icon Static Resource MUST specify creativeType";
        }
        //(required)
        this.content = options.content;

        //(required) [STATIC,IFRAME,HTML]
        this.resourceCategory = options.resourceCategory;

        //(required only if StaticResource [IMAGE,JS,FLASH]
        this.creativeType = function (creativeType) {
            if (!creativeType) return null;
            if ((/javascript/gi).test(creativeType)) {
                return "JS";
            } else if ((/flash/gi).test(creativeType)) {
                return "FLASH";
            } else {
                return "IMAGE";
            }
        }(options.creativeType);

        /** Clickthrough and clicktracking information */
        /** (required only if StaticResource  */
        this.clickThrough = options.clickThrough;
        this.clickTrackers = options.clickTrackers;
        this.viewTrackers = options.viewTrackers;

        this.asset_url = ""; //For Tracking use
        this.type = function (_this) {
            if (!_this.creativeType) {
                return _this.resourceCategory;
            } else {
                return _this.resourceCategory + "_" + _this.creativeType;
            }
        }(this);
    };

    var PriorityMap = {
        STATIC_IMAGE: 1,
        HTML: 2,
        IFRAME: 3,
        STATIC_JS: 4,
        STATIC_FLASH: 5
    };

    Obj.prototype.getContent = function () {
        return this.content;
    }

    Obj.prototype.getCompiledHtmlElement = function (icon) {


        if (!this.content) {
            return null;
        }
        if (!this.compiledElement) {
            this.compiledElement = function () {

                if (this.type == "HTML") {
                    return this.content;
                } else if (this.type == "STATIC_IMAGE") {
                    this.asset_url = this.content;
                    return function () {
                        return "<a href='#' class='companionAdStaticResource' data-clickThrough='" + this.clickThrough + "'>" + "<img src='" + this.content + "' width='" + icon.getWidth() + "' height='" + icon.getHeight() + "' />" + "</a>";
                    }.call(this);

                } else if (this.type == "IFRAME") {
                    this.asset_url = this.content;
                    return function (content) {
                        return "<iframe src='" + this.content + "' width='" + icon.getWidth() + "' height='" + icon.getHeight() + "'></iframe>";
                    }.call(this);
                } else if (this.type == "STATIC_JS") {
                    this.asset_url = this.content;
                    return function (content) {
                        return "<script src='" + this.content + "'><script>";
                    }.call(this);
                } else if (this.type == "STATIC_FLASH") {
                    this.asset_url = this.content;
                    return this.content;
                }

                return this.content;

            }.call(this);
        }
        return this.compiledElement;
    }
    Obj.prototype.getResourceCategory = function () {
        return this.resourceCategory;
    }
    Obj.prototype.getCreativeType = function () {
        return this.creativeType;
    };
    Obj.prototype.getClickThrough = function () {
        return this.clickThrough;
    }
    Obj.prototype.getClickTrackers = function () {
        return this.clickTrackers;
    }
    Obj.prototype.getType = function () {
        return this.type;
    };

    //On click, fire all click trackers
    Obj.prototype.handleClick = function () {
        if (!this.clickTrackers) {
            return;
        }
        for (var i = 0; i < this.clickTrackers.length; i++) {
            this.clickTrackers[i].fireTracker(adfw.Controller.getState().currentContentPlayhead(), this.content);
        }
    };
    //On Show, fire all View trackers
    Obj.prototype.handleDisplay = function () {
        if (!this.viewTrackers) {
            return;
        }
        for (var i = 0; i < this.viewTrackers.length; i++) {
            this.viewTrackers[i].fireTracker(adfw.Controller.getState().currentContentPlayhead(), this.content);
        }
    };
    return Obj;
})();

adfw.LinearMediaFile = (function () {
    "use strict";
    var Obj = function (options) {
        //Required variables
        this._url = options.url;
        this._fixedUrl = options.url;
        this._urlPostfix = "";
        this.mimeType = options.type;
        this.width = options.width;
        this.height = options.height;
        this.isInteractiveCreativeFile = options.isInteractiveCreativeFile;
        
        this.delivery = options.delivery ? options.delivery.toLowerCase() : null; //This String should be either "PROGRESSIVE" or "STREAMING"
        if (this.delivery != 'progressive' && this.delivery != 'streaming') {
            this.delivery = null;
        }

        if (adfw.Utils.isFlashMIME(this.mimeType)) {
            this._type = Obj.Types.FLASH;
        }
        else if (this.delivery == "progressive") {
            this._type = Obj.Types.PROGRESSIVE;
        }
        else {
            if (adfw.Utils.isSmoothMIME(this.mimeType) || adfw.Utils.isXMLMIME(this.mimeType)) {
                this._type = Obj.Types.SMOOTH;
                this._urlPostfix = "|COMPONENT=SMOOTH";
                this._fixedUrl += this._urlPostfix;
            }
            else if (adfw.Utils.isHLSMIME(this.mimeType)) {
                this._type = Obj.Types.HLS;
                this._urlPostfix = "|COMPONENT=HLS";
                this._fixedUrl += this._urlPostfix;
            }
            else if (adfw.Utils.isDASHMIME(this.mimeType)) {
                this._type = Obj.Types.DASH;
                this._urlPostfix = "|COMPONENT=HAS";
                this._fixedUrl += this._urlPostfix;
            }
        }

        //Variables required for linear skip
        if (typeof options.skipoffset === "string" && options.skipoffset) {
            this.skipoffset = new adfw.Offset(options.skipoffset);
        }
        else {
            this.skipoffset = null;
        }

        //Optional variables
        this.scalable = options.scalable;
        this.bitrate = parseInt(options.bitrate, 10);
        this.maxBitrate = parseInt(options.maxBitrate, 10);
        this.minBitrate = parseInt(options.minBitrate, 10);
        this.codec = options.codec;
        this.apiFramework = options.apiFramework;
        this.maintainAspectRatio = options.maintainAspectRatio;

        //adfw.Utils.log("CREATED: " + this.toString());
    };

    Obj.Types = {
        PROGRESSIVE: "PROGRESSIVE",
        HLS: "HLS",
        SMOOTH: "SMOOTH",
        DASH: "DASH",
        FLASH: "FLASH"
    };

    Obj.prototype.getBitrate = function () {
        if (this.bitrate) {
            return this.bitrate;
        }
        else if (this.maxBitrate && this.minBitrate) {
            try {
                return (this.maxBitrate + this.minBitrate) / 2;
            }
            catch (e) {
            }
        }
        return null;
    };
    Obj.prototype.getMIMEType = function () {
        return this.mimeType;
    };
    Obj.prototype.getUrl = function () {
        return this._url;
    };
    Obj.prototype.getUrlPostfix = function () {
        return this._urlPostfix;
    };
    Obj.prototype.getFixedUrl = function () {
        var player = adfw.Controller.getPlayer();
        if (player) {
            var type = player.getAdapterType();
            if (type === adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF) {
                return this._fixedUrl;
            }
        }

        return this._url;
    };
    Obj.prototype.isHLS = function () {
        return this.getType() === Obj.Types.HLS;
    };
    Obj.prototype.isSmooth = function () {
        return this.getType() === Obj.Types.SMOOTH;
    };
    Obj.prototype.isDASH = function () {
        return this.getType() === Obj.Types.DASH;
    };
    Obj.prototype.isProgressive = function () {
        return this.getType() === Obj.Types.PROGRESSIVE;
    };
    Obj.prototype.isJavaScript = function () {
        return adfw.Utils.isJSMIME(this.mimeType);
    };
    Obj.prototype.getType = function () {
        return this._type;
    };

    Obj.prototype.toString = function () {
        var str = "Linear Media File";
        str += "\n\t url=" + this._url;
        str += "\n\t type=" + this.getType();
        str += "\n\t mime=" + this.getMIMEType();
        str += "\n\t width=" + this.width;
        str += "\n\t height=" + this.height;
        str += "\n\t delivery=" + this.delivery;

        str += "\n\t skipoffset=" + this.skipoffset;
        str += "\n\t scalable=" + this.scalable;
        str += "\n\t bitrate=" + this.bitrate;
        str += "\n\t maxBitrate=" + this.maxBitrate;
        str += "\n\t minBitrate=" + this.minBitrate;
        str += "\n\t codec=" + this.codec;
        str += "\n\t apiFramework=" + this.apiFramework;
        str += "\n\t maintainAspectRatio=" + this.maintainAspectRatio;


        return str;
    };

    return Obj;
})();

adfw.NonLinearVariation = (function () {
    "use strict";
    var Obj = function (options) {
        this.id = options.id;

        this.width = parseInt(options.width, 10);
        this.height = parseInt(options.height, 10);
        if (this.width === null || this.height === null || isNaN(this.width) || isNaN(this.height)) {
            throw "NonLinear Ad MUST specify width/height!";
        }

        this.expandedWidth = parseInt(options.expandedWidth, 10); //Max allowable width
        this.expandedHeight = parseInt(options.expandedHeight, 10); //Max allowable height
        if (this.expandedHeight === null || isNaN(this.expandedHeight)) {
            this.expandedWidth = null;
        }
        if (this.expandedHeight === null || isNaN(this.expandedHeight)) {
            this.expandedHeight = null;
        }

        //Are we allowed to scale this guy?
        if (typeof options.scalable === "string") {
            this.scalable = adfw.Utils.parseBoolean(options.scalable);
        }
        else if (typeof options.scalable === "boolean") {
            this.scalable = options.scalable;
        }
        else {
            this.scalable = true;
        }

        //If we scale this guy, do we need to maintain aspect ratio?
        if (typeof options.maintainAspectRatio === "string") {
            this.maintainAspectRatio = adfw.Utils.parseBoolean(options.maintainAspectRatio);
        }
        else if (typeof options.maintainAspectRatio === "boolean") {
            this.maintainAspectRatio = maintainAspectRatio.scalable;
        }
        else {
            this.maintainAspectRatio = true;
        }

        //Minimum suggested duration - convert to MS
        this.minSuggestedDuration = null;
        if (options.minSuggestedDuration) {
            if (typeof options.minSuggestedDuration === "number") {
                this.minSuggestedDuration = options.minSuggestedDuration;
            }
            else if (typeof options.minSuggestedDuration === "string") {
                this.minSuggestedDuration = adfw.Utils.convertHMS(options.minSuggestedDuration);
            }
        }
        if (!this.minSuggestedDuration) {
            this.minSuggestedDuration = 0;
        }

        //The resources
        if (!options.resources) {
            throw "No NonLinear resources detected";
        }
        this.resources = options.resources;
        this.bestResource = null;

        //Clickthrough and clicktracking information
        this.clickThrough = options.clickThrough;
        this.clickTrackers = options.clickTrackers;

        //Ad Parameters for VPAID
        this.apiFramework = options.apiFramework;
        this.adParameters = options.adParameters;
    };

    //Sort function
    Obj.Sort = function (a, b) {
        //VPAID gets first priority because it is cool
        if (a.apiFramework && a.apiFramework.toLowerCase() === "vpaid" && !b.apiFramework) {
            return -1;
        }
        if (b.apiFramework && b.apiFramework.toLowerCase() === "vpaid" && !a.apiFramework) {
            return 1;
        }

        //If there is an API Framework that is NOT VPAID, it gets last priority
        if (a.apiFramework && !b.apiFramework) {
            return 1;
        }
        if (b.apiFramework && !a.apiFramework) {
            return -1;
        }

        //Flash also always gets last priority
        if (a.getType() === adfw.NonLinearResource.ResourceType.STATIC_FLASH && b.getType() !== a.getType()) {
            return 1;
        }
        if (b.getType() === adfw.NonLinearResource.ResourceType.STATIC_FLASH && b.getType() !== a.getType()) {
            return -1;
        }

        //Static images get second priority because they're least prone to error
        if (a.getType() === adfw.NonLinearResource.ResourceType.STATIC_IMAGE && b.getType() !== a.getType()) {
            return -1;
        }
        if (b.getType() === adfw.NonLinearResource.ResourceType.STATIC_IMAGE && b.getType() !== a.getType()) {
            return 1;
        }

        //If none of the above, then let's compare by dimensions.
        try {

            var playerDimensions = {
                x: 0,
                y: 0,
                w: 1280,
                h: 720
            };
            try {
                playerDimensions = adfw.Controller.getPlayer().getDisplayRect();
            } catch (e) {
            }
            //I want the height to be as close to 20% of the player's dimensions as possible without going over that.
            if (a.getHeight() !== b.getHeight()) {
                var playerHeight = playerDimensions.h;
                var ratioA = a.getHeight() / playerHeight;
                var ratioB = b.getHeight() / playerHeight;
                if (ratioB > 0.22 && ratioA <= 0.2) {
                    return -1;
                } //If either is over 22%, prioritize the smaller
                if (ratioA > 0.22 && ratioB <= 0.2) {
                    return 1;
                } //If either is over 22%, prioritize the smaller
                if (ratioA > 0.2 && ratioB > 0.2) {
                    return (ratioA < ratioB) ? -1 : 1;
                } //If A and B are over 20% height, return the smallest
                return (ratioA > ratioB) ? -1 : 1; //If none of the above apply, return the largest
            }
            //If the heights are equal, let's compare by width - the closest to the player's width without going over
            else if (a.getWidth() !== b.getWidth()) {
                var playerWidth = playerDimensions.w;
                if (a.getWidth() > playerWidth && b.getWidth() <= playerWidth) {
                    return 1;
                } //If A is over and B is not, return B
                if (b.getWidth() > playerWidth && a.getWidth() <= playerWidth) {
                    return -1;
                } //If B is over and A is not, return A
                if (a.getWidth() > playerWidth && b.getWidth() > playerWidth) {
                    return (a.getWidth() < b.getWidth()) ? -1 : 1;
                } //If both are over, return the smaller
                return (a.getWidth() > b.getWidth()) ? -1 : 1;//If none of the above apply, return the largest
            }
            //OK if we can't compare by height or width, let's try again with type priority:
            else {
                var ap = adfw.NonLinearResource.PriorityMap[a.getType()];
                var bp = adfw.NonLinearResource.PriorityMap[b.getType()];
                if (!bp) {
                    return 1;
                }
                if (!ap) {
                    return -1;
                }
                return ap - bp;
            }
        }
        catch (e) {
            adfw.Utils.error("error while sorting nonlinear: " + e);
            return 0;
        }
    };

    //On click, fire all click trackers
    Obj.prototype.handleClick = function () {
        if (!this.clickTrackers) {
            return;
        }
        for (var i = 0; i < this.clickTrackers.length; i++) {
            this.clickTrackers[i].fireTracker(adfw.Controller.getState().currentContentPlayhead(), this.getBestResource().getResource());
        }
    };

    //Calculates the proper display time of the nonlinear. It takes the larger of the minSuggestedDuration and default display time, but keeps it underneath the maximum.
    Obj.prototype.calculateDisplayTime = function () {
        var dur = this.getMinimumSuggestedDuration() || 0;
        var displayTime = Math.max(dur, adfw.Config.get("NONLINEAR_DEFAULT_DISPLAY_TIME"));
        displayTime = Math.min(displayTime, adfw.Config.get("NONLINEAR_MAXIMUM_DISPLAY_TIME"));
        return displayTime;
    };

    //Gets the best resource available to this variation
    Obj.prototype.getBestResource = function () {
        if (!this.bestResource) {
            this.resources.sort(adfw.NonLinearResource.Sort);
            this.bestResource = this.resources[0];
        }
        return this.bestResource;
    };

    Obj.prototype.isScalable = function () {
        return this.scalable;
    };

    Obj.prototype.shouldMaintainAspectRatio = function () {
        return this.maintainAspectRatio;
    };

    Obj.prototype.getMinimumSuggestedDuration = function () {
        return this.minSuggestedDuration || 0;
    };

    Obj.prototype.getWidth = function () {
        return this.width;
    };

    Obj.prototype.getHeight = function () {
        return this.height;
    };

    Obj.prototype.getExpandedWidth = function () {
        return this.expandedWidth;
    };

    Obj.prototype.getExpandedHeight = function () {
        return this.expandedHeight;
    };

    Obj.prototype.getType = function () {
        return this.getBestResource().type;
    };

    Obj.prototype.getClickThrough = function () {
        if (this.clickThrough && this.clickThrough.length > 1) {
            return this.clickThrough;
        }
        else {
            return null;
        }
    };

    Obj.prototype.toString = function () {
        var str = "NonLinearVariation";
        str += "\n\t width=" + this.getWidth();
        str += "\n\t height=" + this.getHeight();
        str += "\n\t expandedWidth=" + this.getExpandedWidth();
        str += "\n\t expandedHeight=" + this.getExpandedHeight();
        str += "\n\t scalable=" + this.isScalable();
        str += "\n\t maintainAspectRatio=" + this.shouldMaintainAspectRatio();
        str += "\n\t minSuggestedDuration=" + this.getMinimumSuggestedDuration();
        str += "\n\t resources=" + this.resources.length;
        str += "\n\t clickThrough=" + this.getClickThrough();
        str += "\n\t clickTrackingUrls=" + this.clickTrackers.length;
        str += "\n\t apiFramework=" + this.apiFramework;
        str += "\n\t adParameters=" + this.adParameters;

        return str;
    };

    return Obj;
})();


adfw.NonLinearResource = (function () {
    "use strict";
    var Obj = function (options) {
        this.resource = options.resource;
        this.type = options.type;
    };

    Obj.ResourceType = {
        STATIC_IMAGE: "STATIC_IMAGE",
        STATIC_JS: "STATIC_JS",
        STATIC_FLASH: "STATIC_FLASH",
        IFRAME: "IFRAME",
        HTML: "HTML"
    };
    Obj.PriorityMap = {
        STATIC_IMAGE: 1,
        HTML: 2,
        IFRAME: 3,
        STATIC_JS: 4,
        STATIC_FLASH: 5
    };
    Obj.Sort = function (a, b) {
        var ap = Obj.PriorityMap[a.type];
        var bp = Obj.PriorityMap[b.type];
        if (!bp) {
            return 1;
        }
        if (!ap) {
            return -1;
        }
        return ap - bp;
    };

    Obj.prototype.getType = function () {
        return this.type;
    };
    Obj.prototype.getResource = function () {
        return this.resource;
    };

    Obj.prototype.toString = function () {
        var str = "NonLinearResource";
        str += "\n\t type=" + this.getType();
        str += "\n\t resource=" + this.getResource();
        return str;
    };

    return Obj;
})();
adfw.Offset = (function () {
    "use strict";
    var flatTimeOffsetRegex = /\s*(\d+):(\d+):(\d+):?(\d+)?\s*/;
    var percentageOffsetRegex = /\s*(\d+)%\s*/;

    var Obj = function (offset) {
        this.originalOffsetString = offset;
        // if(typeof offset === "number") {
        // 	offset = adfw.Utils.convertMS(offset);
        // }
        this.initializeOffsetString(offset);
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };

    Obj.OffsetType = {
        STATIC_OFFSET_START: "STATIC_OFFSET_START",
        STATIC_OFFSET_END: "STATIC_OFFSET_END",
        PERCENTAGE_OFFSET: "PERCENTAGE_OFFSET",
        MILLISECOND_OFFSET: "MILLISECOND_OFFSET",
    };

    Obj.prototype.getType = function () {
        return this.type;
    };

    Obj.prototype.initializeOffsetString = function (offset) {

        if (offset === null || typeof(offset) === "undefined" || offset.toString().toLowerCase().trim() == "now") {
            this.log("Empty time offset: " + offset);
            this.type = Obj.OffsetType.MILLISECOND_OFFSET;
            this.offset = 0;
        }
        else if (flatTimeOffsetRegex.test(offset)) {
            var ms = adfw.Utils.convertHMS(offset);
            this.type = Obj.OffsetType.MILLISECOND_OFFSET;
            this.offset = ms;
            //this.log("Offset created: " + offset + " as MILLISECOND_OFFSET (" + this.offset + "--1)");
        }
        else if (percentageOffsetRegex.test(offset)) {
            var timeArray = percentageOffsetRegex.exec(offset);
            var percentage = timeArray[1];
            this.type = Obj.OffsetType.PERCENTAGE_OFFSET;
            this.offset = percentage;
            //this.log("Offset created: " + offset + " as PERCENTAGE_OFFSET");
        }
        else if (offset.toString().toLowerCase().trim() == "start") {
            this.type = Obj.OffsetType.STATIC_OFFSET_START;
            this.offset = "start";
            //this.log("Offset created: " + offset + " as STATIC_OFFSET_START");
        }
        else if (offset.toString().toLowerCase().trim() == "end") {
            this.type = Obj.OffsetType.STATIC_OFFSET_END;
            this.offset = "end";
            //this.log("Offset created: " + offset + " as STATIC_OFFSET_END");
        }
        else if (typeof offset === "number" && !isNaN(offset) && offset >= 0) {
            var ms = offset;
            this.type = Obj.OffsetType.MILLISECOND_OFFSET;
            this.offset = ms;
            //this.log("Offset created: " + offset + " as MILLISECOND_OFFSET (" + this.offset + "--2)");
        }
        else {
            throw("Unrecognized time offset format: " + offset);
        }
    };


    Obj.prototype.getOriginalOffsetString = function () {
        return this.originalOffsetString;
    };

    //Given a Playhead and Duration, returns whether or not the offset has been passed (true if offset should trigger, false if not)
    Obj.prototype.test = function (playhead, duration) {
        var decision;
        if (this.getType() === Obj.OffsetType.MILLISECOND_OFFSET) {
            //It's a milliseconds offset
            decision = playhead >= this.offset;
            return (decision);
        }
        else if (this.getType() === Obj.OffsetType.PERCENTAGE_OFFSET) {
            //It's a percentage offset
            var playheadPercentage = ((playhead / duration) * 100);
            decision = playheadPercentage >= this.offset;
            return (decision);
        }
        //For the static offsets, you actually should have the player decide when to fire. The offset can't decide for itself based on just the playhead and duration (especially for 'end', you need to know that the OnRenderingComplete event has fired.
        //But just in case someone goofs it up, the functionality is provided.
        else if (this.getType() == Obj.OffsetType.STATIC_OFFSET_START) {
            this.error("WARNING: Offset.test() called on static offset [START]. You should have the Player determine whether or not this offset should fire. Returning best guess.");
            return true;
        }
        else if (this.getType() === Obj.OffsetType.STATIC_OFFSET_END) {
            this.error("WARNING: Offset.test() called on static offset [END]. You should have the Player determine whether or not this offset should fire. Returning best guess.");
            var playheadPercentage = ((playhead / duration) * 100);
            return (playheadPercentage >= 98);
        }
    };

    //Given a Playhead and Duration, returns the Milliseconds value at which this offset can trigger. (Playhead and duration are needed in the case of a percentage or END offset)
    Obj.prototype.getTriggerMS = function (duration) {
        if (this.getType() === Obj.OffsetType.MILLISECOND_OFFSET) {
            return this.offset;
        }
        else if (this.getType() === Obj.OffsetType.PERCENTAGE_OFFSET) {
            if (typeof(duration) === 'number') {
                return ((this.offset / 100) * duration);
            }
            else {
                return Infinity;
            }
        }
        else if (this.getType() === Obj.OffsetType.STATIC_OFFSET_START) {
            return 0;
        }
        else if (this.getType() === Obj.OffsetType.STATIC_OFFSET_END) {
            if (typeof(duration) === 'number') {
                return duration;
            }
            else {
                return Infinity;
            }
        }
    };

    Obj.prototype.getTriggerMSWithoutTypecheck = function () {
        return this.offset;
    };

    Obj.prototype.toString = function () {
        if (this.getType() === Obj.OffsetType.MILLISECOND_OFFSET) {
            return this.offset + " ms";
        }
        else if (this.getType() === Obj.OffsetType.PERCENTAGE_OFFSET) {
            return this.offset + "%";
        }
        else if (this.getType() === Obj.OffsetType.STATIC_OFFSET_START) {
            return this.offset;
        }
        else if (this.getType() === Obj.OffsetType.STATIC_OFFSET_END) {
            return this.offset;
        }
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW OFFSET]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW OFFSET]");
    };

    return Obj;
})();
/*
 var tracker = new adfw.Tracker(idString, urlString);
 if(tracker.shouldFire("impression")) { tracker.fireTracker(contentPlayhead, adAssetURI) }
 */
adfw.Tracker = (function () {
    "use strict";
    var Obj = function (id, url) {
        if (!id) {
            id = "";
        }
        if (!url) {
            url = "";
        }
        this.id = id.toLowerCase();
        this.url = url;
        this.fired = false;
    };

    //Add a callback function to execute when this tracker is fired
    Obj.prototype.setCallback = function (fn) {
        this.onfire = fn;
    };

    //Fire the tracker's Url. Needs contentPlayhead, adAssetURI to replace macros.
    Obj.prototype.fireTracker = function (contentPlayhead, adAssetURI) {
        this.fired = true;
        if (this.getUrl() && this.getUrl().length > 1) {
            adfw.ServerInterface.fireTracker(this, contentPlayhead, adAssetURI);
            //var processedUrl = adfw.MacroHelper.replaceTrackingMacros(this.getUrl(), contentPlayhead, adAssetURI);
            //adfw.Utils.log("Firing tracker: ID=" + this.getID() + " Url=" + processedUrl);
            //adfw.Utils.fireTrackerUrl(processedUrl);
            //adfw.Events.dispatchEvent(adfw.Events.TRACKING_EVENT, { event: this.getID(), url: processedUrl });
        }
        //if(typeof this.onfire === "function") { this.onfire(); } //This adds the possibility of utilizing trackers for internal functionality
    };

    //Returns whether this tracker should fire or not. Playhead and duration aren't necessary unless using the OffsetTracker subclass.
    Obj.prototype.shouldFire = function (id, playhead, duration) {
        if (!id) {
            return false;
        }
        else if ((id.toLowerCase().trim() !== this.id)) {
            return false;
        }
        else {
            return true;
        }
    };

    Obj.prototype.getID = function () {
        return this.id;
    };
    Obj.prototype.getUrl = function () {
        return this.url;
    };
    Obj.prototype.isFired = function () {
        return this.fired;
    };
    Obj.prototype.unsetFired = function () {
        //adfw.Utils.log("UNSET FIRED: " + this.id);
        this.fired = false;
    };

    Obj.prototype.toString = function () {
        var str = "Tracker";
        str += "\n\t id=" + this.id;
        str += "\n\t url=" + this.url;
        str += "\n\t fired=" + this.fired;
        return str;
    };
    return Obj;
}());

//A "One Time Tracker" may only be fired once (as opposed to many times)
adfw.OneTimeTracker = (function () {
    "use strict";
    var Obj = function (id, url) {
        adfw.Tracker.call(this, id, url, true);
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype = Object.create(adfw.Tracker.prototype);
    Obj.constructor = Obj;

    //Given a AdPlayhead and AdDuration, determines whether this tracker should fire. The ID is irrelevant for an OffsetTracker, but we need it anyway because the parent class Tracker uses it.
    Obj.prototype.shouldFire = function (id, playhead, duration) {
        if (!id) {
            return false;
        }
        if (this.isFired()) {
            return false;
        }
        else if ((id.toLowerCase().trim() !== this.id)) {
            return false;
        }
        else {
            return true;
        }
    };

    Obj.prototype.toString = function () {
        var str = "OneTimeTracker";
        str += "\n\t id=" + this.id;
        str += "\n\t url=" + this.url;
        str += "\n\t fired=" + this.fired;
        return str;
    };
    return Obj;
}());
/*
 //Progress trackers fire not because of a specific event, but by a time offset.
 //Compatible trackers are: progress, firstQuartile, midpoint, thirdQuartile
 var offsetTracker = new adfw.OffsetTracker(idString, urlString, offsetString);
 if(offsetTracker.shouldFire("firstQuartile", 2500, 10000)) { offsetTracker.fireTracker(contentPlayhead, adAssetURI) }
 */
adfw.OffsetTracker = (function () {
    "use strict";
    var Obj = function (id, url, progressOffset) {
        if (!progressOffset) {
            throw("Failed to create Progress Tracker: Missing progress offset");
        }
        this.progressOffset = new adfw.Offset(progressOffset);
        adfw.Tracker.call(this, id, url, true);
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype = Object.create(adfw.Tracker.prototype);
    Obj.constructor = Obj;
    Obj.prototype.getOffset = function () {
        return this.progressOffset;
    };

    //Given a AdPlayhead and AdDuration, determines whether this tracker should fire. The ID is irrelevant for an OffsetTracker, but we need it anyway because the parent class Tracker uses it.
    Obj.prototype.shouldFire = function (id, playhead, duration) {
        if (this.isFired()) {
            return false;
        }
        var determination = this.getOffset().test(playhead, duration);
        //adfw.Utils.log("Tracker " + this.getID() + " fire decision: " + determination + " (" + playhead + "/" + duration + ")" + typeof(playhead) + " | " + typeof(duration));
        return determination;
    };

    Obj.prototype.toString = function () {
        var str = "OffsetTracker";
        str += "\n\t id=" + this.id;
        str += "\n\t url=" + this.url;
        str += "\n\t offset=" + this.progressOffset.originalOffsetString;
        str += "\n\t fired=" + this.fired;
        return str;
    };
    return Obj;
}());

//A "Click Tracker" is fired whenever a creative is clicked.
adfw.ClickTracker = (function (id, url) {
    "use strict";
    var Obj = function (id, url) {
        adfw.Tracker.call(this, id, url, true);
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype = Object.create(adfw.Tracker.prototype);
    Obj.constructor = Obj;

    //Given a AdPlayhead and AdDuration, determines whether this tracker should fire. The ID is irrelevant for an OffsetTracker, but we need it anyway because the parent class Tracker uses it.
    Obj.prototype.shouldFire = function () {
        return true;
    };

    Obj.prototype.toString = function () {
        var str = "ClickTracker";
        str += "\n\t id=" + this.id;
        str += "\n\t url=" + this.url;
        str += "\n\t fired=" + this.fired;
        return str;
    };
    return Obj;
}());

/*
 //Error trackers fire when something has gone wrong.
 var errorTracker = new adfw.ErrorTracler(urlString);
 errorTracker.fireError(errorCode, errorMessage);
 */
adfw.ErrorTracker = (function () {
    "use strict";
    var Obj = function (url) {
        if (!url) {
            throw("Failed to create error tracker: Missing tracker Url");
        }
        this.url = url;
        //adfw.Utils.log("CREATED: \n" + this.toString());
    };
    Obj.prototype.getUrl = function () {
        return this.url;
    };
    Obj.prototype.setCallback = function (fn) {
        this.onfire = fn;
    };
    Obj.prototype.fireError = function (code, message, contentPlayhead, adAssetURI) {
        adfw.ServerInterface.fireError(this, code, message, contentPlayhead, adAssetURI);
        // var processedUrl = adfw.MacroHelper.replaceErrorMacros(this.getUrl(), code, message, contentPlayhead, adAssetURI);
        // adfw.Utils.fireTrackerUrl(processedUrl);
        // adfw.Events.dispatchEvent(adfw.Events.ERROR_TRACKER, { code: code, message: message, url: processedUrl });
        // if(typeof this.onfire === "function") { this.onfire(); } //This adds the possibility of utilizing trackers for internal functionality
    };
    Obj.prototype.toString = function () {
        var str = "ErrorTracker";
        str += "\n\t url=" + this.getUrl();
        return str;
    };
    return Obj;
}());
// This class is meant to be part of the video player that interacts with the Ad.
// It takes the VPAID creative as a parameter in its contructor.
adfw.VPAIDWrapper = (function () {
    "use strict";
    /**
     * @class VPAIDWrapper
     * @description VPAIDWrapper An Interface Class between the Video Player and the VPaid Ad Unit
     * @param {Object} VPAIDCreative retrieved from invoking Ad Unit's getVPAIDAd()
     */
    var VPAIDWrapper = function (ad, creative, adProgram) {
        this.DISABLE_VPAID_LOG = true;

        this._ad = ad;

        this._creative = creative;
        this._vpaidProgram = adProgram;

        if (this._creative instanceof adfw.LinearCreative) {
            this._type = "linear";
        } else if (this._creative instanceof adfw.NonLinearCreative) {
            this._type = "nonlinear";
        } else if (this._creative instanceof adfw.CompanionCreative) {
            this._type = "companion";
        } else {
            this._type = "unknown";
            throw ("Unknown VPAID creative type");
        }

        this._hasHaltedControllerForClickToLinear = false;

        this._initTimeout();
        if (!this.checkVPAIDInterface(this._vpaidProgram)) {
            //The VPAIDCreative doesn't conform to the VPAID spec
            return;
        }
        this.setCallbacksForCreative();
    };
    VPAIDWrapper.prototype._initTimeout = function () {
        /** Minimum DisplayTime for nonlinear vpaid ad only*/
        this._displayMS = null;
        /** Store DisplayTimeOut for nonlinear vpaid ad only*/
        this._displayTimeOut = null;

        /** Store LoadingTimeOut for vpaid ad */
        /** Calling initAd() and not receiving AdLoaded event */
        this._vpaidLoadingTimeOut = null;

        /** Store StartTimeOut for vpaid ad */
        /** Calling startAd() and not receiving AdStarted event */
        this._vpaidStartTimeOut = null;

        /** Store AdLinearAdTimeOut for vpaid ad */
        this._vpaidAdLinearTimeOut = null;

        /** Store StopTimeOut for vpaid ad */
        /** Calling stopAd() and not receiving AdStopped event */
        this._vpaidStopTimeOut = null;
    };

    /**
     * @function VPAIDWrapper.log
     * @description custom log function
     * @param  {string} log log
     */
    VPAIDWrapper.prototype.log = function (log) {
        adfw.Utils.log(log, "[ADFW VPAIDWRAPPER]");
    };

    VPAIDWrapper.prototype.getInternalAd = function () {
        return this._ad;
    };

    VPAIDWrapper.prototype.getInternalCreative = function () {
        return this._creative;
    };

    /**
     * @function VPAIDWrapper.setCallbacksForCreative
     * @description This function registers the callbacks of each of the VPAIDevents
     */
    VPAIDWrapper.prototype.setCallbacksForCreative = function () {
        //The key of the object is the event name and the value is a reference to the callback function that is registered with the creative
        var callbacks = {
            AdStarted: this.onStartAd,
            AdStopped: this.onStopAd,
            AdSkipped: this.onSkipAd,
            AdLoaded: this.onAdLoaded,
            AdLinearChange: this.onAdLinearChange,
            AdSizeChange: this.onAdSizeChange,
            AdExpandedChange: this.onAdExpandedChange,
            AdSkippableStateChange: this.onAdSkippableStateChange,
            AdDurationChange: this.onAdDurationChange,
            AdRemainingTimeChange: this.onAdRemainingTimeChange,
            AdVolumeChange: this.onAdVolumeChange,
            AdImpression: this.onAdImpression,
            AdClickThru: this.onAdClickThru,
            AdInteraction: this.onAdInteraction,
            AdVideoStart: this.onAdVideoStart,
            AdVideoFirstQuartile: this.onAdVideoFirstQuartile,
            AdVideoMidpoint: this.onAdVideoMidpoint,
            AdVideoThirdQuartile: this.onAdVideoThirdQuartile,
            AdVideoComplete: this.onAdVideoComplete,
            AdUserAcceptInvitation: this.onAdUserAcceptInvitation,
            AdUserMinimize: this.onAdUserMinimize,
            AdUserClose: this.onAdUserClose,
            AdPaused: this.onAdPaused,
            AdPlaying: this.onAdPlaying,
            AdError: this.onAdError,
            AdLog: this.onAdLog
        };
        // Looping through the object and registering each of the callbacks with the creative
        for (var eventName in callbacks) {
            this._vpaidProgram.subscribe(adfw.Utils.bind(callbacks[eventName], this),
                eventName, this);
        }
    };

    /**
     * @function VPAIDWrapper.handshakeVersion @description HandshakeVersion
     */
    VPAIDWrapper.prototype.handshakeVersion = function () {
        this._vpaidVersion = this._vpaidProgram.handshakeVersion("2.0");
    };

    /**
     * @function VPAIDWrapper.initAd
     * @description Pass through for initAd - when the video player wants to call the ad
     * @param  {integer} width
     * @param  {integer} height
     * @param  {string} viewMode        ['thumbnail','normal','fullscreen']
     * @param  {integer} desiredBitrate
     * @param  {object} creativeData    [from adParameter from the VPAID XML]
     * @param  {object} environmentVars [meta data]
     */
    VPAIDWrapper.prototype.initAd = function (width, height, viewMode, desiredBitrate, creativeData, environmentVars, displayMS) {

        var self = this;
        this._displayMS = displayMS;
        this.log("Initialized: " + this._ad.uid);
        //Setting VPAID load time out from config
        adfw.VisualOverlay.bufferingVPAIDObj.isPrebuffered = true;

        var vpaidInitDeferred = new adfw.Q.defer();
        this.vpaidInitDeferred = vpaidInitDeferred;

        this._vpaidLoadingTimeOut = setTimeout(function () {
            var error = "VPAID: Not receving AdLoaded event from Ad Unit after calling initAd()";
            vpaidInitDeferred.reject(error);
            self.triggerAdError(error);
        }, adfw.Config.get("VPAID_DEFAULT_LOAD_TIMEOUT"));

        this._vpaidProgram.initAd(width, height, viewMode, desiredBitrate, creativeData, environmentVars);

        return vpaidInitDeferred.promise;

    };

    /**
     * @function VPAIDWrapper.onAdPaused
     * @description Callback for AdPaused
     */
    VPAIDWrapper.prototype.onAdPaused = function () {
        this.log("onAdPaused");
        adfw.VisualOverlay.handleVPAIDEvent("pause", this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdPlaying
     * @description Callback for AdPlaying
     */
    VPAIDWrapper.prototype.onAdPlaying = function () {
        this.log("onAdPlaying");
        adfw.VisualOverlay.handleVPAIDEvent("resume", this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdError
     * @description Callback for AdError<p><ul><li>Display "VPAID_ERROR" EVENT</li><li>Clean up Resource</li></ul></p>
     */
    VPAIDWrapper.prototype.onAdError = function (message) {
        this.log("onAdError: " + message);
        if (true === this.cleared) {
            return false;
        }
        this.clearResource();
        if (this.stopDeferred) {
            this.stopDeferred.resolve("VPAID ad stopped");
        }
        adfw.Events.dispatchEvent("VPAID_ERROR", {
            ad: this._ad,
            errorMessage: message
        });
    };

    /**
     * @function VPAIDWrapper.triggerAdError
     * @description trigger Ad Error
     */
    VPAIDWrapper.prototype.triggerAdError = function (message) {
        this.log("VPAID triggerAdError: " + message);
        this.onAdError(message);
    };

    /**
     * @function VPAIDWrapper.onAdLog
     * @description Callback for AdLog
     */
    VPAIDWrapper.prototype.onAdLog = function (message) {
        this.log("onAdLog: " + message);
    };

    /**
     * @function VPAIDWrapper.onAdUserAcceptInvitation
     * @description Callback for AdUserAcceptInvitation
     */
    VPAIDWrapper.prototype.onAdUserAcceptInvitation = function () {
        this.log("onAdUserAcceptInvitation");
        adfw.VisualOverlay.handleVPAIDEvent("acceptInvitation", this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdUserMinimize
     * @description Callback for AdUserMinimize
     */
    VPAIDWrapper.prototype.onAdUserMinimize = function () {
        this.log("onAdUserMinimize");
        adfw.VisualOverlay.handleVPAIDEvent("collapse", this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdUserClose
     * @description Callback for AdUserClose
     */
    VPAIDWrapper.prototype.onAdUserClose = function () {
        this.log("onAdUserClose");
        this.stopAd();
        adfw.VisualOverlay.handleVPAIDEvent('close', this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdSkippableStateChange
     * @description Callback for AdSkippableStateChange
     */
    VPAIDWrapper.prototype.onAdSkippableStateChange = function () {
        this.log("Ad Skippable State Changed to: " + this._vpaidProgram.getAdSkippableState());
    };

    /**
     * @function VPAIDWrapper.onAdExpandedChange
     * @description Callback for AdExpandedChange
     */
    VPAIDWrapper.prototype.onAdExpandedChange = function () {
        //this.log("Ad Expanded Changed to: " + this._vpaidProgram.getAdExpanded());
        // Chris: I am not sure if we need to pause the video when the ad expands. For now I will remove it.
        // if (this._vpaidProgram.getAdExpanded()) {
        // 	adfw.Controller.pause();
        // } else {
        // 	adfw.Controller.resume();
        // }
    };

    /**
     * @function VPAIDWrapper.getAdExpanded
     * @description Pass through for getAdExpanded
     * @return {Boolean} this._vpaidProgram.getAdExpanded();
     */
    VPAIDWrapper.prototype.getAdExpanded = function () {
        this.log("getAdExpanded");
        return this._vpaidProgram.getAdExpanded();
    };

    /**
     * @function VPAIDWrapper.getAdSkippableState
     * @description Pass through for getAdSkippableState
     * @return {Boolean} this._vpaidProgram.getAdSkippableState();
     */
    VPAIDWrapper.prototype.getAdSkippableState = function () {
        this.log("getAdSkippableState");
        return this._vpaidProgram.getAdSkippableState();
    };

    /**
     * @function VPAIDWrapper.onAdSizeChange
     * @description Callback for AdSizeChange
     */
    VPAIDWrapper.prototype.onAdSizeChange = function () {
        this.log("Ad size changed to: w=" + this._vpaidProgram.getAdWidth() + "h = " + this._vpaidProgram.getAdHeight());
    };

    /**
     * @function VPAIDWrapper.onAdDurationChange
     * @description Callback for AdDurationChange
     */
    VPAIDWrapper.prototype.onAdDurationChange = function () {
        //this.log("Ad Duration Changed to: " + this.getAdDuration());
        // TODO: Update controller with info and dispatch events
        if (this.getAdDuration() > 0) {
            this.VPAIDDuration = this.getAdDuration() * 1000;
        }

        this.setupLinearTimeout();
        this.setupLinearTimeCheck();
    };

    /**
     * @function VPAIDWrapper.onAdRemainingTimeChange
     * @description Callback for AdRemainingTimeChange
     */
    VPAIDWrapper.prototype.onAdRemainingTimeChange = function () {
        //this.log("Ad Remaining Time Changed to: " + this._vpaidProgram.getAdRemainingTime());
        // TODO: Update controller with info and dispatch events
    };

    /**
     * @function VPAIDWrapper.getAdRemainingTime
     * @description Pass through for getAdRemainingTime
     * @return {string} this._vpaidProgram.getAdRemainingTime();
     */
    VPAIDWrapper.prototype.getAdRemainingTime = function () {
        var remaining = this._vpaidProgram.getAdRemainingTime();
        //this.log("getAdRemainingTime: " + remaining);
        return remaining;
    };

    /**
     * @function VPAIDWrapper.getAdDuration
     * @description Pass through for getAdDuration
     * @return {string} this._vpaidProgram.getAdDuration();
     */
    VPAIDWrapper.prototype.getAdDuration = function () {
        var duration = this._vpaidProgram.getAdDuration();
        //this.log("getAdDuration: " + duration);
        return duration;
    };

    /**
     * @function VPAIDWrapper.onAdImpression
     * @description Callback for AdImpression
     */
    VPAIDWrapper.prototype.onAdImpression = function () {
        //this.log("Ad Impression");
        adfw.VisualOverlay.handleVPAIDEvent('Impression');
    };

    /**
     * @function VPAIDWrapper.onAdClickThru
     * @description Callback for AdClickThru
     */
    VPAIDWrapper.prototype.onAdClickThru = function (url, id, playerHandles) {
        this.log("Clickthrough portion of the ad was clicked");
        this.log(url + " " + id + " " + playerHandles);
        adfw.VisualOverlay.handleVPAIDEvent('ClickTracking');
        if (!playerHandles) {
            this.log("NO AdClickThru");
            return;
        }
        adfw.VisualOverlay.setIFrameFromVPAID();
        adfw.VisualOverlay.openIFrame(url);
    };

    /**
     * @function VPAIDWrapper.onAdInteraction
     * @description Callback for AdInteraction
     */
    VPAIDWrapper.prototype.onAdInteraction = function (id) {
        var self = this;
        if (this._displayTimeOut) {
            clearTimeout(this._displayTimeOut);
        }
        if (!this._vpaidProgram.adLinear) {
            this._displayTimeOut = setTimeout(function () {
                self.stopAd();
            }, 60000);
        }
        //TODO, make the nonlinear refresh configurable
        //this.log("A non-clickthrough event has occured");
    };

    /**
     * @function VPAIDWrapper.onAdVideoStart
     * @description Callback for AdVideoStart
     */
    VPAIDWrapper.prototype.onAdVideoStart = function () {
        //this.log("Video 0% completed");
        adfw.VisualOverlay.handleVPAIDEvent("start", this.getAdRemainingTime(), this.getAdDuration());
        this.setupLinearTimeout();
    };

    /**
     * @function VPAIDWrapper.onAdVideoFirstQuartile
     * @description Callback for AdVideoFirstQuartile
     */
    VPAIDWrapper.prototype.onAdVideoFirstQuartile = function () {
        this.log("Video 25% completed");
        adfw.VisualOverlay.handleVPAIDEvent('firstQuartile', this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdVideoMidpoint
     * @description Callback for AdVideoMidpoint
     */
    VPAIDWrapper.prototype.onAdVideoMidpoint = function () {
        this.log("Video 50% completed");
        adfw.VisualOverlay.handleVPAIDEvent('midpoint', this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdVideoThirdQuartile
     * @description Callback for AdVideoThirdQuartile
     */
    VPAIDWrapper.prototype.onAdVideoThirdQuartile = function () {
        this.log("Video 75% completed");
        adfw.VisualOverlay.handleVPAIDEvent('thirdQuartile', this.getAdRemainingTime(), this.getAdDuration());
        adfw.Controller.prebufferingForVPaid();
    };

    /**
     * @function VPAIDWrapper.onAdVideoComplete
     * @description Callback for AdVideoComplete
     */
    VPAIDWrapper.prototype.onAdVideoComplete = function () {
        this.log("Video 100% completed");
        this.stopAd();
        adfw.VisualOverlay.handleVPAIDEvent('complete', this.getAdRemainingTime(), this.getAdDuration());
    };

    /**
     * @function VPAIDWrapper.onAdLinearChange
     * @description Callback for AdLinearChange
     */
    VPAIDWrapper.prototype.onAdLinearChange = function () {
        this.log("Ad linear has changed: " + this._vpaidProgram.getAdLinear());

        adfw.Events.dispatchEvent(adfw.Events.VPAID_LINEARITY_CHANGE, {
            isLinear: this._vpaidProgram.getAdLinear(),
            wrapper: this,
        });
        adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
            message: "VPAID linearity change complete",
        });

        // if(this._type === "nonlinear" && this._vpaidProgram.getAdLinear() === true) {
        // 	//adfw.Controller.haltForVPAID();

        // 	this.log("Halting controller for VPAID...");
        // 	this._hasHaltedControllerForClickToLinear = true;
        // }
        // else {
        // 	this.log("Not Halting: _type=" + this._type + " and adLinear=" + this._vpaidProgram.getAdLinear());
        // }
        this.setupLinearTimeout();
        this.setupLinearTimeCheck();
    };

    VPAIDWrapper.prototype.setupLinearTimeCheck = function () {
        var self = this;
        this.log("setupLinearTimeCheck");
        if (this.getAdLinear() === true) {
            if (!this.linearTimeCheckInterval) {
                this.linearTimeCheckInterval = setInterval(function () {
                    var duration = self.getAdDuration();
                    if (!isNaN(duration) && duration != self.VPAIDDuration) {
                        self.VPAIDDuration = duration;
                    }
                    var remaining = self.getAdRemainingTime();
                    var tempCurrentTime = parseInt((duration - remaining) * 1000, 10);
                    if (!isNaN(tempCurrentTime) && tempCurrentTime != self.currentAdLinearTime) {
                        self.currentAdLinearTime = tempCurrentTime;
                        adfw.Events.dispatchEvent(adfw.Events.VPAID_LINEAR_PLAYBACK_TIME, {
                            ms: tempCurrentTime
                        });
                    }
                }, 500);
            }
        }
        else {
            this.stopLinearTimeCheck();
        }
    };

    VPAIDWrapper.prototype.stopLinearTimeCheck = function () {
        var self = this;

        if (this.linearTimeCheckInterval) {
            clearInterval(this.linearTimeCheckInterval);
            this.linearTimeCheckInterval = null;
        }

    };

    VPAIDWrapper.prototype.setupLinearTimeout = function () {
        var self = this;
        if (this.getAdLinear() === true && this.getAdRemainingTime() > 0) {
            adfw.VisualOverlay.updateVPAIDLinearVideoCurrentPlayTime();
            //We will give the ad a few seconds to report its remaining time correctly, or it will be terminated
            //Commented this out because I didn't read the VAST spec well enough and screwed it up
            // if(this.getAdRemainingTime() < 1) {
            // 	if(this.linearAdTimeoutRetryTimer) {
            // 		clearTimeout(this.linearAdTimeoutRetryTimer);
            // 	}
            // 	this.linearAdTimeoutRetryTimer = setTimeout(function() {
            // 		if(self.getAdLinear() === true) {
            // 			if(self.getAdRemainingTime() > 0) {
            // 				self.setupLinearTimeout();
            // 			}
            // 			else {
            // 				self.triggerAdError("Linear Ad Remaining time is not being reported correctly. Terminating ad...");
            // 			}
            // 		}
            // 	}, 4000);
            // 	return false;
            // }

            var timeoutvalue = this.getAdRemainingTime() * 1000 + adfw.Config.get("VPAID_DEFAULT_ADLINEAR_TIMEOUT");

            if (!this._vpaidAdLinearTimeOut) {
                //this.log("setupLinearTimeout: create new timeout for " + timeoutvalue);
                this._vpaidAdLinearTimeOut = new adfw.Utils.Timer(function () {
                    self.log("linear ad timeout!!");
                    self.stopAd();
                }, timeoutvalue);
            } else {
                //this.log("setupLinearTimeout: update timeout for " + timeoutvalue);
                this._vpaidAdLinearTimeOut.reset(timeoutvalue);
            }

        } else if (this.getAdLinear() === false) {
            //this.log("setupLinearTimeout: clear linear timeout since adLinear has become false");
            if (this._vpaidAdLinearTimeOut) {
                this._vpaidAdLinearTimeOut.clear();
            }
        } else {
            //this.log("setupLinearTimeout: bail because adLinear is " + this.getAdLinear() + " and remaining time = " + this.getAdRemainingTime());
            //setTimeout(function () {
            //    self.setupLinearTimeout();
            //}, 1000);
        }
    };

    /**
     * @function VPAIDWrapper.getAdLinear
     * @description Pass through for getAdLinear
     * @return {Boolean} this._vpaidProgram.getAdLinear()
     */
    VPAIDWrapper.prototype.getAdLinear = function () {
        //this.log("getAdLinear");
        return this._vpaidProgram.getAdLinear();
    };

    /**
     * @function VPAIDWrapper.startAd
     * @description Pass through for startAd()
     */
    VPAIDWrapper.prototype.startAd = function () {
        var self = this;
        this.VPAIDDuration = 0;
        //this.log("startAd");

        if (!this.vpaidInitDeferred) {
            var errorMessage = "initAd() was not called... aborting.";
            this.log(errorMessage);
            return Q.reject(errorMessage);
        }
        else {
            return this.vpaidInitDeferred.promise
                .then(function () {
                    //self.log("Init complete. Starting ad...");
                    var vpaidStartDeferred = new adfw.Q.defer();
                    self.vpaidStartDeferred = vpaidStartDeferred;

                    if (self._displayMS) {
                        self._displayTimeOut = setTimeout(function () {
                            self.stopAd();
                        }, self._displayMS);
                    }
                    self._vpaidStartTimeOut = setTimeout(function () {
                        var errorMessage = "VPAID: Not receving AdStarted event from Ad Unit after calling startAd()";
                        self.triggerAdError(errorMessage);
                        vpaidStartDeferred.reject(errorMessage);
                    }, adfw.Config.get("VPAID_DEFAULT_START_TIMEOUT"));
                    self.log("startAd!!")
                    self._vpaidProgram.startAd();
                    if (self._vpaidProgram.getAdLinear() && self.getAdRemainingTime() > 0) {
                        adfw.VisualOverlay.updateVPAIDLinearVideoCurrentPlayTime();
                    }

                    return vpaidStartDeferred.promise;
                })
        }


    };

    /**
     * @function VPAIDWrapper.onAdLoaded
     * @description Callback for AdLoaded
     */
    VPAIDWrapper.prototype.onAdLoaded = function () {

        if (this.vpaidInitDeferred) {
            this.vpaidInitDeferred.resolve("VPAID Ad loaded");
        }
        if (this._vpaidLoadingTimeOut) {
            clearTimeout(this._vpaidLoadingTimeOut);
        }
        this.log("ad has been loaded: " + this._ad.uid);
        //adfw.Events.dispatchEvent(adfw.Events.VPAID_ADLOADED, {});
    };

    /**
     * @function VPAIDWrapper.onStartAd
     * @description Callback for StartAd
     */
    VPAIDWrapper.prototype.onStartAd = function () {
        if (this._vpaidStartTimeOut) {
            clearTimeout(this._vpaidStartTimeOut);
        }
        if (this.vpaidStartDeferred) {
            this.vpaidStartDeferred.resolve("VPAID Ad started");
        }
        //this.log("Ad has started");
        adfw.VisualOverlay.handleVPAIDEvent('creativeView', this.getAdRemainingTime(), this.getAdDuration());

        this.setupLinearTimeout();
        this.setupLinearTimeCheck();
    };

    /**
     * @function VPAIDWrapper.stopAd
     * @description Pass through for stopAd()
     */
    VPAIDWrapper.prototype.stopAd = function () {
        var self = this;

        this.stopDeferred = adfw.Q.defer();

        this._vpaidStopTimeOut = setTimeout(function () {
            self.triggerAdError("VPAID: Not receving AdStopped event from Ad Unit after calling stopAd()");
        }, adfw.Config.get("VPAID_DEFAULT_STOP_TIMEOUT"));
        this._vpaidProgram.stopAd();
        this.stopLinearTimeCheck();

        return this.stopDeferred.promise;
    };

    /**
     * @function VPAIDWrapper.onStopAd
     * @description Callback for StopAd
     */
    VPAIDWrapper.prototype.onStopAd = function () {
        this.stopLinearTimeCheck();
        if (true === this.cleared) {
            return false;
        }
        if (this._vpaidStopTimeOut) clearTimeout(this._vpaidStopTimeOut);
        this.log("Ad has stopped");
        this.clearResource();
        if (this._hasHaltedControllerForClickToLinear === true) {
            adfw.Controller.resumeFromMidroll();
        }
        if (this.stopDeferred) {
            this.stopDeferred.resolve("VPAID ad stopped");
        }
        adfw.Events.dispatchEvent("VPAID_COMPLETE", {
            ad: this._ad
        });
    };

    /**
     * @function VPAIDWrapper.onSkipAd
     * @description Callback for SkipAd
     */
    VPAIDWrapper.prototype.onSkipAd = function () {
        if (true === this.cleared) {
            return false;
        }
        this.log("Ad was skipped: " + this._ad.uid);
        adfw.VisualOverlay.handleVPAIDEvent('skip', this.getAdRemainingTime(), this.getAdDuration());
        this.clearResource();
        if (this._hasHaltedControllerForClickToLinear === true) {
            adfw.Controller.resumeFromMidroll();
        }
        adfw.Events.dispatchEvent("VPAID_COMPLETE", {
            ad: this._ad
        });
    };

    /**
     * @function VPAIDWrapper.skipAd
     * @description Pass through for skipAd
     */
    VPAIDWrapper.prototype.skipAd = function () {
        if (typeof this._vpaidProgram.getAdSkippableState !== 'undefined' && typeof this._vpaidProgram.skipAd !== 'undefined') {
            if (this._vpaidProgram.getAdSkippableState() === true) {
                this._vpaidProgram.skipAd();
            } else {
                this.log("VPAID Ad cannot be skipped");
            }
        } else {
            this.log("VPAID Ad cannot be skipped");
        }
    };

    /**
     * @function VPAIDWrapper.setAdVolume
     * @description Pass through for setAdVolume()
     */
    VPAIDWrapper.prototype.setAdVolume = function (val) {
        this._vpaidProgram.setAdVolume(val);
    };

    /**
     * @function VPAIDWrapper.getAdVolume
     * @description Pass through for getAdVolume()
     */
    VPAIDWrapper.prototype.getAdVolume = function () {
        return this._vpaidProgram.getAdVolume();
    };

    /**
     * @function VPAIDWrapper.onAdVolumeChange
     * @description Callback for AdVolumeChange
     */
    VPAIDWrapper.prototype.onAdVolumeChange = function () {
        this.log("Ad Volume has changed to - " + this._vpaidProgram.getAdVolume());
        if (this._vpaidProgram.getAdVolume() === 0) {
            adfw.VisualOverlay.handleVPAIDEvent('mute', this.getAdRemainingTime(), this.getAdDuration());
        } else if (this._vpaidProgram.getAdVolume() > 0) {
            adfw.VisualOverlay.handleVPAIDEvent('unmute', this.getAdRemainingTime(), this.getAdDuration());
        }
    };

    /**
     * @function VPAIDWrapper.resizeAd
     * @description Pass through for resizeAd()
     */
    VPAIDWrapper.prototype.resizeAd = function (width, height, viewMode) {
        this._vpaidProgram.resizeAd(width, height, viewMode);
    };

    /**
     * @function VPAIDWrapper.pauseAd
     * @description Pass through for pauseAd()
     */
    VPAIDWrapper.prototype.pauseAd = function () {
        this._vpaidProgram.pauseAd();
        if (this._vpaidAdLinearTimeOut) {
            this._vpaidAdLinearTimeOut.pause();
        }
    };

    /**
     * @function VPAIDWrapper.resumeAd
     * @description Pass through for resumeAd()
     */
    VPAIDWrapper.prototype.resumeAd = function () {
        this._vpaidProgram.resumeAd();
        if (this._vpaidAdLinearTimeOut) {
            this._vpaidAdLinearTimeOut.resume();
        }
    };

    /**
     * @function VPAIDWrapper.expandAd
     * @description Pass through for expandAd()
     */
    VPAIDWrapper.prototype.expandAd = function () {
        this._vpaidProgram.expandAd();
    };

    /**
     * @function VPAIDWrapper.collapseAd
     * @description Pass through for collapseAd()
     */
    VPAIDWrapper.prototype.collapseAd = function () {
        this._vpaidProgram.collapseAd();
    };

    /**
     * @function VPAIDWrapper.clearResource
     * @description Calling @Class{VisualOverlay} to clean up resource
     */
    VPAIDWrapper.prototype.clearResource = function () {
        this.cleared = true;
        this.log("clean resource: " + this._ad.uid);
        if (this._displayTimeOut) clearTimeout(this._displayTimeOut);
        if (this._vpaidLoadingTimeOut) clearTimeout(this._vpaidLoadingTimeOut);
        if (this._vpaidStartTimeOut) clearTimeout(this._vpaidStartTimeOut);
        if (this._vpaidStopTimeOut) clearTimeout(this._vpaidStopTimeOut);
        if (this._vpaidAdLinearTimeOut) this._vpaidAdLinearTimeOut.clear();
        adfw.VisualOverlay.VPAIDClean();

        //Chris: Need to move this somewhere more logical
        //adfw.Controller.resume();
    };
    /**
     * @function VPAIDWrapper.checkVPAIDInterface
     * @description Checking if input is a valid VPAIDCreative
     * @param  {object} VPAIDCreative
     * @return {boolean}
     */
    VPAIDWrapper.prototype.checkVPAIDInterface = function (VPAIDCreative) {
        if (
            typeof VPAIDCreative.handshakeVersion == "function" &&
            typeof VPAIDCreative.initAd == "function" &&
            typeof VPAIDCreative.startAd == "function" &&
            typeof VPAIDCreative.stopAd == "function" &&
            typeof VPAIDCreative.skipAd == "function" &&
            typeof VPAIDCreative.resizeAd == "function" &&
            typeof VPAIDCreative.pauseAd == "function" &&
            typeof VPAIDCreative.resumeAd == "function" &&
            typeof VPAIDCreative.expandAd == "function" &&
            typeof VPAIDCreative.collapseAd == "function" &&
            typeof VPAIDCreative.subscribe == "function" &&
            typeof VPAIDCreative.unsubscribe == "function") {
            return true;
        }
        return false;
    };
    return VPAIDWrapper;
})();

adfw.DisplayHandler = (function () {
    "use strict";
    var Obj = function () {
    };

    Obj.prototype.init = function () {
        adfw.VisualOverlay.init();
        this.initIFramePauseLogic();
        this.initLinearIconsLogic();
    };

    //Register event listeners that pause the video upon iframe open, and resumes the video upon iframe close
    Obj.prototype.initIFramePauseLogic = function () {
        adfw.Events.addListener(adfw.Events.IFRAME_OPEN, function (evt, params) {
            try {
                adfw.Controller.handleIFrameOpen();
            }
            catch (e) {
                adfw.Utils.log("Error: " + e, "[ADFW DISPLAYHANDLER]");
            }
        });
        adfw.Events.addListener(adfw.Events.IFRAME_CLOSE, function (evt, params) {
            if (!params.overwritePause) {
                adfw.Controller.handleIFrameClose();
            }
        });
    };

    Obj.prototype.initLinearIconsLogic = function () {
        adfw.Events.addListener(adfw.Events.LINEAR_AD_START, function (evt, params) {
            if (!params.icons || adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.DISABLED || false === adfw.Config.ICONS_ENABLED) {
                return false;
            }
            adfw.VisualOverlay.loadLinearIcons(params.icons);
        });
        adfw.Events.addListener(adfw.Events.LINEAR_AD_END, function (evt, params) {
            adfw.VisualOverlay.destroyLinearIcons();
        });
    };
    return new Obj();
})();
adfw.VisualOverlay = (function () {
    "use strict";
    var Obj = function () {
        try {
            this.widgetAPI = new Common.API.Widget();
        } catch (e) {
            this.widgetAPI = null;
        }
    };

    Obj.prototype.init = function () {
	this.log("init");
        if (this._alreadyInitialized) {
            return false;
        }
        this._alreadyInitialized = true;
        var self = this;
        this.initIFrameUI();
        this.initLinearIconUI();
        this.initNonLinearUI();
        this.initVPAIDUI();
        adfw.Controller.getPlayer().addListener(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, function (evt, params) {
            self.scaleUI.call(self, evt, params);
        });
        adfw.Events.addListener(adfw.Events.LINEAR_AD_START, function (evt, params) {
            self.hideNonLinearAd.call(self, true);
        });
    };

    //Given a set of dimensions in 960x540 format (e.g. from the PlayerAdapter), converts them up to true window scale, and then scales all current UI to fit the new dimensions.
    Obj.prototype.scaleUI = function (evt, params) {
        this.log("scaleUI");
        if (params) {
            this.scaledDimms = params;
        } else {
            try {
                this.scaledDimms = adfw.Controller.getPlayer().getDisplayRect();
            } catch (e) {
                this.error(e);
            }
        }
        if (!this.scaledDimms) {
            return false;
        }

        //Scale and reposition all related VisualOverlay components
        this.scaleNonLinearAd(this.scaledDimms);
        this.positionNonLinearAd(this.scaledDimms);
        this.scaleLinearIcons(this.scaledDimms);
        this.positionLinearIcons(this.scaledDimms);
        this.positionVPAID(this.scaledDimms);
        this.scaleVPAID(this.scaledDimms);
    };

    //***************************************** IFRAME *****************************************

    //Create the iFrame, its overlay, and its close button
    Obj.prototype.initIFrameUI = function () {
        this.log("initIFrameUI");
        var self = this;

        this.iframeContainer = document.createElement("div");
        this.iframeOverlay = document.createElement("div");
        this.iframeCloseButton = document.createElement("div");
        this.iframeWindow = document.createElement("iframe");

        this.iframeContainer.className = "adfw-visualoverlay-iframe-container";
        this.iframeOverlay.className = "adfw-visualoverlay-iframe-overlay";
        this.iframeCloseButton.className = "adfw-visualoverlay-iframe-closebutton";
        this.iframeWindow.className = "adfw-visualoverlay-iframe-window";
        this.iframeWindow.sandbox = "";

        this.iframeContainer.appendChild(this.iframeOverlay);
        this.iframeContainer.appendChild(this.iframeCloseButton);
        this.iframeContainer.appendChild(this.iframeWindow);

        var closeOnClickFunc = function () {
            self.closeIFrame();
        };

        this.iframeCloseButton.addEventListener("click", closeOnClickFunc);
        this.iframeOverlay.addEventListener("click", closeOnClickFunc);
        this.closeIFrame();
        document.body.appendChild(this.iframeContainer);
    };

    //Get the current Url of the iFrame
    Obj.prototype.getIFrameSrc = function () {
        return this.iframeWindow.src;
    };

    //Show the iFrame and set its SRC to the given Url.
    Obj.prototype.openIFrame = function (src) {
        this.log("openIFrame");
        if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.DISABLED) {
            return false;
        }
        try {
            this.iframeWindow.src = src;
            this.iframeContainer.style.display = "block";
            this.iframeWindow.focus();
            adfw.Events.dispatchEvent(adfw.Events.IFRAME_OPEN, {
                src: src
            });
            return true;
        } catch (e) {
        }
        return false;
    };

    //Close the iFrame
    Obj.prototype.closeIFrame = function () {
    	this.log("closeIFrame");
        try {
            this.iframeContainer.style.display = "none";
            this.iframeWindow.src = "";
            if (this.iframeWindow.isVPAID) {
                adfw.Events.dispatchEvent(adfw.Events.IFRAME_CLOSE, {
                    overwritePause: true
                });
            } else {
                adfw.Events.dispatchEvent(adfw.Events.IFRAME_CLOSE);
            }
        } catch (e) {
        }
    };

    Obj.prototype.setIFrameSandboxParameters = function (str) {
        this.log("setIFrameSandboxParameters");
        if (str) {
            this.iframeWindow.sandbox = str;
        } else {
            this.iframeWindow.sandbox = "";
        }
    };

    Obj.prototype.setIFrameFromVPAID = function () {
	this.log("setIFrameFromVPAID");
        this.iframeWindow.isVPAID = true;
    };
    //***************************************** VPAID IFRAME *****************************************
    Obj.prototype.initVPAIDUI = function () {
    	this.log("initVPAIDUI");
        this.vpaidContainer = document.createElement("div");
        this.vpaidContainer.className = "adfw-visualoverlay-vpaidframe adfw-visualoverlay-hidden";
        this.vpaidContainer.id = "vc1";
        document.body.appendChild(this.vpaidContainer);

        this.vpaidContainer_2 = document.createElement("div");
        this.vpaidContainer_2.className = "adfw-visualoverlay-vpaidframe adfw-visualoverlay-hidden";
        this.vpaidContainer_2.id = "vc2";
        document.body.appendChild(this.vpaidContainer_2);
    }

    /**
     * [initVPAID initiating VPAID - Loading remote script into a sandbox iframe to avoid DOM polluting]
     * @param  {[type]} adCreative [description]
     * @param  {[type]} type       ['linear','nonlinear']
     */
    Obj.prototype.initVPAID = function (ad, type) {
        this.log("initVPAID");
        if (this.VPAIDWrapper instanceof adfw.VPAIDWrapper) {
            adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                message: "PreBuffer VPAID"
            });
            //return false;
        } else {
            this.currentVPAIDObj = {};
        }
        var self = this;
        //this.VPAIDClean();
        var url, adCreative, interactiveCreativeFileUrl;
        //the variable that store all the current VPAID meta
        this.bufferingVPAIDObj = {};
        this.bufferingVPAIDObj.VPAIDType = type;


        this.vpaidScriptInitDeferred = adfw.Q.defer();

        if ('linear' === type) {
            adCreative = ad.getLinearCreative();
            interactiveCreativeFileUrl = adCreative.getInteractiveCreativeFile() && adCreative.getInteractiveCreativeFile().getUrl();
            url = interactiveCreativeFileUrl || adCreative.getOptimalMediaFile().getUrl();
            this.bufferingVPAIDObj.vpaidAdParameters = adCreative.adParameters;
        } else if ('nonlinear' === type) {
            adCreative = ad.getNonLinearCreative();
            url = adCreative.getBestVariation().getBestResource().getResource();
            this.bufferingVPAIDObj.vpaidAdParameters = adCreative.getBestVariation().adParameters;
            this.bufferingVPAIDObj.vpaidDisplayMS = adCreative.getBestVariation().calculateDisplayTime();
        } else {
            this.vpaidScriptInitDeferred = adfw.Q.reject("Unrecognized VPAID type: " + type);
            return this.vpaidScriptInitDeferred.promise;
        }

        this.bufferingVPAIDObj.ad = ad;
        this.bufferingVPAIDObj.vpaidCreative = adCreative;
        this.bufferingVPAIDObj.VPAIDUrl = url;

        // Load the VPAID ad unit
        var vpaidFrame = document.createElement('iframe');
        vpaidFrame.style.display = 'none';

        vpaidFrame.onload = function () {
            var vpaidLoader = vpaidFrame.contentWindow.document.createElement('script');

            vpaidLoader.onload = function () {

                self.bufferingVPAIDObj.isLoaded = true;
                self.vpaidScriptInitDeferred.resolve("VPAID Script loaded");
            };

            vpaidLoader.onerror = function () {
                self.vpaidScriptInitDeferred.reject("VPAID script load failure");
            };

            vpaidLoader.src = url;
            vpaidLoader.innerText = "inDapIF = true;window.top = window;window.parent = window;window.frameElement = null;";
            vpaidFrame.contentWindow.document.body.appendChild(vpaidLoader);
        };
        
        vpaidFrame.onerror = function () {
            self.vpaidScriptInitDeferred.reject("VPAID frame load failure");
        };
        
        document.body.appendChild(vpaidFrame);
        vpaidFrame.src = "about:blank";
        this.bufferingVPAIDObj.vpaidFrame = vpaidFrame;

        return this.vpaidScriptInitDeferred.promise
            .then(function () {

                self.log("Initialized VPAID iFrame...");
                return self.VPAIDIFrameCallback();
            })
            .catch(function (err) {
                self.log("Failed to initialize VPAID iFrame: " + err);
                throw(err);
            });
    };

    Obj.prototype.VPAIDIFrameCallback = function () {
	this.log("VPAIDIFrameCallback");
		
        var vpaidProgram;
        var fn = this.bufferingVPAIDObj.vpaidFrame.contentWindow.getVPAIDAd;
        if (fn && typeof fn == 'function') {
            vpaidProgram = fn();
        } else {
            var error = "VPAID Ad Unit JavaScript File is not VALID: " + fn;
            this.log(error);
            return adfw.Q.reject(error).promise;
        }
        this.log("Creating VPAID Wrapper...");
        var VPAIDWrapper = new adfw.VPAIDWrapper(this.bufferingVPAIDObj.ad, this.bufferingVPAIDObj.vpaidCreative, vpaidProgram);
        this.bufferingVPAIDObj.VPAIDWrapper = VPAIDWrapper;
        return this.VPAIDLOAD();
    };

    Obj.prototype.VPAIDLOAD = function () {
        this.log("VPAIDLOAD");

        if (!this.bufferingVPAIDObj.VPAIDWrapper) {
            return adfw.Q.reject("Bad state: No VPAIDWrapper");
        }
        var VPAIDWrapper = this.bufferingVPAIDObj.VPAIDWrapper;
        var self = this;

        VPAIDWrapper.handshakeVersion("2.0");
        if (this.currentVPAIDContainer == this.vpaidContainer) {
            this.bufferingVPAIDContainer = this.vpaidContainer_2;
        } else {
            this.bufferingVPAIDContainer = this.vpaidContainer;
        }
        var creativeData = {
                AdParameters: (this.bufferingVPAIDObj.vpaidAdParameters) ? this.bufferingVPAIDObj.vpaidAdParameters : ""
            },
            environmentVars = {
                slot: this.bufferingVPAIDContainer,
                videoSlotCanAutoPlay: true
            };
        var width = 1280,
            height = 720;
        if (this.scaledDimms) {
            width = this.scaledDimms.w;
            height = this.scaledDimms.h;
        }
        return VPAIDWrapper.initAd(width, height, 'normal', 512, creativeData, environmentVars, this.bufferingVPAIDObj.vpaidDisplayMS);
    };

    Obj.prototype.startVPAID = function () {
        var self = this;

        this.log("startVPAID");

        //Close any active VPAID ads
        if (this.currentVPAIDObj) {
            if (this.currentVPAIDObj.VPAIDWrapper) {
                this.currentVPAIDObj.VPAIDWrapper.stopAd();
            }
        }

        if (!this.vpaidScriptInitDeferred) {
            var error = "Initialization was not started";
            this.error(error);

            return Q.reject(error);
        }
        else {
            return this.vpaidScriptInitDeferred.promise
                .then(
                    function (result) {
                        self.scaleUI();
                        self.currentVPAIDObj = self.bufferingVPAIDObj;
                        self.VPAIDWrapper = self.currentVPAIDObj.VPAIDWrapper;
                        if (self.currentVPAIDObj.VPAIDType == 'nonlinear') {
                            if (self.nonLinearAd != self.currentVPAIDObj.ad) {
                                self.hideNonLinearAd(true);
                            }
                            self.nonLinearAd = self.currentVPAIDObj.ad;
                        }
                        self.vpaidAd = self.currentVPAIDObj.ad;

                        self.currentVPAIDContainer = self.bufferingVPAIDContainer;
                        self.currentVPAIDContainer.className = "adfw-visualoverlay-vpaidframe";
                        adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                            message: "Start VPAID"
                        });

                        self.log("SELF: " + self);
                        self.log("SELF.CurrentVPAIDOBJ: " + self.currentVPAIDObj);
                        self.log("SELF.VPAIDWrapper: " + self.VPAIDWrapper);
                        self.currentVPAIDObj.hasStarted = true;
                        return self.VPAIDWrapper.startAd().then(function (result) {
                            self.log("VPAID START COMPLETE: " + result);
                        });
                    },
                    // function (error) {
                    // 
                    // }
                    undefined
                )
                // .catch(function (error) {
            // 
                // })
            ;
        }
    };
    Obj.prototype.VPAIDStopAllVideo = function () {
        this.log("VPAIDStopAllVideo");
        try {

            var videos = this.currentVPAIDContainer.getElementsByTagName("video");
            for (var i = 0; i < videos.length; i++) {
                try {
                    var videoTag = videos[i];
                    videoTag.pause();
                    videoTag.removeAttribute("src");
                    videoTag.load();
                } catch (e) {
                    adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                        message: "Failed to stop video: " + e
                    });
                }
            }
        } catch (e) {
            adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                message: "Failed to stop video: " + e
            });
        }
    };

    /**
     * [VPAIDClean Clean up Resource beforeSetup/onComplete/onError]
     */
    Obj.prototype.VPAIDClean = function () {
        this.log("VPAIDClean");
        if (this.currentVPAIDObj) {
            //Remove VPAID element if existed
            if (this.currentVPAIDObj.vpaidFrame && this.currentVPAIDObj.vpaidFrame.parentNode) {
                this.currentVPAIDObj.vpaidFrame.parentNode.removeChild(this.currentVPAIDObj.vpaidFrame);
            }
            this.VPAIDStopAllVideo();
            if (this.currentVPAIDObj.VPAIDType == "nonlinear") {
                this.hideNonLinearAd();
                this.nonLinearAd = null;
            }
            this.currentVPAIDObj = {};
        }
        this.vpaidAd = null;
        this.VPAIDWrapper = null;
        this.vpaidScriptInitDeferred = null;
        this.iframeWindow.isVPAID = false;
        if (this.currentVPAIDContainer) {
            this.currentVPAIDContainer.innerHTML = "";
            this.currentVPAIDContainer.className = "adfw-visualoverlay-hidden adfw-visualoverlay-vpaidframe";
        }
        //this.currentVPAIDContainer = null;
    };

    //Positions the Linear Industry Icon display element based on the size and position of the video frame
    Obj.prototype.positionVPAID = function (scaled) {
    	this.log("positionVPAID");
        if (!scaled) {
            return false;
        }

        //this.log("position VPAID: " + scaled.x + "x" + scaled.y + "x" + scaled.w + "x" + scaled.h);

        this.vpaidContainer.style.left = scaled.x + 'px';
        this.vpaidContainer.style.top = scaled.y + 'px';
        this.vpaidContainer_2.style.left = scaled.x + 'px';
        this.vpaidContainer_2.style.top = scaled.y + 'px';
    };

    //Scales the NonLinear display element based on the size of the video frame
    Obj.prototype.scaleVPAID = function (scaled) {
        this.log("scaleVPAID");
        if (!scaled) {
            return false;
        }

        //this.log("scale VPAID: " + scaled.x + "x" + scaled.y + "x" + scaled.w + "x" + scaled.h);

        if (this.currentVPAIDObj && this.currentVPAIDObj.VPAIDWrapper) {
            this.currentVPAIDObj.VPAIDWrapper.resizeAd(scaled.w, scaled.h, 'normal');
        }
        if (this.bufferingVPAIDObj && this.bufferingVPAIDObj.VPAIDWrapper) {
            this.bufferingVPAIDObj.VPAIDWrapper.resizeAd(scaled.w, scaled.h, 'normal');
        }

        this.vpaidContainer.style.width = scaled.w + "px";
        this.vpaidContainer.style.height = scaled.h + "px";
        this.vpaidContainer_2.style.width = scaled.w + "px";
        this.vpaidContainer_2.style.height = scaled.h + "px";
    };

    Obj.prototype.handleVPAIDEvent = function (event, adRemainingTime, adDuration) {
        this.log("handleVPAIDEvent");
        var ad = this.vpaidAd || null;
        var adCreative = this.currentVPAIDObj.vpaidCreative || null;
        var adDuration = adDuration || 0;
        var adPlayhead = adDuration - adRemainingTime || 0;
        var contentPlayhead = adfw.Controller.getContentPlayhead() || 0;
        var url = this.currentVPAIDObj.VPAIDUrl || null;

        if (!ad || !adCreative || !event) return;

        if (event == 'Impression') {
            ad.handleImpression();
        } else if (event == 'ClickTracking') {
            if (typeof adCreative.adCreative === 'function') {
                adCreative.handleClick();
            }
        } else if (event == 'skip' || event == 'creativeView' || event == 'mute' || event == 'unmute' || event == 'start' || event == 'firstQuartile' || event == 'midpoint' || event == 'thirdQuartile' || event == 'complete' || event == 'acceptInvitation' || event == 'collapse' || event == 'close' || event == 'pause' || event == 'resume') {
            adCreative.handleEvent(event, adPlayhead, adDuration, contentPlayhead, url);
        }
        return;
    };

    //Now handled by VPAIDWrapper.setupLinearTimeCheck
    Obj.prototype.updateVPAIDLinearVideoCurrentPlayTime = function () {
        // var ms,
        // 	videos = this.currentVPAIDContainer.getElementsByTagName("video");
        // if (typeof videos !== 'undefined' && videos.length > 0) {
        // 	var video = videos[0];
        // 	video.addEventListener('timeupdate', function() {
        // 		var tempCurrentTime = parseInt(video.currentTime * 1000, 10);
        // 		if (!isNaN(tempCurrentTime)) {
        // 			ms = tempCurrentTime;
        // 			adfw.Events.dispatchEvent(adfw.Events.VPAID_LINEAR_PLAYBACK_TIME, {
        // 				ms: ms
        // 			});
        // 		}
        // 	}, false);
        // }
    };

    //***************************************** LINEAR *****************************************
    //Simulates a click on the Video ad.
    Obj.prototype.simulateVideoClick = function () {
        this.log("simulateVideoClick");
        return this.handleVideoClick();
    };

    Obj.prototype.handleVideoClick = function () {
        this.log("handleVideoClick");
        var state = adfw.Controller.getState();
        var currentLinearAd = state.currentLinearAd();
        if (!currentLinearAd) {
            return false;
        }
        var currentLinearCreative = currentLinearAd.getLinearCreative();
        if (!currentLinearCreative) {
            return false;
        }

        currentLinearCreative.handleClick();
        currentLinearCreative.handleEvent("acceptInvitationLinear", state.currentAdPlayhead(), adfw.Controller.getDuration(), state.currentContentPlayhead(), currentLinearCreative.getOptimalMediaFile().getUrl());
        if (currentLinearCreative.getClickThrough()) {
            if (typeof(this._clickThroughHandler) === "function") {
                try {
                    this._clickThroughHandler(currentLinearCreative.getClickThrough());
                }
                catch (e) {
                    this.log("Failed clickthrough: " + e);
                }
            }
            else {
                this.openIFrame(currentLinearCreative.getClickThrough());
            }
        }
        return true;
    };

    Obj.prototype.setClickThroughHandler = function (func) {
        this.log("setClickThroughHandler");
        this._clickThroughHandler = null;
        if (typeof(func) === "function") {
            this._clickThroughHandler = func;
        }
    };


    //***************************************** NONLINEAR *****************************************

    //Create the NonLinear display element and its close button
    Obj.prototype.initNonLinearUI = function () {
        this.log("initNonLinearUI");
        var self = this;

        var tempFunc;
        var div;

        //Function to handle NonLinear resource timeouts
        if (!this.handleNonLinearTimeout) {
            tempFunc = function () {
                if (!this.nonLinearAd || !this.nonLinearAdBreak) {
                    return;
                } //Prevent double reporting
                clearTimeout(this.nonLinearResourceTimeout);
                this.nonLinearResourceTimeout = null;
                adfw.Controller.handleVSuitePlaybackError(this.nonLinearAdBreak, this.nonLinearAd, 502, "Failed to fetch NonLinear ad - timeout", adfw.Controller.getState().currentContentPlayhead(), this.nonLinearVariation.getBestResource().getResource());
                this.hideNonLinearAd(true);
            };
            this.handleNonLinearTimeout = adfw.Utils.bind(tempFunc, this);
        }
        if (!this.handleNonLinearError) {
            tempFunc = function () {
                if (!this.nonLinearAd || !this.nonLinearAdBreak) {
                    return;
                } //Prevent double reporting
                clearTimeout(this.nonLinearResourceTimeout);
                this.nonLinearResourceTimeout = null;
                adfw.Controller.handleVSuitePlaybackError(this.nonLinearAdBreak, this.nonLinearAd, 502, "Failed to fetch NonLinear ad - 404", adfw.Controller.getState().currentContentPlayhead(), this.nonLinearVariation.getBestResource().getResource());
                this.hideNonLinearAd(true);
            };
            this.handleNonLinearError = adfw.Utils.bind(tempFunc, this);
        }
        if (!this.handleNonLinearLoad) {
            tempFunc = function () {
                clearTimeout(this.nonLinearResourceTimeout);
                this.nonLinearResourceTimeout = null;
                this.nonLinearAd.handleImpression(adfw.Controller.getState().currentContentPlayhead(), this.nonLinearVariation.getBestResource().getResource());
                this.nonLinearCreative.handleEvent("creativeView", null, null, adfw.Controller.getState().currentContentPlayhead(), this.nonLinearVariation.getBestResource().getResource());
            };
            this.handleNonLinearLoad = adfw.Utils.bind(tempFunc, this);
        }

        //Create the display element
        div = document.createElement("div");
        div.className = "adfw-visualoverlay-nonlinearui adfw-visualoverlay-hidden";
        document.body.appendChild(div);
        this.nonLinearDisplayElement = div;

        //Create the container holding ad
        div = document.createElement("div");
        div.className = "adfw-visualoverlay-nonlinearui adfw-visualoverlay-nonlinearui-container";
        div.addEventListener("click", function () {
            self.handleNonLinearClick();
        });
        this.nonLinearContainer = div;

        //Create the img tag that goes inside the container
        var img = document.createElement("img");
        img.style.padding = "0px";
        img.style.margin = "0px";
        img.style.width = "100%";
        img.style.height = "100%";
        img.addEventListener("load", this.handleNonLinearLoad);
        img.addEventListener("error", this.handleNonLinearError);

        this.nonLinearImg = img;

        //Create iframe tag that goes inside the container
        var iframe = document.createElement("iframe");
        iframe.style.padding = "0px";
        iframe.style.margin = "0px";
        iframe.style.width = "100%";
        iframe.style.height = "100%";
        iframe.addEventListener("load", this.handleNonLinearLoad);
        iframe.addEventListener("error", this.handleNonLinearError);
        this.nonLinearIFrame = iframe;

        //Create the close button
        div = document.createElement("div");
        div.className = "adfw-visualoverlay-nonlinearui adfw-visualoverlay-nonlinearui-closebutton";
        div.addEventListener("click", this.handleNonLinearClose);
        this.nonLinearCloseButton = div;

        this.nonLinearDisplayElement.appendChild(this.nonLinearContainer);
        this.nonLinearDisplayElement.appendChild(this.nonLinearCloseButton);
    };

    //Simulates a click on the NonLinear ad.
    Obj.prototype.simulateNonLinearClick = function () {
    	this.log("simulateNonLinearClick");
        this.handleNonLinearClick();
    };

    //If the NonLinear creative is clicked, fire the acceptInvitation and clickTracking events, and open the iFrame to the clickThrough Url.
    Obj.prototype.handleNonLinearClick = function () {
    	this.log("handleNonLinearClick");
        if (this.nonLinearCreative) {
            try {
                var resourceURI = null;
                if (this.nonLinearVariation.getBestResource().getType() != adfw.NonLinearResource.ResourceType.HTML) {
                    resourceURI = this.nonLinearVariation.getBestResource().getResource();
                }
                this.nonLinearCreative.handleEvent("acceptInvitation", adfw.Controller.getState().currentAdPlayhead(), adfw.Controller.getPlayer.getDuration(), adfw.Controller.getState().currentContentPlayhead(), resourceURI);
            } catch (e) {
                this.nonLinearCreative.handleEvent("acceptInvitation");
            }
            if (this.nonLinearVariation) {
                this.nonLinearVariation.handleClick();
                if (this.nonLinearVariation.getClickThrough()) {
                    this.openIFrame(this.nonLinearVariation.getClickThrough());
                    this.hideNonLinearAd(true);
                }
            }
        }
    };

    //When the NonLinear close button is clicked, this function is executed. Close the NonLinear creative.
    Obj.prototype.handleNonLinearClose = function () {
        this.log("handleNonLinearClose");
        adfw.VisualOverlay.hideNonLinearAd();
    };

    //Positions the NonLinear display element based on the size and position of the video frame
    Obj.prototype.positionNonLinearAd = function (scaled) {
        this.log("positionNonLinearAd");
        if (!scaled) {
            return false;
        }

        var lowerX = scaled.x + scaled.w;
        var lowerY = scaled.y + scaled.h;
        var upperX = scaled.x;
        var upperY = scaled.y;

        if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.BOTTOM_RIGHT) {
            this.nonLinearDisplayElement.style.left = (lowerX - (0 + this.nonLinearDisplayElement.offsetWidth)) + "px";
            this.nonLinearDisplayElement.style.top = (lowerY - (0 + this.nonLinearDisplayElement.offsetHeight)) + "px";
        } else if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.BOTTOM_LEFT) {
            this.nonLinearDisplayElement.style.left = (upperX) + "px";
            this.nonLinearDisplayElement.style.top = (lowerY - (0 + this.nonLinearDisplayElement.offsetHeight)) + "px";
        } else if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.TOP_LEFT) {
            this.nonLinearDisplayElement.style.left = (upperX) + "px";
            this.nonLinearDisplayElement.style.top = (upperY) + "px";
        } else if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.TOP_RIGHT) {
            this.nonLinearDisplayElement.style.left = (lowerX - (0 + this.nonLinearDisplayElement.offsetWidth)) + "px";
            this.nonLinearDisplayElement.style.top = (upperY) + "px";
        } else {
            //Overlay disabled
            return false;
        }
        return true;
    };

    //Scales the NonLinear display element based on the size of the video frame
    Obj.prototype.scaleNonLinearAd = function (scaled) {
        this.log("scaleNonLinearAd");
        if (!this.nonLinearDisplayElement || !this.nonLinearCreative || !this.nonLinearVariation || !this.nonLinearVariation.isScalable() || !scaled) {
            return false;
        }

        var maxW = scaled.w;
        var maxH = Math.floor(scaled.h * adfw.Config.get("NONLINEAR_MAXIMUM_VIDEO_COVERAGE_RATIO"));
        var minH = Math.floor(scaled.h * adfw.Config.get("NONLINEAR_MINIMUM_VIDEO_COVERAGE_RATIO"));
        var preferredH = 0;

        var assignedW = this.nonLinearVariation.getWidth();
        var assignedH = this.nonLinearVariation.getHeight();

        var aspectRatio = this.nonLinearVariation.getWidth() / this.nonLinearVariation.getHeight();

        if (assignedW > maxW || assignedH > maxH) {
            //Scale down
            if (assignedW / maxW > assignedH / maxH) {
                //scale using width because it's bigger in ratio to max
                assignedW = maxW;
                assignedH = assignedW / aspectRatio;
            } else {
                //scale using height because it's bigger in ratio to max
                assignedH = maxH;
                assignedW = assignedH * aspectRatio;
            }
        } else if (assignedH < minH) {
            //Scale up
            var scaleRatio = minH / assignedH;
            if ((scaleRatio * assignedW) > maxW) {
                scaleRatio = maxW / assignedW;
            }
            assignedH *= scaleRatio;
            assignedW *= scaleRatio;
        }

        this.nonLinearDisplayElement.style.width = assignedW + "px";
        this.nonLinearDisplayElement.style.height = assignedH + "px";
        //adfw.Events.dispatchEvent("DEBUG_MESSAGE", {message: "Scaling NonLinear Creative: " + assignedW + "x" + assignedH + " (" + minH  +")"});
    };

    //Given some HTML, put that HTML into the NonLinear creative.
    //When possible, uses widgetAPI.putInnerHTML in order to avoid memory leaks.
    Obj.prototype.handleNonLinearHTML = function (newHTML) {
        this.log("handleNonLinearHTML");
        if (this.widgetAPI) {
            this.widgetAPI.putInnerHTML(this.nonLinearContainer, newHTML);
            //adfw.Events.dispatchEvent("DEBUG_MESSAGE", {message: "NonLinear HTML using WidgetAPI"});
        } else {
            this.nonLinearContainer.innerHTML = newHTML;
            //adfw.Events.dispatchEvent("DEBUG_MESSAGE", {message: "NonLinear HTML using innerHTML"});
        }
    };

    //Given an imgSrc, display the nonlinear img.
    Obj.prototype.handleNonLinearImg = function (imgSrc) {
        this.log("handleNonLinearImg");
        this.nonLinearImg.src = encodeURI(imgSrc);
        this.nonLinearResourceTimeout = setTimeout(this.handleNonLinearTimeout, adfw.Config.get("NONLINEAR_RESOURCE_TIMEOUT"));
        this.nonLinearDisplayElement.appendChild(this.nonLinearImg);
    };

    //Given an imgSrc, display the nonlinear img.
    Obj.prototype.handleNonLinearIFrame = function (iframeSrc) {
        this.log("handleNonLinearIFrame");
        this.nonLinearIFrame.src = encodeURI(iframeSrc);
        this.nonLinearResourceTimeout = setTimeout(this.handleNonLinearTimeout, adfw.Config.get("NONLINEAR_RESOURCE_TIMEOUT"));
        this.nonLinearDisplayElement.appendChild(this.nonLinearIFrame);
    };

    //Given a NonLinear creative, displays the Creative inside the NonLinear display element.
    //Returns TRUE if display is successful. If unsuccessful, returns { code: errorCode, message: errorMessage }
    Obj.prototype.showNonLinearAd = function (parentAdBreak, ad) {
        this.log("showNonLinearAd");
        if (adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.DISABLED || false === adfw.Config.NONLINEAR_ADS_ENABLED) {
            adfw.Controller.handleVSuitePlaybackError(parentAdBreak, ad, 500, "NonLinear ads have been disabled in the configuration", adfw.Controller.getState().currentContentPlayhead(), ad.getNonLinearCreative().getBestVariation().getBestResource().getResource());
            return false;
        }
        if (this.nonLinearAd || this.nonLinearCreative || this.nonLinearVariation) {
            if (this.nonLinearDisplayTimeout || this.vpaidAd) {
                //If we're already displaying a NonLinear ad, abort display
                adfw.Controller.handleVSuitePlaybackError(parentAdBreak, ad, 500, "Rejecting NonLinear ad: A NonLinear ad is already being displayed.", adfw.Controller.getState().currentContentPlayhead(), ad.getNonLinearCreative().getBestVariation().getBestResource().getResource());
                return false;
            } else {
                this.hideNonLinearAd(true);
                adfw.Controller.handleVSuitePlaybackError(parentAdBreak, ad, 500, "Unknown NonLinear error", adfw.Controller.getState().currentContentPlayhead(), ad.getNonLinearCreative().getBestVariation().getBestResource().getResource());
                return false;
            }
        }

        if (this.nonLinearResourceTimeout) {
            clearTimeout(this.nonLinearResourceTimeout);
            this.nonLinearResourceTimeout = null;
        }

        var self = this;

        var creative = ad.getNonLinearCreative();
        var variation = creative.getBestVariation();
        var resource = variation.getBestResource();

        //Check for Flash
        if (resource.getType() === adfw.NonLinearResource.ResourceType.STATIC_FLASH) {
            adfw.Controller.handleVSuitePlaybackError(parentAdBreak, ad, 503, "Flash resources are not supported", adfw.Controller.getState().currentContentPlayhead(), ad.getNonLinearCreative().getBestVariation().getBestResource().getResource());
            return false;
        }
        //Check for non-vpaid JS
        else if (variation.apiFramework !== 'VPAID' && resource.getType() === adfw.NonLinearResource.ResourceType.STATIC_JS) {
            adfw.Controller.handleVSuitePlaybackError(parentAdBreak, ad, 503, "Non-VPAID JS resources are not supported", adfw.Controller.getState().currentContentPlayhead(), ad.getNonLinearCreative().getBestVariation().getBestResource().getResource());
            return false;
        }

        this.nonLinearAdBreak = parentAdBreak;
        this.nonLinearAd = ad;
        this.nonLinearCreative = creative;
        this.nonLinearVariation = variation;

        var displayMS = variation.calculateDisplayTime();
        this.nonLinearDisplayTimeout = setTimeout(function () {
            self.hideNonLinearAd(true);
        }, displayMS);

        var newHTML = "";
        if (resource.getType() === adfw.NonLinearResource.ResourceType.STATIC_IMAGE) {
            //newHTML = "<img src='" + encodeURI(resource.getResource()) + "'></img>";
            //this.handleNonLinearHTML(newHTML);
            this.handleNonLinearImg(resource.getResource());

            //this.nonLinearContainer.style.backgroundImage = "url('" + encodeURI(resource.getResource()) + "')";
        } else if (resource.getType() === adfw.NonLinearResource.ResourceType.IFRAME) {
            //newHTML = "<iframe src='" + encodeURI(resource.getResource()) + "'></iframe>";
            this.handleNonLinearIFrame(resource.getResource());
        } else if (resource.getType() === adfw.NonLinearResource.ResourceType.HTML) {
            newHTML = resource.getResource();
            this.handleNonLinearHTML(newHTML);
            this.nonLinearAd.handleImpression(adfw.Controller.getState().currentContentPlayhead(), null);
            this.nonLinearCreative.handleEvent("creativeView", null, null, adfw.Controller.getState().currentContentPlayhead(), null);
        } else if (variation.apiFramework === 'VPAID' && resource.getType() === adfw.NonLinearResource.ResourceType.STATIC_JS) {
            adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                message: "Showing NonLinear VPAID: "
            });
            this.initVPAID(ad, 'nonlinear');
        }

        //If we have VPAID, don't display the normal nonlinear UI.
        if (resource.getType() !== adfw.NonLinearResource.ResourceType.STATIC_JS) {
            this.nonLinearDisplayElement.className = "adfw-visualoverlay-nonlinearui";
            this.nonLinearDisplayElement.style.width = variation.getWidth() + "px";
            this.nonLinearDisplayElement.style.height = variation.getHeight() + "px";
            this.nonLinearContainer.src = resource.getResource();
        }
        //adfw.Events.dispatchEvent("DEBUG_MESSAGE", {message: "Showing NonLinear Creative: " + variation.getWidth() + "x" + variation.getHeight()});
        this.scaleUI();
        adfw.Events.dispatchEvent(adfw.Events.NONLINEAR_AD_START);
        return true;
    };

    //Hides the NonLinear display element (if it's currently showing).
    //If there is not a TRUE passed in as an argument, then it means that the close was triggered by the user. In this case, fire the Close tracking event as well
    Obj.prototype.hideNonLinearAd = function (wasClosedAutomatically) {
        // adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
        //  message: "Hiding NonLinear Creative..." + wasClosedAutomatically
        // });
        this.log("hideNonLinearAd");
        if (wasClosedAutomatically !== true) {
            if (this.nonLinearCreative) {
                try {
                    var resourceURI = null;
                    if (this.nonLinearVariation.getBestResource().getType() != adfw.NonLinearResource.ResourceType.HTML) {
                        resourceURI = this.nonLinearVariation.getBestResource().getResource();
                    }
                    this.nonLinearCreative.handleEvent("close", adfw.Controller.getState().currentAdPlayhead(), adfw.Controller.getPlayer.getDuration(), adfw.Controller.getState().currentContentPlayhead(), resourceURI);
                } catch (e) {
                    this.nonLinearCreative.handleEvent("close");
                }
            }
        }
        if (this.nonLinearAd) {
            adfw.Events.dispatchEvent(adfw.Events.NONLINEAR_AD_END);
        }
        this.nonLinearAdBreak = null;
        this.nonLinearAd = null;
        this.nonLinearCreative = null;
        this.nonLinearVariation = null;
        if (this.nonLinearDisplayTimeout) {
            clearTimeout(this.nonLinearDisplayTimeout);
            this.nonLinearDisplayTimeout = null;
        }
        if (this.nonLinearResourceTimeout) {
            clearTimeout(this.nonLinearResourceTimeout);
            this.nonLinearResourceTimeout = null;
        }
        this.nonLinearImg.src = "";
        this.nonLinearIFrame.src = "";
        this.handleNonLinearHTML("");
        try {
            this.nonLinearDisplayElement.removeChild(this.nonLinearImg);
        } catch (e) {
        }
        try {
            this.nonLinearDisplayElement.removeChild(this.nonLinearIFrame);
        } catch (e) {
        }

        this.nonLinearDisplayElement.className = "adfw-visualoverlay-nonlinearui adfw-visualoverlay-hidden";

        //this.VPAIDClean();
    };


    //***************************************** Linear Industry Icon  *****************************************

    //Create the Linear Industry Icon display element
    Obj.prototype.initLinearIconUI = function () {
    	this.log("initLinearIconUI");
        this.linearIconElements = [];

        if (!this.handleLinearIconLoad) {
            var tempFunc = function (iconElement) {
                iconElement.resource.handleDisplay();
            };

            this.handleLinearIconLoad = adfw.Utils.bind(tempFunc, this);
        }
    };
    Obj.prototype.createIconElement = function (icon) {
        this.log("createIconElement");
        var self = this;

        if (!icon) {
            return false;
        }
        var resource = icon.getPriorityIconResource();

        var icon_container = document.createElement("div");
        icon_container.resource = resource;
        icon_container.className = "adfw-visualoverlay-linearicon adfw-visualoverlay-hidden";
        icon_container.addEventListener("click", function (resource) {
            return function (e) {
                e.preventDefault();
                self.handleLinearIconClick(resource);
            };
        }(resource));
        icon_container.setAttribute("data-width", icon.getWidth());
        icon_container.setAttribute("data-height", icon.getHeight());
        icon_container.setAttribute("data-X", icon.getX());
        icon_container.setAttribute("data-Y", icon.getY());

        if (resource.getType() == "STATIC_IMAGE") {
            var img = document.createElement("img");
            img.style.width = icon.getWidth() + 'px';
            img.style.height = icon.getHeight() + 'px';
            img.src = resource.getContent();
            icon_container.appendChild(img);
        } else if (resource.getType() == "HTML") {
            icon_container.innerHTML = resource.getContent();
        } else if (resource.getType() == "IFRAME") {
            var iframe = document.createElement("iframe");
            iframe.style.width = icon.getWidth() + 'px';
            iframe.style.height = icon.getHeight() + 'px';
            iframe.src = encodeURI(resource.getContent());
            icon_container.appendChild(iframe);
        }
        this.linearIconElements.push(icon_container);
        document.body.appendChild(icon_container);
        //Display Logic (offset/duration)
        this.showLinearIcon(icon_container, icon.getOffset(), icon.getDuration());
    };

    Obj.prototype.loadLinearIcons = function (icons) {
        this.log("loadLinearIcons");
        if (adfw.Config.get("ICONS_ENABLED") === false || adfw.Config.get("OVERLAY_POSITION") === adfw.Config.OVERLAY_POSITION.DISABLED) {
            return false;
        }

        for (var i = 0; i < icons.length; i++) {
            this.createIconElement(icons[i]);
        }
        this.scaleLinearIcons(this.scaledDimms);
        this.positionLinearIcons(this.scaledDimms);
    };

    Obj.prototype.showLinearIcon = function (iconElement, offset, duration) {
        //TODO handle display event
        this.log("showLinearIcon");

        var self = this;
        if (offset) {
            iconElement.t_offset = setTimeout(function (iconElement) {
                return function () {
                    iconElement.className = 'adfw-visualoverlay-linearicon';
                    self.handleLinearIconLoad(iconElement);
                };
            }(iconElement), offset);

        } else {
            iconElement.className = 'adfw-visualoverlay-linearicon';
            self.handleLinearIconLoad(iconElement);
        }
        if (duration) {
            iconElement.t_duration = setTimeout(function (iconElement) {
                return function () {
                    self.destroyLinearIcon(iconElement);
                };
            }(iconElement), offset ? offset + duration : duration);
        }
    };

    Obj.prototype.destroyLinearIcons = function () {
        this.log("destroyLinearIcons");
        var iconElements = document.getElementsByClassName('adfw-visualoverlay-linearicon');
        for (var i = 0; i < iconElements.length; i++) {
            this.destroyLinearIcon(iconElements[i]);
        }
    };

    Obj.prototype.destroyLinearIcon = function (iconElement) {
        this.log("destroyLinearIcon");
        if (iconElement) {
            iconElement.parentNode.removeChild(iconElement);
            //clearTimeout for display offset/duration
            clearTimeout(iconElement.t_offset);
            clearTimeout(iconElement.t_duration);
        }
    };

    //Positions the Linear Industry Icon display element based on the size and position of the video frame
    Obj.prototype.positionLinearIcons = function (scaled) {
        this.log("positionLinearIcons");

        if (!this.linearIconElements || !scaled) {
            return false;
        }
        var linearIconElements = this.linearIconElements;
        var lowerX = scaled.x + scaled.w;
        var lowerY = scaled.y + scaled.h;
        var upperX = scaled.x;
        var upperY = scaled.y;

        for (var i = 0; i < linearIconElements.length; i++) {
            var thislinearIconTarget;
            var thislinearIconElement = linearIconElements[i];

            if (thislinearIconElement.getAttribute("data-X") == 'left') {
                thislinearIconElement.style.left = (upperX + 5) + 'px';
            } else if (thislinearIconElement.getAttribute("data-X") == 'right') {
                thislinearIconTarget = thislinearIconElement.firstChild;
                thislinearIconElement.style.left = (lowerX - 5) - parseInt(thislinearIconTarget.style.width, 10) + 'px';
            } else {
                thislinearIconElement.style.left = upperX + parseInt(thislinearIconElement.getAttribute("data-X"), 10) + 'px';
            }
            if (thislinearIconElement.getAttribute("data-Y") == 'top') {
                thislinearIconElement.style.top = (upperY + 5) + 'px';
            } else if (thislinearIconElement.getAttribute("data-Y") == 'bottom') {
                thislinearIconTarget = thislinearIconElement.firstChild;
                thislinearIconElement.style.top = (lowerY - 5) - parseInt(thislinearIconTarget.style.height, 10) + 'px';
            } else {
                thislinearIconElement.style.top = upperY + parseInt(thislinearIconElement.getAttribute("data-Y"), 10) + 'px';
            }
        }
    };

    //Scales the icons based on the size of the video frame
    Obj.prototype.scaleLinearIcons = function (scaled) {
        this.log("scaleLinearIcons");
        if (!this.linearIconElements || !scaled) {
            return false;
        }
        var linearIconElements = this.linearIconElements;
        var thislinearIconElement;
        var thislinearIconTarget;

        //When Full Screen
        if (scaled.w == window.innerWidth) {
            for (var i = 0; i < linearIconElements.length; i++) {
                thislinearIconElement = linearIconElements[i];
                thislinearIconTarget = thislinearIconElement.firstChild;
                thislinearIconTarget.style.width = parseInt(thislinearIconElement.getAttribute("data-width"), 10) + "px";
                thislinearIconTarget.style.height = parseInt(thislinearIconElement.getAttribute("data-height"), 10) + "px";
            }
        } else {
            var widthRatio = scaled.w / window.innerWidth;
            var heightRatio = scaled.h / window.innerHeight;
            for (var x = 0; x < linearIconElements.length; x++) {
                thislinearIconElement = linearIconElements[x];
                thislinearIconTarget = thislinearIconElement.firstChild;
                thislinearIconTarget.style.width = Math.floor(parseInt(thislinearIconElement.getAttribute("data-width"), 10) * widthRatio) + "px";
                thislinearIconTarget.style.height = Math.floor(parseInt(thislinearIconElement.getAttribute("data-height"), 10) * heightRatio) + "px";
            }
        }
    };

    //If the Linear Icon Container creative is clicked, fire the acceptInvitation and clickTracking events, and open the iFrame to the clickThrough Url.
    Obj.prototype.handleLinearIconClick = function (resource) {
        this.log("handleLinearIconClick");
        if (resource) {
            var clickThrough = resource.clickThrough;
            var clickTrackers = resource.clickTrackers;

            //Handle Click for Static Resource
            if (clickThrough && resource.getType() == 'STATIC_IMAGE') {
                //OPEN IFRAME
                adfw.VisualOverlay.openIFrame(clickThrough);
                //Handle Click for HTML Resource
            } else if (resource.getType() == 'HTML') {
                //Extracting url from Atag
                var regex_a_tag = /href=['"]([^'">]+)/i;
                clickThrough = regex_a_tag.exec(resource.content);
                if (clickThrough) {
                    //OPEN IFRAME
                    adfw.VisualOverlay.openIFrame(clickThrough[1]);
                }
            }
            if (clickTrackers) {
                //SEND TRACKING
                resource.handleClick();
            }
        }
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW VISUALOVERLAY]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW VISUALOVERLAY]");
    };

    return new Obj();
})();

adfw.PlatformUtils = (function () {
    "use strict";

    var Obj = function () {
        this.platform = null;
    };

    //Gets the platform that Ad Framework is running on - whether it's Orsay, Tizen, or Unknown.
    Obj.prototype.Platform = {
        TIZEN_WEBKIT: "TIZEN_WEBKIT",
        ORSAY_WEBKIT: "ORSAY_WEBKIT",
        TIZEN_VOLT: "TIZEN_VOLT",
        UNKNOWN: "UNKNOWN",
    };

    Obj.prototype.isRunningInBrowserEnvironment = function () {
        if (typeof this._isRunningInBrowserEnvironment === "boolean") {
            return this._isRunningInBrowserEnvironment;
        } else {
            //this.log("Determining browser status...");
            try {
                this._isRunningInBrowserEnvironment = (window && window.location && document && document.body && document.getElementById && document.body.appendChild && navigator.userAgent);
                //this.log("Running in a browser environment? " + this._isRunningInBrowserEnvironment);
            }
            catch (e) {
                this._isRunningInBrowserEnvironment = false;
                //this.error("Failure while detecting browser environment: " + e);
                //this.error("Assuming we are NOT in a browser environment!");
            }
            return this._isRunningInBrowserEnvironment;
        }
    }

    Obj.prototype.isTizenWebkit = function () {
        return this.getPlatform() === this.Platform.TIZEN_WEBKIT;
    };

    Obj.prototype.isTizenVolt = function () {
        return this.getPlatform() === this.Platform.TIZEN_VOLT;
    };

    Obj.prototype.isOrsayWebkit = function () {
        return this.getPlatform() === this.Platform.ORSAY_WEBKIT;
    };

    Obj.prototype.isUnknownPlatform = function () {
        return this.getPlatform() === this.Platform.UNKNOWN;
    };

    Obj.prototype.getPlatform = function () {
        if (this.platform) {
            return this.platform;
        }

        //this.log("Determining platform...");

        this.platform = this.Platform.UNKNOWN;
        if (typeof(navigator) !== "undefined" && typeof(navigator.userAgent) === "string") {
            var ua = navigator.userAgent.toLowerCase();

            if (ua.indexOf("maple") >= 0 && ua.indexOf("smarttv") >= 0) {
                //this.log("Orsay Webkit userAgent detected: " + ua);
                this.platform = this.Platform.ORSAY_WEBKIT;
            } else if (ua.indexOf("tizen") >= 0) {
                //this.log("Tizen Webkit userAgent detected: " + ua);
                this.platform = this.Platform.TIZEN_WEBKIT;
            }
            else {
                //this.log("Unknown userAgent");
            }

        } else if (typeof(Volt) !== "undefined" && ((typeof(window) === "undefined") || typeof(document) === "undefined")) {
            //this.log("Platform determined to be VOLT");
            this.platform = this.Platform.TIZEN_VOLT;
        }
        return this.platform;
    };

    Obj.prototype.determineWindowScaleRelativeTo960 = function () {
        if (this.isTizenVolt()) {
            this.viewportWidth = scene.width;
            this.viewportHeight = scene.height;
            this.xScaleRelativeTo960 = this.viewportWidth / 960;
            this.yScaleRelativeTo960 = this.viewportHeight / 540;
        } else {
            if (this.isRunningInBrowserEnvironment()) {
                this.viewportWidth = window.innerWidth;
                this.viewportHeight = window.innerHeight;
                this.xScaleRelativeTo960 = this.viewportWidth / 960;
                this.yScaleRelativeTo960 = this.viewportHeight / 540;

                if (this.isTizenWebkit()) {

                    var cb = function (that) {
                        tizen.systeminfo.getPropertyValue('DISPLAY', function (display) {
                            that.viewportWidth = display.resolutionWidth;
                            that.viewportHeight = display.resolutionHeight;
                            that.xScaleRelativeTo960 = that.viewportWidth / 960;
                            that.yScaleRelativeTo960 = that.viewportHeight / 540;
                        });
                    }(this);

                }
            }
        }
    };

    //convertDimensionsToScreenRatio(0,0,1920,1080) -> {x:0,y:0,w:1,h:1}
    Obj.prototype.convertDimensionsToScreenRatio = function (x, y, w, h) {
        var params = {};

        if (typeof x === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            params = x;
        } else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            params = {
                x: x,
                y: y,
                w: w,
                h: h
            };
        } else {
            throw "convertDimensionsToScreenRatio received incorrect params: " + params + " | " + params.x + "," + params.y + "," + params.w + "," + params.h + ",";
        }

        params.x = params.x / this.viewportWidth;
        params.w = params.w / this.viewportWidth;

        params.y = params.y / this.viewportHeight;
        params.h = params.h / this.viewportHeight;

        return params;
    };

    //convertDimensionsFromScreenRatio(0,0,1,1) -> {x:0,y:0,w:1920,h:1080}
    //Scales a map of {x,y,w,h} that is already relative to 960x540 into whatever resolution the actual window size is.
    Obj.prototype.convertDimensionsFromScreenRatio = function (x, y, w, h) {
        var params = {};

        if (typeof x === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            params = x;
        } else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            params = {
                x: x,
                y: y,
                w: w,
                h: h
            };
        } else {
            throw "convertDimensionsFromScreenRatio received incorrect params: " + params + " | " + params.x + "," + params.y + "," + params.w + "," + params.h + ",";
        }

        params.x = Math.round(params.x * this.viewportWidth);
        params.w = Math.round(params.w * this.viewportWidth);

        params.y = Math.round(params.y * this.viewportHeight);
        params.h = Math.round(params.h * this.viewportHeight);

        return params;
    };

    //scaleTo960(0,0,1920,1080) -> {x:0,y:0,w:960,h:540}
    Obj.prototype.scaleTo960 = function (x, y, w, h) {
        var params = {};
        if (!this.xScaleRelativeTo960 || !this.yScaleRelativeTo960 || typeof(this.xScaleRelativeTo960) !== "number" || typeof(this.yScaleRelativeTo960) !== "number") {
            this.determineWindowScaleRelativeTo960();
        }
        if (typeof x === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            params = x;
        } else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            params = {
                x: x,
                y: y,
                w: w,
                h: h
            };
        } else {
            throw "scaleTo960 received incorrect params: " + params + " | " + params.x + "," + params.y + "," + params.w + "," + params.h + ",";
        }

        params.x = Math.round(params.x / this.xScaleRelativeTo960);
        params.w = Math.round(params.w / this.xScaleRelativeTo960);

        params.y = Math.round(params.y / this.yScaleRelativeTo960);
        params.h = Math.round(params.h / this.yScaleRelativeTo960);

        return params;
    };

    //scaleTo960(0,0,960,540) -> {x:0,y:0,w:1920,h:1080}
    //Scales a map of {x,y,w,h} that is already relative to 960x540 into whatever resolution the actual window size is.
    Obj.prototype.scaleFrom960 = function (x, y, w, h) {
        var params = {};
        if (!this.xScaleRelativeTo960 || !this.yScaleRelativeTo960 || typeof(this.xScaleRelativeTo960) !== "number" || typeof(this.yScaleRelativeTo960) !== "number") {
            this.determineWindowScaleRelativeTo960();
        }
        if (typeof x === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            params = x;
        } else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            params = {
                x: x,
                y: y,
                w: w,
                h: h
            };
        } else {
            throw "scaleFrom960 received incorrect params: " + params + " | " + params.x + "," + params.y + "," + params.w + "," + params.h + ",";
        }

        params.x = Math.round(params.x * this.xScaleRelativeTo960);
        params.w = Math.round(params.w * this.xScaleRelativeTo960);

        params.y = Math.round(params.y * this.yScaleRelativeTo960);
        params.h = Math.round(params.h * this.yScaleRelativeTo960);

        return params;
    };

    Obj.prototype.log = function (msg) {
        if (typeof adfw.PlatformUtils !== "undefined") {
            adfw.Utils.log(msg, "[ADFW PLATFORMUTILS]");
        }
    };
    Obj.prototype.error = function (msg) {
        if (typeof adfw.PlatformUtils !== "undefined") {
            adfw.Utils.error(msg, "[ADFW PLATFORMUTILS]");
        }
    };

    return new Obj();
}());

adfw.WebkitUtils = (function () {
    "use strict";

    var Obj = function () {

    };

    //Given a seed, generate a random ID that is unique to the current page.
    Obj.prototype.generateUniqueID = function (seed) {
        if (!seed) {
            seed = "plugin";
        }
        var id = null;
        var rand = null;
        var generatedID = null;
        var existingElement = null;
        do {
            rand = Math.floor(Math.random() * 99999);
            id = (seed + rand);
            existingElement = document.getElementById(id);
        } while (existingElement);
        return id;
    };

    return new Obj();
}());
adfw.OrsayWebkitUtils = (function () {
    "use strict";

    var Obj = function () {
        this._mac = null;
        this._duid = null;
        this._networkPlugin = null;
        this._tvPlugin = null;
        this._nnaviPlugin = null;
        this._sefPlayers = [];
        this._audioPlugins = [];
    };

    //Gets the DUID of the TV
    Obj.prototype.getDUID = function () {
        if (this._duid) {
            return this._duid;
        }
        else {
            try {
                this._mac = this.getNetworkPlugin().GetMAC(1);
                this._duid = this.getNNaviPlugin().GetDUID(this._mac);
                return this._duid;
            }
            catch (e) {
                this._duid = "NONE";
                return this._duid;
            }
        }
    };

    Obj.prototype.getInfolinkVersion = function () {
        if (this.isInfolink()) {
            return this._tvInfolinkVersion;
        }
        else {
            return "UNKNOWN";
        }
    };

    //Checks whether this is an INFOLINK TV (has INFOLINK in its firmware version)
    Obj.prototype.isInfolink = function () {
        if (typeof this._isInfolinkBoolean === "boolean") {
            return this._isInfolinkBoolean;
        }

        var isInfolinkBoolean = false;

        //this.log("Checking whether this is an INFOLINK TV...");

        if (adfw.PlatformUtils.isOrsayWebkit()) {
            var nnavi = this.getNNaviPlugin();
            if (!nnavi || typeof nnavi.GetFirmware !== "function") {
                this.log("nnavi plugin does not exist or does not have a GetFirmware function. nnavi=" + nnavi);
                isInfolinkBoolean = false;
            }
            else {
                this._tvInfolinkVersion = nnavi.GetFirmware();
                if (this._tvInfolinkVersion.indexOf("INFOLINK") > -1) {
                    isInfolinkBoolean = true;
                }
                //this.log("nnavi plugin reports firmware version: " + this._tvInfolinkVersion + ". This indicates the TV " + (isInfolinkBoolean ? "is" : "is NOT") + " INFOLINK.");
            }
        }
        else {
            //this.log("PlatformUtils does not think this is an Orsay Webkit environment.");
        }

        this._isInfolinkBoolean = isInfolinkBoolean;
        //this.log("So - is this TV Infolink? " + this._isInfolinkBoolean);
        return this._isInfolinkBoolean;
    };

    //Checks whether this is a 2012 INFOLINK TV (has INFOLINK2012 in its firmware version)
    Obj.prototype.is2012Model = function () {
        if (!this.isInfolink()) {
            return false;
        }
        if (typeof this._is2012ModelBoolean === "boolean") {
            return this._is2012ModelBoolean;
        }

        var regex = /INFOLINK2012/g;
        this._is2012ModelBoolean = regex.test(this._tvInfolinkVersion);
        return this._is2012ModelBoolean;
    };

    //Checks whether this is a 2013 INFOLINK TV (has INFOLINK2013 in its firmware version)
    Obj.prototype.is2013Model = function () {
        if (!this.isInfolink()) {
            return false;
        }
        if (typeof this._is2013ModelBoolean === "boolean") {
            return this._is2013ModelBoolean;
        }

        var regex = /INFOLINK2013/g;
        this._is2013ModelBoolean = regex.test(this._tvInfolinkVersion);
        return this._is2013ModelBoolean;
    };

    //Checks whether this is a 2014 INFOLINK TV (has INFOLINK2014 in its firmware version)
    Obj.prototype.is2014Model = function () {
        if (!this.isInfolink()) {
            return false;
        }
        if (typeof this._is2014ModelBoolean === "boolean") {
            return this._is2014ModelBoolean;
        }

        var regex = /INFOLINK2014/g;
        this._is2014ModelBoolean = regex.test(this._tvInfolinkVersion);
        return this._is2014ModelBoolean;
    };

    //Checks whether this is a 2015 INFOLINK TV (has INFOLINK2015 in its firmware version)
    Obj.prototype.is2015Model = function () {
        if (!this.isInfolink()) {
            return false;
        }
        if (typeof this._is2015ModelBoolean === "boolean") {
            return this._is2015ModelBoolean;
        }

        var regex = /INFOLINK2015/g;
        this._is2015ModelBoolean = regex.test(this._tvInfolinkVersion);
        return this._is2015ModelBoolean;
    };

    Obj.prototype.getWidgetID = function () {
        if (typeof(window) !== "undefined" && window.curWidget && window.curWidget.id) {
            return window.curWidget.id;
        }
        return null;
    };

    Obj.prototype.getNetworkPlugin = function () {
        if (this._networkPlugin) {
            return this._networkPlugin;
        }
        else {
            this.generateNetworkPlugin();
            return this._networkPlugin;
        }
    };

    Obj.prototype.getTVPlugin = function () {
        if (this._tvPlugin) {
            return this._tvPlugin;
        }
        else {
            this.generateTVPlugin();
            return this._tvPlugin;
        }
    };

    Obj.prototype.getNNaviPlugin = function () {
        if (this._nnaviPlugin) {
            return this._nnaviPlugin;
        }
        else {
            this.generateNNaviPlugin();
            return this._nnaviPlugin;
        }
    };

    //Create a SEF Plugin and return its ID
    Obj.prototype.generateSEFPlayer = function (id) {
        if (!id) {
            id = adfw.WebkitUtils.generateUniqueID("sefPlugin");
        }
        else if (document.getElementById(id)) {
            return null;
        }
        var container = document.createElement("div");
        document.body.appendChild(container);

        if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_WEBKIT) {
            container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-SEF", "adfw-plugin adfw-sef-plugin-tizen");
        }
        else {
            container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-SEF", "adfw-plugin adfw-sef-plugin-orsay");
        }

        var sefPlayer = document.getElementById(id);
        if (sefPlayer) {
            this._sefPlayers.push(id);
            return sefPlayer;
        }
        else {
            return null;
        }
    };

    //Create an Audio plugin and return its ID
    Obj.prototype.generateAudioPlugin = function (id) {
        if (!id) {
            id = adfw.WebkitUtils.generateUniqueID("sefAudio");
        }
        else if (document.getElementById(id)) {
            return null;
        }
        var container = document.createElement("div");
        document.body.appendChild(container);
        container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-AUDIO", "adfw-plugin adfw-hidden-plugin");
        var audio = document.getElementById(id);
        if (audio) {
            this._audioPlugins.push(id);
            return audio;
        }
        else {
            return null;
        }
    };

    Obj.prototype.generateNetworkPlugin = function (id) {
        if (!id) {
            id = adfw.WebkitUtils.generateUniqueID("sefNetwork");
        }
        else if (document.getElementById(id)) {
            return null;
        }
        var container = document.createElement("div");
        document.body.appendChild(container);
        container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-NETWORK", "adfw-plugin adfw-hidden-plugin");
        var network = document.getElementById(id);
        if (network) {
            this._networkPlugin = network;
            return network;
        }
        else {
            return null;
        }
    };

    Obj.prototype.generateTVPlugin = function (id) {
        if (!id) {
            id = adfw.WebkitUtils.generateUniqueID("sefTV");
        }
        else if (document.getElementById(id)) {
            return null;
        }
        var container = document.createElement("div");
        document.body.appendChild(container);
        container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-TV", "adfw-plugin adfw-hidden-plugin");
        var tvPlugin = document.getElementById(id);
        if (tvPlugin) {
            this._tvPlugin = tvPlugin;
            return tvPlugin;
        }
        else {
            return null;
        }
    };

    Obj.prototype.generateNNaviPlugin = function (id) {
        if (!id) {
            id = adfw.WebkitUtils.generateUniqueID("sefNNAVI");
        }
        else if (document.getElementById(id)) {
            return null;
        }
        var container = document.createElement("div");
        document.body.appendChild(container);
        container.innerHTML += this.generatePluginHTML(id, "SAMSUNG-INFOLINK-NNAVI", "adfw-plugin adfw-hidden-plugin");
        var nnavi = document.getElementById(id);
        if (nnavi) {
            this._nnaviPlugin = nnavi;
            return nnavi;
        }
        else {
            return null;
        }
    };

    //Given an ID and a clsid, creates the HTML necessary for a Orsay plugin.
    Obj.prototype.generatePluginHTML = function (id, clsid, className) {
        if (!className) {
            className = "";
        }
        var style = "";
        if (clsid === "SAMSUNG-INFOLINK-SEF" || clsid === "SAMSUNG-INFOLINK-PLAYER") {
            style = "";
        }


        var html = "<OBJECT id='" + id + "' classid='clsid:" + clsid + "' class='" + className + "' style='" + "" + "'></OBJECT>";
        return html;
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW ORSAYWEBKITUTILS]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW ORSAYWEBKITUTILS]");
    };

    return new Obj();
}());
adfw.TizenWebkitUtils = (function () {
    "use strict";

    var Obj = function () {
        this.avplayerElement = null;
        this._tizenWebAPIsPlugin = null;
    };

    var modelYear2015Regex = /15_*/;
    var modelYear2016Regex = /16_*/;
    var modelYear2017Regex = /17_*/;

    Obj.prototype.getTizenWebAPIsPlugin = function (callback, error_callback) {
        if (this._tizenWebAPIsPlugin) {
            return this._tizenWebAPIsPlugin;
        }
        else {
            this.generateTizenWebAPIsPlugin(callback, error_callback);
            return this._tizenWebAPIsPlugin;
        }
    };

    //Create or get AVPlayer Plugin and return it
    Obj.prototype.getAVPlayerElement = function () {

        //Can only be one!
        if (this.avplayerElement) {
            return this.avplayerElement;
        }
        else {
            var objects = document.getElementsByTagName("object");
            for (var i = 0; i < objects.length; i++) {
                var object = objects[i];
                if (object.type === 'application/avplayer') {
                    this.avplayerElement = object;
                    return this.avplayerElement;
                }
            }

            //if we get to here, we need to create our own element since it doesn't exist
            var plugin = document.createElement("object");
            plugin.type = "application/avplayer";
            if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.ORSAY_WEBKIT) {
                plugin.className = "adfw-plugin adfw-avplay-plugin-orsay";
            }
            else if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_WEBKIT) {
                plugin.className = "adfw-plugin adfw-avplay-plugin-tizen";
            }
            else {
                plugin.className = "adfw-plugin";
            }
            document.body.appendChild(plugin);
            this.avplayerElement = plugin;
            return this.avplayerElement;
        }
    };

    Obj.prototype.generateTizenWebAPIsPlugin = function (callback, error_callback) {
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = "$WEBAPIS/webapis/webapis.js";
        document.body.appendChild(script);
        script.onload = function () {
            this._tizenWebAPIsPlugin = true;
            if (callback) {
                callback();
            }
        };
        script.onerror = function () {
            if (error_callback) {
                error_callback();
            }
        };
    };

    //Just in case you forgot how to do it, I documented it here...
    Obj.prototype.getModelCode = function () {
        return webapis.productinfo.getModelCode();
    };

    Obj.prototype.is2015Model = function () {
        return modelYear2015Regex.test(this.getModelCode());
    };

    Obj.prototype.is2016Model = function () {
        return modelYear2016Regex.test(this.getModelCode());
    };

    Obj.prototype.is2017Model = function () {
        return modelYear2017Regex.test(this.getModelCode());
    };

    return new Obj();
}());
adfw.TizenVoltUtils = (function () {
    "use strict";

    var Obj = function () {

    };

    return new Obj();
}());
adfw.PlayerAdapter = (function () {
    "use strict";
    //Constructor: set up prototype chain
    //DO NOT OVERRIDE THIS OR IT WILL NOT INHERIT EVENT FUNCTIONALITY!
    var Obj = function () {
        adfw.GenericEventDispatcher.call(this); //This Object is an event dispatcher!
        this.state = Obj.State.STOPPED;
        this.internalDisplayArea = {
            x: 0,
            y: 0,
            w: 1920,
            h: 1080
        };
    };
    Obj.prototype = Object.create(adfw.GenericEventDispatcher.prototype);
    Obj.prototype.constructor = Obj;

    var abstractFunction = function () {
        this.error("You have called an abstract function, the PlayerAdapter is meant to be an abstract class. please implement and override this function");
    };

    //Abstract functions that should be implemented by each concrete implementation.
    Obj.prototype.initialize = abstractFunction; //do whatever your video player needs
    Obj.prototype.play = abstractFunction; //plays a video given a Url. if given signed milliseconds as a second parameter, starts playback that many milliseconds into the video
    Obj.prototype.initPlayer = abstractFunction; //prepares a video Url. Used instead of play() if you want to set some parameters on the adapter first.
    Obj.prototype.startPlayback = abstractFunction; //starts playback of initialized Url
    Obj.prototype.stop = abstractFunction; //stops and unloads the current video
    Obj.prototype.pause = abstractFunction; //pauses the currently playing video
    Obj.prototype.resume = abstractFunction; //resumes the currently paused video
    Obj.prototype.jump = abstractFunction; //jumps forward/backward in time, given unsigned milliseconds
    Obj.prototype.jumpForward = abstractFunction; //jumps forward in time, given signed milliseconds
    Obj.prototype.jumpBackward = abstractFunction; //jumps backward in time, given signed milliseconds

    Obj.prototype.startBufferingVideo = abstractFunction; //starts buffering a given Url, returns null
    Obj.prototype.playBufferedVideo = abstractFunction; //starts playback of buffered Url
    Obj.prototype.cancelBufferedVideo = abstractFunction; //destroys any buffered video on the dormant player
    Obj.prototype.getBufferedVideoUrl = abstractFunction;

    Obj.prototype.getDuration = abstractFunction; //returns Integer in milliseconds
    Obj.prototype.getPlayhead = abstractFunction; //returns Integer in milliseconds

    Obj.prototype.getDisplayRect = abstractFunction; //getDisplayRect() gets an Object {x,y,w,h} in your native window size
    Obj.prototype.setDisplayRect = abstractFunction; //setDisplayRect(x,y,w,h) in your native window size

    //Get the coordinates of the display area, relative to 1x1 resolution
    Obj.prototype.getDisplayRectRatio = function () {
        var displayArea = adfw.PlatformUtils.convertDimensionsToScreenRatio(this.getDisplayRect());
        return displayArea;
    };

    //Resize and move the video window, using 1x1 scale
    Obj.prototype.setDisplayRectRatio = function (x, y, w, h) {
        var displayArea = adfw.PlatformUtils.convertDimensionsFromScreenRatio(x, y, w, h);
        this.setDisplayRect(displayArea.x, displayArea.y, displayArea.w, displayArea.h);
    };

    Obj.prototype.getRelativeDisplayRect = abstractFunction; //getRelativeDisplayRect() gets an Object {x,y,w,h} relative to 960x540
    Obj.prototype.setRelativeDisplayRect = abstractFunction; //setRelativeDisplayRect(x,y,w,h) in pixels or units, relative to 960x540

    Obj.prototype.close = abstractFunction;
    Obj.prototype.getInternalPlayer = abstractFunction;

    Obj.prototype.getAdapterType = function () {
        return Obj.AdapterType.ABSTRACT;
    };

    Obj.State = {
        STOPPED: "STOPPED",
        PLAYING: "PLAYING",
        PAUSED: "PAUSED",
    };

    Obj.AdapterType = {
        HTML5: "HTML5",
        ORSAY_WEBKIT_SEF: "SEF_OW",
        TIZEN_WEBKIT_AVPLAY: "AVPLAY_TW",
        TIZEN_VOLT_LWPLAYER: "LWPLAYER",
        TIZEN_TVPLUS_IP: "TIZEN_TVPLUS_IP",
        TIZEN_VOLT_D2TV: "D2TV",
        TIZEN_VOLT_VIDEOWIDGET_V1: "VIDEOWIDGET_V1"
    };

    //Events that may be dispatched by the PlayerAdapter
    Obj.Events = {

        //- Active Player Events ----------------------------------------------------

        CURRENT_PLAYBACK_TIME: "CURRENT_PLAYBACK_TIME", //{ ms: Integer }
        SUBTITLE: "SUBTITLE", //{ duration: Integer, text: String, attributes: Array }
        CUSTOM: "CUSTOM", //{ arguments: [] }
        SPARSE_TRACK: "SPARSE_TRACK", // { time:Integer, data:String, raw:String }
        RENDER_ERROR: "RENDER_ERROR", //{ code: Integer, message: String }
        PLAYER_EXCEPTION: "PLAYER_EXCEPTION", //{ code: Integer, message: String }

        STREAM_INFO_READY: "STREAM_INFO_READY",
        STREAM_STOPPED: "STREAM_STOPPED", //{ ms: Integer }

        RENDERING_START: "RENDERING_START",
        RENDERING_COMPLETE: "RENDERING_COMPLETE",

        BUFFERING_START: "BUFFERING_START",
        BUFFERING_PROGRESS: "BUFFERING_PROGRESS", //{ percent: Integer }
        BUFFERING_COMPLETE: "BUFFERING_COMPLETE",

        RESOLUTION_CHANGED: "RESOLUTION_CHANGED",
        BITRATE_CHANGED: "BITRATE_CHANGED",

        AD_START: "AD_START",
        AD_END: "AD_END",

        DECODING_COMPLETE: "DECODING_COMPLETE",
        CONNECTION_FAILED: "CONNECTION_FAILED",
        AUTHENTICATION_FAILED: "AUTHENTICATION_FAILED",
        STREAM_NOT_FOUND: "STREAM_NOT_FOUND",
        NETWORK_DISCONNECTED: "NETWORK_DISCONNECTED",
        NETWORK_SLOW: "NETWORK_SLOW",

        //- Dormant (Prebuffering) Player Events ----------------------------------------------------

        PREBUFFERING_CURRENT_PLAYBACK_TIME: "PREBUFFERING_CURRENT_PLAYBACK_TIME", //{ ms: Integer }
        PREBUFFERING_BUFFERING_PROGRESS: "PREBUFFERING_BUFFERING_PROGRESS", //{ percent: Integer }
        PREBUFFERING_SUBTITLE: "PREBUFFERING_SUBTITLE", //{ subtitle: String, time: Integer, properties: Map }
        PREBUFFERING_CUSTOM: "PREBUFFERING_CUSTOM", //{ arguments: [] }
        PREBUFFERING_SPARSE_TRACK: "PREBUFFERING_SPARSE_TRACK", // { time:Integer, data:String }
        PREBUFFERING_RENDER_ERROR: "PREBUFFERING_RENDER_ERROR", //{ code: Integer, message: String }

        PREBUFFERING_STREAM_INFO_READY: "PREBUFFERING_STREAM_INFO_READY",

        PREBUFFERING_RENDERING_START: "PREBUFFERING_RENDERING_START",
        PREBUFFERING_RENDERING_COMPLETE: "PREBUFFERING_RENDERING_COMPLETE",

        PREBUFFERING_BUFFERING_START: "PREBUFFERING_BUFFERING_START",
        PREBUFFERING_BUFFERING_COMPLETE: "PREBUFFERING_BUFFERING_COMPLETE",

        PREBUFFERING_RESOLUTION_CHANGED: "PREBUFFERING_RESOLUTION_CHANGED",
        PREBUFFERING_BITRATE_CHANGED: "PREBUFFERING_BITRATE_CHANGED",

        PREBUFFERING_AD_START: "PREBUFFERING_AD_START",
        PREBUFFERING_AD_END: "PREBUFFERING_AD_END",

        PREBUFFERING_DECODING_COMPLETE: "PREBUFFERING_DECODING_COMPLETE",
        PREBUFFERING_CONNECTION_FAILED: "PREBUFFERING_CONNECTION_FAILED",
        PREBUFFERING_AUTHENTICATION_FAILED: "PREBUFFERING_AUTHENTICATION_FAILED",
        PREBUFFERING_STREAM_NOT_FOUND: "PREBUFFERING_STREAM_NOT_FOUND",
        PREBUFFERING_NETWORK_DISCONNECTED: "PREBUFFERING_NETWORK_DISCONNECTED",
        PREBUFFERING_NETWORK_SLOW: "PREBUFFERING_NETWORK_SLOW",

        //- Adapter Events ----------------------------------------------------

        DISPLAY_AREA_CHANGED: "DISPLAY_AREA_CHANGED", // {x:Integer, y:Integer, w:Integer, h:Integer}
        DEBUG_MESSAGE: "DEBUG_MESSAGE"
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW " + this.getAdapterType() + " ADAPTER]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW " + this.getAdapterType() + " ADAPTER]");
    }

    Obj.prototype.Execute = function () {
        //Unimplemented
        return null;
    }

    return Obj;
}());
adfw.SEFAdapter = (function () {
    "use strict";

    //Constructor: set up prototype chain
    var Obj = function (params) {
        adfw.PlayerAdapter.call(this);
        this.initialized = false;
        this.initialize(params);
    };
    Obj.prototype = Object.create(adfw.PlayerAdapter.prototype);
    Obj.prototype.constructor = Obj;
    Obj.Events = adfw.PlayerAdapter.Events;

    Obj.prototype.getAdapterType = function () {
        return adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF;
    };

    //Internal enum that allows detection of the SEF event type
    Obj._InternalPlayerEventCodes = {
        CONNECTION_FAILED: 1,
        AUTHENTICATION_FAILED: 2,
        STREAM_NOT_FOUND: 3,
        NETWORK_DISCONNECTED: 4,
        NETWORK_SLOW: 5,
        RENDER_ERROR: 6, // Number|errorCode
        RENDERING_START: 7,
        RENDERING_COMPLETE: 8,
        STREAM_INFO_READY: 9,
        DECODING_COMPLETE: 10,
        BUFFERING_START: 11,
        BUFFERING_COMPLETE: 12,
        BUFFERING_PROGRESS: 13, //Number|percentage
        CURRENT_PLAYBACK_TIME: 14, // Number|milliseconds
        AD_START: 15,
        AD_END: 16,
        RESOLUTION_CHANGED: 17,
        BITRATE_CHANGED: 18,
        SUBTITLE: 19, //String|text, Number|time, Object|properties
        CUSTOM: 20,
        SEEK: 30,
        SPARSE_TRACK: 101 // String|sparseTrackTime, String|stringData
    };

    //Need to provide at least 1 ID of a SEF Player Object. Providing a second SEF Player enables prebuffering.
    Obj.prototype.initialize = function (params) {
        var self = this;

        if (this.initialized === true) {
            return false;
        }

        if (typeof(params.playerId1) === "undefined" || params.playerId1 === null) {
            params.playerId1 = adfw.WebkitUtils.generateUniqueID("sefPlugin_1_");
        }
        if (typeof params.playerId1 === "string") {
            this._sef1 = document.getElementById(params.playerId1);
        }
        else if (typeof params.playerId1.Open !== "undefined") {
            this._sef1 = params.playerId1;
        }
        if (!this._sef1) {
            this._sef1 = adfw.OrsayWebkitUtils.generateSEFPlayer(params.playerId1);
        }
        if (!this._sef1) {
            throw "failed to create SEF Adapter with plugin ID: " + params.playerId1;
        }

        if (typeof(params.playerId2) === "undefined" || params.playerId2 === null) {
            params.playerId2 = adfw.WebkitUtils.generateUniqueID("sefPlugin_2_");
        }
        if (typeof params.playerId2 === "string") {
            this._sef2 = document.getElementById(params.playerId2);
        }
        else if (typeof params.playerId2.Open !== "undefined") {
            this._sef2 = params.playerId1;
        }

        if (!this._sef1) {
            throw "failed to initialize SEFAdapter: " + this._sef1 + " | " + this._sef2;
        }

        this._sef1.Open("Player", "1.010", "Player");

        this._OnEventHelperSEF1 = function () {
            self._handleInternalEvent.call(self, (self._player === self._sef1), arguments);
        };
        this._OnEventHelperSEF2 = function () {
            self._handleInternalEvent.call(self, (self._player === self._sef2), arguments);
        };

        this._sef1.OnEvent = this._OnEventHelperSEF1;

        if (true === params.enablePrebuffering) {
            if (!this._sef2) {
                this._sef2 = adfw.OrsayWebkitUtils.generateSEFPlayer(params.playerId2);
            }
            if (!this._sef2) {
                throw "failed to create SEF Adapter with plugin ID: " + params.playerId2;
            }
            this._sef2.Open("Player", "1.010", "Player");
            this._sef2.OnEvent = this._OnEventHelperSEF2;
        }

        this._player = this._sef1;
        this._playhead = null;
        this.initialized = true;

        this.initializePrebufferDeferred();
        this.prebufferDeferred.resolve();

        this.internalPlayerDisplayArea = {x: 0, y: 0, w: 960, h: 540};
    };

    //Initialize player with a Url
    Obj.prototype.initPlayer = function (url) {
        return this._player.Execute("InitPlayer", url);
    };

    //Starts playback. If given a number in milliseconds, will start playback at that time.
    Obj.prototype.startPlayback = function (milliseconds) {
        this.log("StartPlayback: " + milliseconds);
        var retVal;
        if (typeof(milliseconds) === "number" && milliseconds > 999) {
            var sec = (milliseconds / 1000);
            var retVal = this._player.Execute("StartPlayback", sec);
        }

        else {
            retVal = this._player.Execute("StartPlayback");
        }
        this._setDisplayArea();
        return retVal;
    };

    //Play/Pause/Stop/Resume
    Obj.prototype.play = function (url, milliseconds) {
        //this.log("play " + url);
        this._playhead = 0;
        var retVal;
        if (typeof milliseconds === "number" && milliseconds > 999) {
            var sec = (milliseconds / 1000);
            //this.log("Play: " + sec);
            retVal = this._player.Execute("Play", url, sec);
        }
        else {
            retVal = this._player.Execute("Play", url);
        }
        //this.log("play: " + retVal);
        this._setDisplayArea();
        return retVal;
    };
    Obj.prototype.stop = function () {
        //this.log("stop");
        this._playhead = null;
        var returnVal = this._player.Execute("Stop");
        this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_STOPPED);
        return returnVal;
    };
    Obj.prototype.pause = function () {
        //this.log("pause");
        return this._player.Execute("Pause");
    };
    Obj.prototype.resume = function () {
        //this.log("resume");
        return this._player.Execute("Resume");
    };

    //Jumps forward or backward given an unsigned integer representing milliseconds. It actually needs to round down to the lowest second.
    Obj.prototype.jump = function (ms) {
        this.log("jump " + ms);
        var sec = Math.abs(Math.round(ms / 1000));
        if (typeof ms === "number" && ms < 0) {
            return this._player.Execute("JumpBackward", sec);
        }
        else {
            return this._player.Execute("JumpForward", sec);
        }
    };
    Obj.prototype.jumpForward = function (ms) {
        if (typeof ms === "number" && ms > 0) {
            return this.jump(ms);
        }
        else {
            return false;
        }
    };
    Obj.prototype.jumpBackward = function (ms) {
        if (typeof ms === "number" && ms > 0) {
            return this.jump(-ms);
        }
        else {
            return false;
        }
    };

    //Gets the duration, in MS, of the currently playing video.
    Obj.prototype.getDuration = function () {
        return this._player.Execute("GetDuration");
    };

    //Gets the current playhead
    Obj.prototype.getPlayhead = function () {
        return this._playhead;
    };

    //Get the coordinates of the display area, relative to 960x540 resolution
    Obj.prototype.getRelativeDisplayRect = function () {
        return {
            x: this.internalPlayerDisplayArea.x,
            y: this.internalPlayerDisplayArea.y,
            w: this.internalPlayerDisplayArea.w,
            h: this.internalPlayerDisplayArea.h
        };
    };

    //Gets the display area relative to the window's true size
    Obj.prototype.getDisplayRect = function () {
        return adfw.PlatformUtils.scaleFrom960(this.getRelativeDisplayRect());
    };

    //Resize and move the video window, using 960x540 scale
    Obj.prototype.setRelativeDisplayRect = function (x, y, w, h) {

        var changeObject = {
            oldx: this.internalPlayerDisplayArea.x,
            oldy: this.internalPlayerDisplayArea.y,
            oldw: this.internalPlayerDisplayArea.w,
            oldh: this.internalPlayerDisplayArea.h
        };

        if (typeof(x) === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            this.internalPlayerDisplayArea = x;
        }
        else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            this.internalPlayerDisplayArea = {x: x, y: y, w: w, h: h};
        }
        else {
            var error = "Invalid display area. Aborting setRelativeDisplayRect";
            this.log(error);
            throw error;
        }

        this._setDisplayArea();

        changeObject.x = this.internalPlayerDisplayArea.x;
        changeObject.y = this.internalPlayerDisplayArea.y;
        changeObject.w = this.internalPlayerDisplayArea.w;
        changeObject.h = this.internalPlayerDisplayArea.h;

        this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, changeObject);
    };

    //Resize and move the video window, using true window size
    Obj.prototype.setDisplayRect = function (x, y, w, h) {

        var dimms = {};

        if (typeof(x) === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            dimms = x;
        }
        else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            dimms = {x: x, y: y, w: w, h: h};
        }
        else {
            var error = "Invalid display area. Aborting setDisplayRect";
            this.log(error);
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
            //return;
        }

        var scaledDimms = adfw.PlatformUtils.scaleTo960(dimms);
        this.log("setDisplayRect scaledDimms: " + scaledDimms.x + " | " + scaledDimms.y + " | " + scaledDimms.w + " | " + scaledDimms.h);

        if (scaledDimms.w > 960) {
            scaledDimms.w = 960;
        }
        if (scaledDimms.h > 540) {
            scaledDimms.h = 540;
        }

        this.setRelativeDisplayRect(scaledDimms);
    };

    Obj.prototype._getCurrentSEFString = function () {
        return (this._getDormantPlayer() === this._sef2) ? "1 (a)" : "2 (a)";
    };

    Obj.prototype._getDormantSEFString = function () {
        return (this._getDormantPlayer() === this._sef1) ? "1 (d)" : "2 (d)";
    };

    //The buffer deferred/promise refers to the need to wait until video starts buffering before trying to play it. If we don't wait, it will freeze the SEF player.
    Obj.prototype.initializePrebufferDeferred = function () {
        if (this.prebufferDeferred) {
            this.prebufferDeferred.reject('reinitialized');
        }
        this.prebufferDeferred = adfw.Q.defer();
        this.prebufferPromise = this.prebufferDeferred.promise;
    };

    //Starts buffering a given Url on the dormant player.
    Obj.prototype.startBufferingVideo = function (url, ms, prefunc) {

        //We do not prebuffer on any models except for 2013. 2014, and 2015 Orsay
        if (!(adfw.OrsayWebkitUtils.is2013Model() || adfw.OrsayWebkitUtils.is2014Model() || adfw.OrsayWebkitUtils.is2015Model())) {
            this.log("Refusing to prebuffer - only 2013, 2014, and 2015 Orsay models are capable of prebuffering (current platform is " + adfw.OrsayWebkitUtils.getInfolinkVersion() + ")");
            return false;
        }

        this.log("buffer " + url + " at " + ms + " | prefunc=" + prefunc);
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            this.log("Abort prebuffer: prebuffering is disabled/unsupported");
            return false;
        }
        dormantPlayer.Execute("Stop");

        var retVal;

        var finalUrl = url;
        if (!finalUrl.indexOf("CONTROL_TYPE=PREBUFFERING") >= 0) {
            finalUrl += "|CONTROL_TYPE=PREBUFFERING";
        }

        this.initializePrebufferDeferred();

        dormantPlayer.Execute("InitPlayer", finalUrl);
        if (typeof prefunc === "function") {
            prefunc(dormantPlayer);
        }

        if (typeof ms !== "number" || ms < 1000) {
            retVal = dormantPlayer.Execute("StartPlayback");
        }
        else {
            retVal = dormantPlayer.Execute("StartPlayback", Math.round(ms / 1000));
        }
        //this.log("prebuffer: " + finalUrl);
        this._prebufferedUrl = url;
        //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "[PA][" + this._getDormantSEFString() + "]: Start buffering on : " + this._prebufferedUrl});
    };

    //Report that the video to prebuffer has started buffering.
    Obj.prototype.handleBufferedVideoProgress = function (percent) {
        this.prebufferDeferred.resolve();
        this.log("Prebuffer " + percent + "% w/updated promise...");
    };

    //Swaps the active player with the dormant (prebuffered) player.
    Obj.prototype.playBufferedVideo = function () {
        var self = this;
        if (!this._prebufferedUrl || !this.prebufferPromise) {
            this.log("ERROR: prebufferedUrl=" + this._prebufferedUrl + " | promise=" + this.prebufferPromise);
            return false;
        }
        if (!this._getDormantPlayer()) {
            var error = "Error: SEF2 was not provided upon initialization, therefore there is no secondary player to begin buffered playback on. Please use initialize(params.playerId1, params.playerId2) first.";
            this.error(error);
            throw error;
        }
        this.stop();
        this.log("starting buffered video (contingent on promise)...");

        return this.prebufferPromise
            .then(this.getBufferedVideoStartHelper())
            .catch(this.getBufferedVideoBufferingTimeoutHelper())
            .timeout(adfw.Config.get("BUFFERED_RESOURCE_TIMEOUT"));
    };

    Obj.prototype.getBufferedVideoBufferingTimeoutHelper = function () {
        var self = this;
        if (this.storedBufferedVideoBufferingTimeoutHelper) {
            return this.storedBufferedVideoBufferingTimeoutHelper;
        }
        else {
            this.storedBufferedVideoBufferingTimeoutHelper = adfw.Utils.bind(function (err) {
                self.log("Buffered video promise broken: " + err);
                if (err !== 'reinitialized') {
                    self.cancelBufferedVideo();
                    self.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED);
                }
            }, this);
            return this.storedBufferedVideoBufferingTimeoutHelper;
        }

    }

    Obj.prototype.getBufferedVideoStartHelper = function () {
        if (this.storedBufferedVideoStartHelper) {
            return this.storedBufferedVideoStartHelper;
        }
        else {
            this.storedBufferedVideoStartHelper = adfw.Utils.bind(function () {
                this.log("resume buffered video : " + this._prebufferedUrl);
                this.swapPlayers();
                this._setDisplayArea();
                var retVal = this._player.Execute("Resume");
                this.initializePrebufferDeferred()
                return retVal;
            }, this);
            return this.storedBufferedVideoStartHelper;
        }
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.cancelBufferedVideo = function () {
        this.log("cancel buffered video: " + this._prebufferedUrl);
        this.initializePrebufferDeferred();
        this._prebufferedUrl = null;
        var dormantPlayer = this._getDormantPlayer();
        if (dormantPlayer) {
            dormantPlayer.Execute("Stop");
        }
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.getBufferedVideoUrl = function () {
        return this._prebufferedUrl;
    };

    //Other less commonly used functions
    Obj.prototype.close = function () {
        this.log("close!");
        this._sef1.Execute("Close");
        if (this._sef2) {
            this._sef2.Execute("Close");
        }
    };
    Obj.prototype.getInternalPlayer = function () {
        return this._player;
    };

    //Allow app developers to call Execute on the current player
    Obj.prototype.Execute = function () {
        var command = arguments[0];
        var logStr = "Execute ";
        for (var i = 0; i < arguments.length; i++) {
            logStr += " | " + arguments[i];
        }
        this.log(logStr);
        //if(this._getDormantPlayer() === this._sef1) {
        //	adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "Execute [1]: " + command});
        //}
        //else {
        //	adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "Execute [2]: " + command});
        //}
        if (command === "SetDisplayArea") {
            this.setRelativeDisplayRect(arguments[1], arguments[2], arguments[3], arguments[4]);
        }
        else {
            //this.log("Execute(" + arguments[0] + ")");
            return this._player.Execute.apply(this._player, arguments);
        }
    };

    //Allow app developers to call Execute on both players (both Dormant and Active)
    Obj.prototype.ExecuteOnAll = function () {
        var command = arguments[0];
        //this.log("Execute " + command + " | " + arguments[1]);
        //if(this._getDormantPlayer() === this._sef1) {
        //	adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "Execute [1]: " + command});
        //}
        //else {
        //	adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "Execute [2]: " + command});
        //}
        if (command === "SetDisplayArea") {
            this.setRelativeDisplayRect(arguments[1], arguments[2], arguments[3], arguments[4]);
        }
        else {
            if (this._getDormantPlayer()) {
                this._getDormantPlayer().Execute.apply(this._getDormantPlayer(), arguments);
                //this.log("D: Execute(" + arguments[0] + ")");
            }
            //this.log("A: Execute(" + arguments[0] + ")");
            return this._player.Execute.apply(this._player, arguments);
        }
    };

    //Gets the dormant player (the one that is not being used to play any video - we'll use this one for prebuffering)
    Obj.prototype._getDormantPlayer = function () {
        if (!this._sef2) {
            return null;
        }
        if (this._sef1 === this._player) {
            return this._sef2;
        }
        else {
            return this._sef1;
        }
    };

    //Stop the currently active player, and make the dormant player become the active player
    Obj.prototype.swapPlayers = function () {
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            return;
        }
        else {
            this.stop();
            //this._player.OnEvent = null;
            //this.log("swapPlayers ->" + (this._player === this._sef1 ? "sef2" : "sef1"));
            this._player = dormantPlayer;
            //this._player.OnEvent = this._OnEventHelper;
            this._prebufferedUrl = null;
        }
    };

    Obj.prototype._setDisplayArea = function () {
        if (this.internalPlayerDisplayArea) {
            this._player.Execute("SetDisplayArea", this.internalPlayerDisplayArea.x, this.internalPlayerDisplayArea.y, this.internalPlayerDisplayArea.w, this.internalPlayerDisplayArea.h);
            if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_WEBKIT) {
                //If Tizen, also scale the OBJECT tags
                var scaledDimms = adfw.PlatformUtils.scaleFrom960(this.internalPlayerDisplayArea);
                if (this._sef1) {
                    this._sef1.style.left = scaledDimms.x;
                    this._sef1.style.top = scaledDimms.y;
                    this._sef1.style.width = scaledDimms.w;
                    this._sef1.style.height = scaledDimms.h;
                }
                if (this._sef2) {
                    this._sef2.style.left = scaledDimms.x;
                    this._sef2.style.top = scaledDimms.y;
                    this._sef2.style.width = scaledDimms.w;
                    this._sef2.style.height = scaledDimms.h;
                }
            }
        }
    };

    var RenderErrorCode = {
        0: "Unknown",
        1: "Unsupported container",
        2: "Unsupported video codec",
        3: "Unsupported audio codec",
        4: "Unsupported video resolution"
    };

    //Single handler to detect event type and then delegate events to the correct handler
    Obj.prototype._handleInternalEvent = function (isActivePlayer, args) {
        var type = args[0];

        // //Debug output
        // if(type !== Obj._InternalPlayerEventCodes.CURRENT_PLAYBACK_TIME && type !== Obj._InternalPlayerEventCodes.BUFFERING_PROGRESS) {
        // 	var typeString = isActivePlayer ? "" : "PREBUFFERING_";
        // 	for(var prop in Obj._InternalPlayerEventCodes) {
        // 		if(Obj._InternalPlayerEventCodes.hasOwnProperty(prop)) {
        // 			if(Obj._InternalPlayerEventCodes[prop] === type) {
        // 				typeString += prop;
        // 			}
        // 		}
        // 	}
        // 	this.log("SEF Event: " + typeString);
        // }


        args = Array.prototype.slice.call(args, 1, args.length);
        if (type === Obj._InternalPlayerEventCodes.CONNECTION_FAILED) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_CONNECTION_FAILED);
                this._prebufferedUrl = null;
                this._getDormantPlayer().Execute("Stop");
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.AUTHENTICATION_FAILED) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.AUTHENTICATION_FAILED);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_AUTHENTICATION_FAILED);
                this._prebufferedUrl = null;
                this._getDormantPlayer().Execute("Stop");
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.STREAM_NOT_FOUND) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_NOT_FOUND);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND);
                this._prebufferedUrl = null;
                this._getDormantPlayer().Execute("Stop");
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.NETWORK_DISCONNECTED) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.NETWORK_DISCONNECTED);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_NETWORK_DISCONNECTED);
                this._prebufferedUrl = null;
                this._getDormantPlayer().Execute("Stop");
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.NETWORK_SLOW) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.NETWORK_SLOW);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_NETWORK_SLOW);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.RENDERING_START) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_START);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDERING_START);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.RENDERING_COMPLETE) {
            if (isActivePlayer) {
                this._player.Execute("Stop");
                this.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_COMPLETE);
            }
            else {
                this._getDormantPlayer().Execute("Stop");
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDERING_COMPLETE);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.STREAM_INFO_READY) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_INFO_READY);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_INFO_READY);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.DECODING_COMPLETE) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.DECODING_COMPLETE);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_DECODING_COMPLETE);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.BUFFERING_START) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_START);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_START);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.BUFFERING_COMPLETE) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_COMPLETE);
            }
            else {
                this.handleBufferedVideoProgress(100);
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_COMPLETE);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.AD_START) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.AD_START);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_AD_START);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.AD_END) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.AD_END);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_AD_END);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.RESOLUTION_CHANGED) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.RESOLUTION_CHANGED);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RESOLUTION_CHANGED);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.BITRATE_CHANGED) {
            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.BITRATE_CHANGED);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BITRATE_CHANGED);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.RENDER_ERROR) {

            var eventMap = {
                code: args[0],
                message: RenderErrorCode[args[0]]
            };

            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, eventMap);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, eventMap);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.BUFFERING_PROGRESS) {
            var eventMap = {
                percent: args[0]
            };

            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_PROGRESS, eventMap);
            }
            else {
                //this.handleBufferedVideoProgress(args[0]); //I commented this out because i only want the promise to complete after 100%
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_PROGRESS, eventMap);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.CURRENT_PLAYBACK_TIME) {

            var ms = args[0];

            try {
                if (ms) {
                    var parsedInteger = parseInt(ms, 10);
                    if (!isNaN(parsedInteger)) {
                        ms = parsedInteger;
                    }
                }
            }
            catch (e) {
            }

            var eventMap = {
                ms: ms
            };

            //this.log("CURRENT_PLAYBACK_TIME: " + isActivePlayer + " | " + ms);

            if (isActivePlayer) {
                if (this._playhead === ms) {
                    return;
                }
                this._playhead = ms;
                this.dispatchEvent(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, eventMap);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_CURRENT_PLAYBACK_TIME, eventMap);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.SUBTITLE) {
            var eventMap = {
                text: args[0],
                duration: args[1],
                attributes: args[2]
            };

            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.SUBTITLE, eventMap);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_SUBTITLE, eventMap);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.SPARSE_TRACK) {
            var eventMap = {
                time: args[0],
                data: args[1],
                raw: args[1]
            };

            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.SPARSE_TRACK, eventMap);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_SPARSE_TRACK, eventMap);
            }
        }

        else if (type === Obj._InternalPlayerEventCodes.CUSTOM) {
            var eventMap = {
                arguments: args
            };

            if (isActivePlayer) {
                this.dispatchEvent(adfw.PlayerAdapter.Events.CUSTOM, eventMap);
            }
            else {
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_CUSTOM, eventMap);
            }
        }

        else {
            //var errorMessage = "ERROR: Unhandled Player event: " + type + " |";
            //for(var i = 1; i < args.length; i++) {
            //	errorMessage += " | " + args[i];
            //}
            //this.log(errorMessage);
        }
    };

    return Obj;
}());
adfw.HTML5Adapter = (function () {
    "use strict";

    var dummyFunction = function () {
    }; //Do nothing

    //Constructor: set up prototype chain
    var Obj = function (params) {
        adfw.PlayerAdapter.call(this);
        this.initialized = false;
        this.initialize(params);
    };
    Obj.prototype = Object.create(adfw.PlayerAdapter.prototype);
    Obj.prototype.constructor = Obj;
    Obj.Events = adfw.PlayerAdapter.Events;

    Obj.prototype.getAdapterType = function () {
        return adfw.PlayerAdapter.AdapterType.HTML5;
    };

    //Need to provide at least 1 ID of a Video element. Providing a second enables prebuffering.
    Obj.prototype.initialize = function (params) {
    	this.log("[ADFW HTML5Adapter] initialize");
        var self = this;

        if (this.initialized === true) {
            return false;
        }

        if (!params.playerId1) {
            params.playerId1 = adfw.WebkitUtils.generateUniqueID("videoPlugin_1_");
        }
        if (typeof params.playerId1 === "string") {
            this._video1 = document.createElement("video");
            document.body.appendChild(this._video1);
            this.hookEventListeners(this._video1);
            this._video1.id = params.playerId1;
            this._video1.style.display = "";
            this._video1.style.width = 960;
            this._video1.style.height = 540;
            this._video1.style.position = "fixed";
            this._video1.style.top = 0;
            this._video1.style.left = 0;
        }
        if (!this._video1) {
            throw "failed to create video Adapter with plugin ID: " + params.playerId1;
        }

        if (true === params.enablePrebuffering) {
            if (!params.playerId2) {
                params.playerId2 = adfw.WebkitUtils.generateUniqueID("videoPlugin_2_");
            }
            if (typeof params.playerId2 === "string") {
                this._video2 = document.createElement("video");
                document.body.appendChild(this._video2);
                this.hookEventListeners(this._video2);
                this._video2.id = params.playerId2;
                this._video2.style.display = "none";
                this._video2.style.width = 960;
                this._video2.style.height = 540;
                this._video2.style.position = "fixed";
                this._video2.style.top = 0;
                this._video2.style.left = 0;
            }
            if (!this._video2) {
                throw "failed to create video Adapter with plugin ID: " + params.playerId2;
            }
        }

        this._player = this._video1;
        this._playhead = null;
        this.initialized = true;

        this.internalPlayerDisplayArea = {x: 0, y: 0, w: 1280, h: 720};
        this.setDisplayRect(this.internalPlayerDisplayArea);
    };

    //Initialize player with a Url
    Obj.prototype.initPlayer = function (url) {
    	this.log("[ADFW HTML5Adapter] initPlayer : " + url);
        //this.log("Initializing player with: " + url);
        this._player.src = url;
        this._player.load();
    };

    //Starts playback. If given a number in milliseconds, will start playback at that time.
    Obj.prototype.startPlayback = function (milliseconds) {
    	this.log("[ADFW HTML5Adapter] startPlayback : " + milliseconds + "ms");
        this._playhead = typeof(milliseconds) === "number" && milliseconds > 999 ? milliseconds / 1000 : 0;
        try {
            //TODO
            this._player.currentTime = this._playhead;
        }
        catch (e) {
        }

        this._player.play();
    };

    //Play/Pause/Stop/Resume
    Obj.prototype.play = function (url, milliseconds) {
    	this.log("[ADFW HTML5Adapter] play");
        //this.log("play " + url);
        this.initPlayer(url);
        this.startPlayback(milliseconds);
    };
    Obj.prototype.stop = function () {
        //this.log("stop");
        this.log("[ADFW HTML5Adapter] stop");
        this._playhead = null;
        this._player.pause();
        this._player.src = "";
        this._player.load();
        this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_STOPPED);
    };
    Obj.prototype.pause = function () {
        //this.log("pause");
        this.log("[ADFW HTML5Adapter] pause");
        this._player.pause();
    };
    Obj.prototype.resume = function () {
        //this.log("resume");
        this._player.play();
    };

    //Jumps forward or backward given an unsigned integer representing milliseconds. It actually needs to round down to the lowest second.
    Obj.prototype.jump = function (ms) {
    	this.log("[ADFW HTML5Adapter] jump : " + ms + "ms");
        //this.log("jump " + ms);
        var sec = Math.round(ms / 1000);
        if (typeof sec === "number") {
            return this._player.currentTime = this._player.currentTime + sec;
        }
        return false;
    };
    Obj.prototype.jumpForward = function (ms) {
	this.log("[ADFW HTML5Adapter] jumpForward : " + ms + "ms");
        if (typeof ms === "number" && ms > 0) {
            return this.jump(ms);
        }
        else {
            return false;
        }
    };
    Obj.prototype.jumpBackward = function (ms) {
	this.log("[ADFW HTML5Adapter] jumpBackward : " + ms + "ms");
        if (typeof ms === "number" && ms > 0) {
            return this.jump(-ms);
        }
        else {
            return false;
        }
    };

    //Gets the duration, in MS, of the currently playing video.
    Obj.prototype.getDuration = function () {
    	this.log("[ADFW HTML5Adapter] getDuration : " + Math.floor(this._player.duration * 1000));
        return Math.floor(this._player.duration * 1000);
    };

    //Gets the current playhead
    Obj.prototype.getPlayhead = function () {
    	this.log("[ADFW HTML5Adapter] getPlayhead : " + Math.floor(this._player.currentTime));
        return Math.floor(this._player.currentTime);
    };

    //Get the coordinates of the display area, relative to 960x540 resolution
    Obj.prototype.getRelativeDisplayRect = function () {
        return adfw.PlatformUtils.scaleTo960(this.internalPlayerDisplayArea);
    };

    //Gets the display area relative to the window's true size
    Obj.prototype.getDisplayRect = function () {
        return {
            x: this.internalPlayerDisplayArea.x,
            y: this.internalPlayerDisplayArea.y,
            w: this.internalPlayerDisplayArea.w,
            h: this.internalPlayerDisplayArea.h,
        };
    };

    //Resize and move the video window, using 960x540 scale
    Obj.prototype.setRelativeDisplayRect = function (x, y, w, h) {
        this.log("[ADFW HTML5Adapter] setRelativeDisplayRect: " + x + ", " + y + ", " + w + ", " + h);
        var displayArea = adfw.PlatformUtils.scaleFrom960(x, y, w, h);
        this.setDisplayRect(displayArea.x, displayArea.y, displayArea.w, displayArea.h);
    };

    //Resize and move the video window, using true window size
    Obj.prototype.setDisplayRect = function (x, y, w, h) {
		this.log("[ADFW HTML5Adapter] setDisplayRect: " + x + ", " + y + ", " + w + ", " + h);
        if (typeof(y) !== "number" || typeof(w) !== "number" || typeof(h) !== "number") {
            if (!x || typeof(x.x) !== "number" || typeof(x.y) !== "number" || typeof(x.w) !== "number" || typeof(x.h) !== "number") {
                return false;
            }
            else {
                h = x.h;
                w = x.w;
                y = x.y;
                x = x.x;
            }
        }

        var changeObject = {
            oldx: this.internalPlayerDisplayArea.x,
            oldy: this.internalPlayerDisplayArea.y,
            oldw: this.internalPlayerDisplayArea.w,
            oldh: this.internalPlayerDisplayArea.h,
            x: x,
            y: y,
            w: w,
            h: h,
        };

        this.internalPlayerDisplayArea.x = x;
        this.internalPlayerDisplayArea.y = y;
        this.internalPlayerDisplayArea.w = w;
        this.internalPlayerDisplayArea.h = h;

        //this.log("set corrected display area: " + x + ", " + y + ", " + w + ", " + h);

        this._video1.style.left = x + "px";
        this._video1.style.top = y + "px";
        this._video1.style.width = w + "px";
        this._video1.style.height = h + "px";
        if (this._video2) {
            this._video2.style.left = x + "px";
            this._video2.style.top = y + "px";
            this._video2.style.width = w + "px";
            this._video2.style.height = h + "px";
        }


        this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, changeObject);
        //this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED);
    };

    Obj.prototype.setFullScreen = function () {
	this.log("[ADFW HTML5Adapter] setFullScreen");
        this._video1.style.left = "0px";
        this._video1.style.top = "0px";
        this._video1.style.width = "100%";
        this._video1.style.height = "100%";
        if (this._video2) {
            this._video2.style.left = "0px";
            this._video2.style.top = "0px";
            this._video2.style.width = "100%";
            this._video2.style.height = "100%";
        }
    };

    //Starts buffering a given Url on the dormant player.
    Obj.prototype.startBufferingVideo = function (url, ms, prefunc) {
    	this.log("[ADFW HTML5Adapter] startBufferingVideo");
        if (url === this._prebufferedUrl) {
            return false;
        }
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            this.log("Abort prebuffer: prebuffering is disabled/unsupported");
            return false;
        }
        if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_WEBKIT || adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.ORSAY_WEBKIT) {
            //this.log("Refusing to prebuffer due to HTML5 prebuffering not working on TV!");
            return false;
        }


        dormantPlayer.src = "";
        dormantPlayer.src = url;
        dormantPlayer.load();

        if (typeof ms === "number" && ms > 500) {
            this._prebufferingSeekPosition = ms;
        }
        else {
            this._prebufferingSeekPosition = null;
        }


        if (typeof prefunc === "function") {
            prefunc(dormantPlayer);
        }
        this._prebufferedUrl = url;
        //this.log("buffering " + url + " with resume point: " + this._prebufferingSeekPosition);
        //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "[PA][" + this._getDormantSEFString() + "]: Start buffering on : " + this._prebufferedUrl});
    };

    //Swaps the active player with the dormant (prebuffered) player.
    Obj.prototype.playBufferedVideo = function () {
    	this.log("[ADFW HTML5Adapter] playBufferedVideo : " + this._prebufferedUrl);
        //this.log("play buffered video: " + this._prebufferedUrl);
        if (!this._prebufferedUrl) {
            return false;
        }
        if (!this._getDormantPlayer()) {
            return false;
            //throw "Error: SEF2 was not provided upon initialization, therefore there is no secondary player to begin buffered playback on. Please use initialize(sef1ID, sef2ID) first.";
        }

        this.swapPlayers();
        //adfw.Events.dispatchEvent(adfw.Events.DEBUG_MESSAGE, {message : "[PA][" + this._getCurrentSEFString() + "]: Play prebuffered ad"});
        this._prebufferedUrl = null;
        this._prebufferingSeekPosition = null;
        this._player.play();
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.cancelBufferedVideo = function () {
    	this.log("[ADFW HTML5Adapter] cancelBufferedVideo");
        this._prebufferedUrl = null;
        this._prebufferingSeekPosition = null;
        var dormantPlayer = this._getDormantPlayer();
        if (dormantPlayer) {
            dormantPlayer.pause();
            dormantPlayer.src = "";
            dormantPlayer.load();
        }
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.getBufferedVideoUrl = function () {
        return this._prebufferedUrl;
    };

    //Other less commonly used functions
    Obj.prototype.close = function () {
        return false;
    };
    Obj.prototype.getInternalPlayer = function () {
        return this._player;
    };

    //Gets the dormant player (the one that is not being used to play any video - we'll use this one for prebuffering)
    Obj.prototype._getDormantPlayer = function () {
        if (!this._video2) {
            return null;
        }
        if (this._video1 === this._player) {
            return this._video2;
        }
        else {
            return this._video1;
        }
    };

    //Stop the currently active player, and make the dormant player become the active player
    Obj.prototype.swapPlayers = function () {
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            return;
        }
        else {
            this.stop();
            //this._player.OnEvent = null;
            //this.log("swapPlayers ->" + (this._player === this._sef1 ? "sef2" : "sef1"));
            this._player.style.display = "none";
            this._player = dormantPlayer;
            this._player.style.display = "";
            //this._player.OnEvent = this._OnEventHelper;
            this._prebufferedUrl = null;
        }
    };

    Obj.prototype._setRelativeDisplayRect = function () {
        //TODO
        return "UNIMPLEMENTED"
    };

    Obj.prototype.hookEventListeners = function (videoElement) {
        this.log("[ADFW HTML5Adapter] hookEventListeners");
        var self = this;

        //current playback time
        videoElement.addEventListener("timeupdate", function (evt) {
            if (self._player === this) {
                var time = Math.floor(this.currentTime * 1000);
                self.dispatchEvent("CURRENT_PLAYBACK_TIME", {
                    ms: time,
                })
            }
        });

        //buffering progress
        videoElement.addEventListener("TODO", function (evt) {
            if (self._player === this) {
                self.dispatchEvent("BUFFERING_PROGRESS", {})
            }
            else {
                self.dispatchEvent("PREBUFFERING_BUFFERING_PROGRESS", {})
            }
        });

        //subtitle
        videoElement.addEventListener("TODO", function (evt) {
            if (self._player === this) {
                self.dispatchEvent("SUBTITLE", {})
            }
            else {
                self.dispatchEvent("PREBUFFERING_SUBTITLE", {})
            }
        });

        //render error
        videoElement.addEventListener("error", function (evt) {
            //console.log("videoElement error! " + (self._player === this) + " | " + evt);
            //console.dir(evt);
            //if (self._player === this) {
            //    self.dispatchEvent("RENDER_ERROR", {
            //        event: evt
            //    })
            //}
            //else {
            //    self.dispatchEvent("PREBUFFERING_RENDER_ERROR", {
            //        event: evt
            //    })
            //}
        }, true);

        //stream info ready
        videoElement.addEventListener("loadedmetadata", function (evt) {
            if (self._player === this) {
                self.dispatchEvent("STREAM_INFO_READY", {})
            }
            else {
                self.dispatchEvent("PREBUFFERING_STREAM_INFO_READY", {})
                //Seek to position
                if (typeof self._prebufferingSeekPosition === "number") {
                    try {
                        var time = Math.round(self._prebufferingSeekPosition / 1000);
                        self._getDormantPlayer().currentTime = time;
                        //console.log("PREBUFFERING STREAM INFO READY SETS TIME: " + time);
                    } catch (e) {
                    }
                    self._prebufferingSeekPosition = null;
                }
            }
        });

        //rendering start
        videoElement.addEventListener("playing", function (evt) {
            if (self._player === this) {
                self.dispatchEvent("RENDERING_START");
            }
            else {

            }
        });

        //rendering complete
        videoElement.addEventListener("ended", function (evt) {
            videoElement.src = "";
            if (self._player === this) {
                self.dispatchEvent("RENDERING_COMPLETE");
            }
            else {

            }
        });

        // videoElement.addEventListener("timeupdate", function(evt) {
        // 	if(self._player === this) {
        // 		self.dispatchEvent("CURRENT_PLAYBACK_TIME", {
        // 			ms: this.currentTime * 1000,
        // 		})
        // 	}
        // });
    }

    return Obj;
}());
adfw.LWPlayerAdapter = (function () {
    "use strict";
    //Constructor: set up prototype chain
    var Obj = function () {
        adfw.PlayerAdapter.call(this);
        this.initialized = false;
        this.lwPlayer = null;
        this.playhead = 0;
        this.duration = 0;
        this.playerWrapper = null;
        this.prebufferedUrl = null;
        this.videoInitDeferred = null;

        this.log("****************************************");
        this.log("INITIALIZING LWPLAYER ADAPTER...");
        this.initialize();
        this.log("****************************************");
    };
    Obj.prototype = Object.create(adfw.PlayerAdapter.prototype);
    Obj.prototype.constructor = Obj;
    Obj.Events = adfw.PlayerAdapter.Events;

    Obj.prototype.getAdapterType = function () {
        return adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_LWPLAYER;
    };

    /*    Obj.prototype.PlayerState = {
     /!* COMMON *!/
     D2TV_MESSAGE_UNKNOWN: 0, /!**< Unknown message type *!/
     D2TV_MESSAGE_END_OF_STREAM: 1, /!**< End of stream message type *!/
     D2TV_MESSAGE_INIT_COMPLETE: 2,
     D2TV_MESSAGE_BEGIN_OF_STREAM: 3, /!**< Streaming begin message type *!/
     D2TV_MESSAGE_ERROR: 4, /!**< Error message type *!/
     D2TV_MESSAGE_WARNING: 5, /!**< Warning message type *!/
     D2TV_MESSAGE_STATE_CHANGED: 6, /!**< State change message type *!/
     D2TV_MESSAGE_STATE_INTERRUPTED: 7, /!**< State change by interrupt *!/
     D2TV_MESSAGE_READY_TO_RESUME: 8, /!**< Ready to resume message type *!/

     /!* PLAYER *!/
     D2TV_MESSAGE_CONNECTING: 9, /!**< Connecting message type *!/
     D2TV_MESSAGE_CONNECTED: 10, /!**< Rtspsrc has successed to connecting to server *!/
     D2TV_MESSAGE_CONNECTION_TIMEOUT: 11, /!**< Connection timeout message type *!/
     D2TV_MESSAGE_BUFFERING: 12, /!**< Buffering message type *!/
     D2TV_MESSAGE_STOP_SUCCESS: 13,

     D2TV_MESSAGE_UPDATE_SUBTITLE: 14, /!**< Update subtitle type *!/
     D2TV_MESSAGE_FILE_NOT_SUPPORTED: 15, /!**< Not supported file *!/
     D2TV_MESSAGE_FILE_NOT_FOUND: 16, /!**< Not founded file *!/
     D2TV_MESSAGE_SEEK_COMPLETED: 17, /!**< Seek completed *!/
     D2TV_MESSAGE_SUBTITLE_TEXT: 18,
     D2TV_MESSAGE_DURATION: 19,
     D2TV_MESSAGE_CURRENT_POSITION: 20,
     D2TV_MESSAGE_NETWORKDOWN: 21,
     D2TV_MESSAGE_TRICKDOWN: 22,
     D2TV_MESSAGE_PLAY_FAILED: 23, /!**< Play failed *!/
     D2TV_MESSAGE_PAUSE_FAILED: 24,
     D2TV_MESSAGE_PAUSE_COMPLETE: 25,
     D2TV_MESSAGE_RESUME_COMPLETE: 26,
     D2TV_MESSAGE_SEEK_FAILED: 27,
     D2TV_MESSAGE_TRICK_FAILED: 28,
     D2TV_MESSAGE_NUM: 29,
     D2TV_MESSAGE_INIT_FAILED: 35,

     /!* SOCKET-PLAYER RETURN *!/
     D2TV_MESSAGE_WINDOW_ID: 200,
     D2TV_MESSAGE_MULTIVIEW_BEGIN_OF_STREAM: 201,
     D2TV_MESSAGE_PIP_PLAYER_BEGINE_OF_STREAM: 202,
     D2TV_MESSAGE_PIP_PLAYER_STOP_COMPLETE: 203,
     D2TV_MESSAGE_MULTIVEIW_STOP_COMPLETE: 204,

     // D2TV-Player State Enum
     PLAYER_STATE_NONE: 0,
     PLAYER_STATE_INITIALIZING: 1,
     PLAYER_STATE_READY: 2,
     PLAYER_STATE_PLAYING: 3,
     PLAYER_STATE_PAUSE: 4,
     PLAYER_STATE_STOPPING: 5,
     PLAYER_STATE_READY_TO_PLAY: 6
     };*/


    //Need to provide at least 1 ID of a SEF Player Object. Providing a second SEF Player enables prebuffering.
    Obj.prototype.initialize = function () {
        var self = this;

        if (this.initialized === true) {
            return false;
        }

        this.internalPlayerDisplayArea = {x: 0, y: 0, w: 960, h: 540};

        this.log("LWPlayerAdapter initialized.");
    };

    Obj.prototype.setLWPlayer = function (lwPlayer) {
        if (typeof(lwPlayer.addEventListener) !== "function") {
            throw "LW_PLAYER not compatible! Does not feature addEventListener function!";
        }
        this.hookUpLWPlayerEventHandlers(lwPlayer);
        this.playerWrapper = lwPlayer;
    };

    Obj.prototype.hookUpLWPlayerEventHandlers = function (lwPlayer) {

        var self = this;

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_INIT_COMPLETE, function (duration, resolutionWidth, resolutionHeight, audioChannels, audioSampleRate, videoFrameNum, videoFrameD, audioNum, videoNum, mediaType, playerVersion) {
            if (self.videoInitDeferred) {
                self.videoInitDeferred.resolve();
            }

            self.log('D2TV init complete: ' + JSON.stringify(Array.prototype.slice.call(arguments)));

            duration = parseInt(duration, 10);
            resolutionWidth = parseInt(resolutionWidth, 10);
            resolutionHeight = parseInt(resolutionHeight, 10);
            audioChannels = parseInt(audioChannels, 10);
            audioSampleRate = parseInt(audioSampleRate, 10);
            videoFrameNum = parseInt(videoFrameNum, 10);
            videoFrameD = parseInt(videoFrameD, 10);
            audioNum = parseInt(audioNum, 10);
            videoNum = parseInt(videoNum, 10);
            mediaType = parseInt(mediaType, 10);

            self.duration = duration || 0;
            self.resolutionWidth = resolutionWidth;
            self.resolutionHeight = resolutionHeight;
            self.audioChannels = audioChannels;
            self.audioSampleRate = audioSampleRate;
            self.videoFrameNum = videoFrameNum;
            self.videoFrameD = videoFrameD;
            self.audioStreamCount = audioNum;
            self.videoStreamCount = videoNum;
            self.mediaType = mediaType;

            self.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_INFO_READY);
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_CURRENT_POSITION, function (ms) {
            //self.log("CURRENT POSITION: " + ms + " (" + typeof(ms) + ")");
            ms = parseInt(ms, 10);
            if (self.playhead === ms) {
                return false;
            }
            self.playhead = ms;
            self.dispatchEvent(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, {
                ms: ms
            });
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_BEGIN_OF_STREAM, function () {
            self.log("BEGINNING OF STREAM");
            self.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_START);
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_END_OF_STREAM, function () {
            self.log("END OF STREAM");
            self.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_COMPLETE);
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_BUFFERING, function (percent) {
            self.log("BUFFER STATUS: " + percent + " (" + typeof(percent) + ")");
            percent = parseInt(percent, 10);
            if (percent === 0) {
                self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_START);
            }
            else if (percent === 100) {
                self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_COMPLETE);
            }
            else {
                self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_PROGRESS, {
                    percent: percent
                });
            }

        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_STOP_SUCCESS, function () {
            self.log("D2TV_MESSAGE_STOP_SUCCESS");
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_SEEK_COMPLETED, function () {
            self.log("D2TV_MESSAGE_SEEK_COMPLETED");
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_PAUSE_COMPLETE, function () {
            self.log("D2TV_MESSAGE_PAUSE_COMPLETE");
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_RESUME_COMPLETE, function () {
            self.log("D2TV_MESSAGE_RESUME_COMPLETE");
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_FILE_NOT_FOUND, function () {
            self.log("D2TV_MESSAGE_FILE_NOT_FOUND");
            self.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED, {
                code: 0,
                message: "D2TV_MESSAGE_FILE_NOT_FOUND"
            });

        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_FILE_NOT_SUPPORTED, function () {
            self.log("D2TV_MESSAGE_FILE_NOT_SUPPORTED");
            self.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: 0,
                message: "D2TV_MESSAGE_FILE_NOT_SUPPORTED"
            });
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_ERROR, function () {
            self.log("D2TV_MESSAGE_ERROR");
            self.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: 0,
                message: "D2TV_MESSAGE_ERROR"
            });
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_PLAY_FAILED, function () {
            self.log("D2TV_MESSAGE_PLAY_FAILED");
            self.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: 0,
                message: "D2TV_MESSAGE_PLAY_FAILED"
            });
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_CONNECTION_TIMEOUT, function () {
            self.log("D2TV_MESSAGE_CONNECTION_TIMEOUT");
            self.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED, {
                code: 0,
                message: "D2TV_MESSAGE_CONNECTION_TIMEOUT"
            });
        });

        lwPlayer.addEventListener(lwPlayer.PlayerState.D2TV_MESSAGE_NETWORKDOWN, function () {
            self.log("D2TV_MESSAGE_NETWORKDOWN");
            self.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED, {
                code: 0,
                message: "D2TV_MESSAGE_NETWORKDOWN"
            });
        });
    };

    //Initialize player with a Url
    Obj.prototype.initPlayer = function (url) {
        var self = this;
        if (!this.playerWrapper) {
            throw "LW Player has not been initialized! Use setLWPlayer(player) on this adapter to initialize it.";
        }
        this.log("InitPlayer: " + url);
        if (this.videoInitDeferred) {
            try {
                this.videoInitDeferred.reject();
                this.videoInitDeferred = null;
            }
            catch (e) {
            }
        }
        this.videoInitDeferred = adfw.Q.defer();
        return this.playerWrapper.player.load(url);
    };

    //Starts playback. If given a number in milliseconds, will start playback at that time.
    Obj.prototype.startPlayback = function (milliseconds) {
        this.log("StartPlayback: " + milliseconds);
        if (!this.videoInitDeferred) {
            this.error("StartPlayback: initPlayer was never called! (videoInitDeferred is null)");
            return false;
        }
        this.videoInitDeferred.promise.then(adfw.Utils.bind(this.getStartPlaybackCallback(), this, milliseconds));
    };

    Obj.prototype.getStartPlaybackCallback = function () {
        if (!this._startPlaybackCallback) {
            var callback = function (ms) {
                if (!ms || isNaN(ms)) {
                    ms = 0;
                }
                var sec = Math.round(ms / 1000);
                this.log("StartPlayback NOT GOING TO activate! LW_PLAYER.js will send play() for us.");
                //this.playerWrapper.player.play(sec);
            }
            this._startPlaybackCallback = callback;
        }
        return this._startPlaybackCallback;
    };

    //Play/Pause/Stop/Resume
    Obj.prototype.play = function (url, milliseconds) {
        this.log("Play: " + url);
        this.initPlayer(url);
        this.startPlayback(milliseconds);
    };

    Obj.prototype.removeVideoMetadata = function () {
        this.duration = null;
        this.resolutionWidth = null;
        this.resolutionHeight = null;
        this.audioChannels = null;
        this.audioSampleRate = null;
        this.videoFrameNum = null;
        this.videoFrameD = null;
        this.audioStreamCount = null;
        this.videoStreamCount = null;
        this.mediaType = null;
    };

    Obj.prototype.stop = function () {
        this.log("Stop");
        this.videoInitDeferred = null;
        this.removeVideoMetadata();
        return this.playerWrapper.player.stop();
    };
    Obj.prototype.pause = function () {
        this.log("Pause");
        return this.playerWrapper.player.pause();
    };
    Obj.prototype.resume = function () {
        this.log("Resume");
        return this.playerWrapper.player.resume();
    };

    //Jumps forward or backward given an unsigned integer representing milliseconds. It actually needs to round down to the lowest second.
    Obj.prototype.jump = function (ms) {

        if (typeof ms !== "number") {
            return false;
        }
        var sec = Math.abs(Math.round(ms / 1000));

        if (ms < 0) {
            this.log("jumpBackward " + sec);
            return this.playerWrapper.player.jumpBackward(sec);
        }
        else {
            this.log("jumpForward " + sec);
            return this.playerWrapper.player.jumpForward(sec);
        }
    };
    Obj.prototype.jumpForward = function (ms) {
        return this.jump(ms);
    };
    Obj.prototype.jumpBackward = function (ms) {
        return this.jump(-ms);
    };

    //Gets the duration, in MS, of the currently playing video.
    Obj.prototype.getDuration = function () {
        try {
            this.duration = this.playerWrapper.player.getDuration();
            return this.duration;
        }
        catch (e) {
            if (typeof this.duration !== "number" || this.duration < 1 || isNaN(this.duration)) {
                this.error(e + "; returning 0");
                return 0;
            }
            else {
                this.error(e + "; returning duration previously set by StreamInfoReady");
                return this.duration;
            }
        }
    };

    //Gets the current playhead
    Obj.prototype.getPlayhead = function () {
        //this.log("getPlayhead: " + this.playhead);
        return this.playhead;
    };

    //Get the coordinates of the display area, relative to 960x540 resolution
    Obj.prototype.getRelativeDisplayRect = function () {
        return adfw.PlatformUtils.scaleTo960(this.getDisplayRect());
    };

    //Gets the display area relative to the window's true size
    Obj.prototype.getDisplayRect = function () {
        return {
            x: this.internalPlayerDisplayArea.x,
            y: this.internalPlayerDisplayArea.y,
            w: this.internalPlayerDisplayArea.w,
            h: this.internalPlayerDisplayArea.h
        };
    };

    //Resize and move the video window, using 960x540 scale
    Obj.prototype.setRelativeDisplayRect = function (x, y, w, h) {

        var dimms = {};

        if (typeof(x) === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            dimms = x;
        }
        else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
            dimms = {x: x, y: y, w: w, h: h};
        }
        else {
            var error = "Invalid display area. Aborting setDisplayArea";
            this.log(error);
            throw error;
        }

        var scaledDimms = adfw.PlatformUtils.scaleFrom960(dimms);
        this.log("setDisplayArea scaledDimms: " + scaledDimms.x + " | " + scaledDimms.y + " | " + scaledDimms.w + " | " + scaledDimms.h);

        this.setDisplayRect(scaledDimms);
    };

    //Resize and move the video window, using true window size
    Obj.prototype.setDisplayRect = function (x, y, w, h) {

        var changeObject = {
            oldx: this.internalPlayerDisplayArea.x,
            oldy: this.internalPlayerDisplayArea.y,
            oldw: this.internalPlayerDisplayArea.w,
            oldh: this.internalPlayerDisplayArea.h
        };

        if (typeof(x) === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
            this.internalPlayerDisplayArea = x;
        }
        else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {

            this.internalPlayerDisplayArea = {x: x, y: y, w: w, h: h};
        }
        else {
            var error = "Invalid display area. Aborting setCorrectedDisplayArea: " + x + "," + y + "," + w + "," + h;
            this.log(error);
            throw error;
        }

        this._setDisplayArea();

        changeObject.x = this.internalPlayerDisplayArea.x;
        changeObject.y = this.internalPlayerDisplayArea.y;
        changeObject.w = this.internalPlayerDisplayArea.w;
        changeObject.h = this.internalPlayerDisplayArea.h;

        this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, changeObject);
    };


    //Starts buffering a given Url on the dormant player.
    Obj.prototype.startBufferingVideo = function (url, ms, prefunc) {
        return false;
    };

    //Swaps the active player with the dormant (prebuffered) player.
    Obj.prototype.playBufferedVideo = function () {
        return false;
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.cancelBufferedVideo = function () {
        return false;
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.getBufferedVideoUrl = function () {
        return this.prebufferedUrl;
    };

    //Other less commonly used functions
    Obj.prototype.close = function () {

    };

    Obj.prototype.getInternalPlayer = function () {
        return this.playerWrapper;
    };

    Obj.prototype._setDisplayArea = function () {
        if (this.internalPlayerDisplayArea) {
            this.log("_setDisplayArea: " + this.internalPlayerDisplayArea.x + "x" + this.internalPlayerDisplayArea.y + "x" + this.internalPlayerDisplayArea.w + "x" + this.internalPlayerDisplayArea.h);
            this.playerWrapper.player.setDisplayRect(this.internalPlayerDisplayArea.x, this.internalPlayerDisplayArea.y, this.internalPlayerDisplayArea.w, this.internalPlayerDisplayArea.h);
        }
    };

    return Obj;
}());
adfw.AVPlayAdapter = (function () {
    "use strict";

    var dummyFunction = function () {
    }; //Do nothing

    //Constructor: set up prototype chain
    var Obj = function (params) {
        adfw.PlayerAdapter.call(this);
        this.initialized = false;
        this.state = "IDLE";
        this.enablePrebuffering = null;
        this.enablePrepareAsync = false;
        this.initialize(params);
        this.initializeBufferDeferred();
    };

    Obj.AVPlayerErrorCodes = {
        NONE: "PLAYER_ERROR_NONE",
        INVALID_PARAMETER: "PLAYER_ERROR_INVALID_PARAMETER",
        NO_SUCH_FILE: "PLAYER_ERROR_NO_SUCH_FILE",
        INVALID_OPERATION: "PLAYER_ERROR_INVALID_OPERATION",
        SEEK_FAILED: "PLAYER_ERROR_SEEK_FAILED",
        INVALID_STATE: "PLAYER_ERROR_INVALID_STATE",
        NOT_SUPPORTED_FILE: "PLAYER_ERROR_NOT_SUPPORTED_FILE",
        INVALID_URI: "PLAYER_ERROR_INVALID_URI",
        CONNECTION_FAILED: "PLAYER_ERROR_CONNECTION_FAILED",
        RESOURCE_LIMIT: "PLAYER_ERROR_RESOURCE_LIMIT",
        AUDIO_CODEC_NOT_SUPPORTED: "PLAYER_ERROR_AUDIO_CODEC_NOT_SUPPORTED",
        VIDEO_CODEC_NOT_SUPPORTED: "PLAYER_ERROR_VIDEO_CODEC_NOT_SUPPORTED",
        NO_AUTH: "PLAYER_ERROR_NO_AUTH",
        GENERIC: "PLAYER_ERROR_GENEREIC",
        RESTORE: "PLAYER_ERROR_RESTORE"
    };

    Obj.AVPlayerMessageCodes = {
        NONE: "PLAYER_MSG_NONE",
        RESOLUTION_CHANGED: "PLAYER_MSG_RESOLUTION_CHANGED",
        AD_END: "PLAYER_MSG_AD_END",
        AD_START: "PLAYER_MSG_AD_START",
        RENDER_DONE: "PLAYER_MSG_RENDER_DONE",
        BITRATE_CHANGE: "PLAYER_MSG_BITRATE_CHANGE",
        FRAGMENT_INFO: "PLAYER_MSG_FRAGMENT_INFO",
        SPARSE_TRACK_DETECT: "PLAYER_SPARSE_TRACK_DETECT",
        STREAMING_EVENT: "PLAYER_STREAMING_EVENT",
        DRM_CHALLENGE_DATA: "PLAYER_MSG_DRM_CHALLENGE_DATA"
    };

    Obj.prototype = Object.create(adfw.PlayerAdapter.prototype);
    Obj.prototype.constructor = Obj;
    Obj.Events = adfw.PlayerAdapter.Events;

    Obj.prototype.getAdapterType = function () {
        return adfw.PlayerAdapter.AdapterType.TIZEN_WEBKIT_AVPLAY;
    };

    //Need to provide at least 1 ID of a Video element. Providing a second enables prebuffering.
    Obj.prototype.initialize = function (params) {
        var self = this;
        if (this.initialized === true) {
            return false;
        }

        this.enablePrebuffering = !!params.enablePrebuffering;

        //Make sure at least one AVPlay plugin has loaded onto the body
        adfw.TizenWebkitUtils.getAVPlayerElement();

        this._player1 = this.createAVPlayerInstance();
        this._player2 = this.createAVPlayerInstance();

        this._activePlayer = this._player1;
        this._prebufferedUrl = null;
        this._prebufferSeekTime = null;
        this._prebufferingPrepareDeferred = null;

        this._playhead = null;
        this.initialized = true;

        //TODO: Fix Airbag! We need to find a way to have the correct displayArea here. If the callback executes, it will overwrite the displayArea that the user set!
        this._screen_width = window.innerWidth;
        this._screen_height = window.innerHeight;
        this.internalPlayerDisplayArea = {
            x: 0,
            y: 0,
            w: this._screen_width,
            h: this._screen_height
        };
        if (window.tizen) {
            var cb = function (that) {
                tizen.systeminfo.getPropertyValue('DISPLAY', function (display) {
                    that._screen_width = display.resolutionWidth;
                    that._screen_height = display.resolutionHeight;
                    that.internalPlayerDisplayArea = {
                        x: 0,
                        y: 0,
                        w: that._screen_width,
                        h: that._screen_height
                    };
                });
            }(this);
        }
    };

    Obj.prototype.getActivePlayer = function () {
        return this._activePlayer;
    };

    Obj.prototype.getDormantPlayer = function () {
        if (this._activePlayer === this._player2) {
            return this._player1;
        }
        else {
            return this._player2;
        }
    };

//The buffer deferred/promise refers to the need to wait until video starts buffering before trying to play it. If we don't wait, it cause buffer underrun.
    Obj.prototype.initializeBufferDeferred = function () {
        if (this.bufferDeferred) {
            this.log('rejecting bufferDeferred');
            this.bufferDeferred.reject();
        }
        this.bufferDeferred = adfw.Q.defer();
        this.bufferPromise = this.bufferDeferred.promise;
    };

//Initialize player with a Url
    Obj.prototype.initPlayer = function (url) {
        this.log("Initializing AV player with: " + url);

        this.replaceAVPlayerInstance(this.getActivePlayer());

        //if prebuffering is disabled, swap the players. this is to reduce the chance of receiving an errant event from the last video and messing up our state
        if (!this.enablePrebuffering) {
            this.swapPlayers();
        }

        this.state = this.getActivePlayer().getState();
        //this.log("AVPlayer: InitPlayer... (state: " + this.state + ")");

        this.initializeBufferDeferred();

        var openResult = this.getActivePlayer().open(url);
        this.log("AVPlayer Open: " + openResult);
	this.log('hooking avplayer event listeners...');
        this.hookEventListeners(this.getActivePlayer());

        this.setDisplayRect(this.internalPlayerDisplayArea);
    };

//Starts playback. If given a number in milliseconds, will start playback at that time.
    Obj.prototype.startPlayback = function (milliseconds) {

        var self = this;

        //this.log("AVPlayer: Preparing... (state: " + this.state + ")");
        var prepareResult = this.getActivePlayer().prepare();

        if (typeof(milliseconds) === "number" && milliseconds > 999) {
            this.log("AVPlayer: Seeking to " + milliseconds);
            self._playhead = milliseconds;
            try {
                self.getActivePlayer().seekTo(self._playhead);
            }
            catch (e) {
                this.log('failed to seek - it could be that we are playing a live stream. swallowing error: ' + e);
            }
        }

        self.log("startPlayback: Starting (not waiting for buffer promise)")
        self.getActivePlayer().play();

        // self.log("startPlayback: waiting for buffer promise...")
        // this.bufferPromise
        //     .finally(function () {
        //         self.log("startPlayback: buffer promise complete, starting playback...");
        //         self.getActivePlayer().play();
        //     })
        //     .timeout(5000);
    };

//Play/Pause/Stop/Resume
    Obj.prototype.play = function (url, milliseconds) {
        this.initPlayer(url);
        this.startPlayback(milliseconds);

    };
    Obj.prototype.stop = function () {
        this.log("stop");
        this._playhead = null;
        this.log('[ACTIVE PLAYER] stop()');
        this.getActivePlayer().stop();
        this.state = this.getActivePlayer().getState();
        this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_STOPPED);
    };
    Obj.prototype.pause = function () {
        //this.log("pause");
        this.log('[ACTIVE PLAYER] pause()');
        this.getActivePlayer().pause();
        this.state = this.getActivePlayer().getState();
    };
    Obj.prototype.resume = function () {
        this.log("resume");
        this.log('[ACTIVE PLAYER] resume()');
        this.getActivePlayer().play();
        this.state = this.getActivePlayer().getState();
    };

    Obj.prototype.jumpForward = function (ms) {
        if (typeof ms === "number" && ms > 0) {
            return this.getActivePlayer().jumpForward(ms);
        } else {
            return false;
        }
    };
    Obj.prototype.jumpBackward = function (ms) {
        if (typeof ms === "number" && ms > 0) {
            return this.getActivePlayer().jumpBackward(Math.abs(ms));
        } else {
            return false;
        }
    };

//Gets the duration, in MS, of the currently playing video.
    Obj.prototype.getDuration = function () {
        try {
            return this.getActivePlayer().getDuration();
        }
        catch (e) {
            this.error('failed to get duration: ' + e);
            return 0;
        }
    };

//Gets the current playhead
    Obj.prototype.getPlayhead = function () {
        return this._playhead;
    };

//Get the coordinates of the display area, relative to 960x540 resolution
    Obj.prototype.getRelativeDisplayRect = function () {
        return adfw.PlatformUtils.scaleTo960(this.getDisplayRect());
    };

//Gets the display area relative to the window's true size
    Obj.prototype.getDisplayRect = function () {
        return {
            x: this.internalPlayerDisplayArea.x,
            y: this.internalPlayerDisplayArea.y,
            w: this.internalPlayerDisplayArea.w,
            h: this.internalPlayerDisplayArea.h
        };
    };

//Resize and move the video window, using 960x540 scale
    Obj.prototype.setRelativeDisplayRect = function (x, y, w, h) {
        this.setDisplayRect(adfw.PlatformUtils.scaleFrom960(x, y, w, h));
    };

//Resize and move the video window, using true window size
    Obj.prototype.setDisplayRect = function (x, y, w, h) {
        if (this.getActivePlayer().getState() != 'NONE') {
            var changeObject = {
                oldx: this.internalPlayerDisplayArea.x,
                oldy: this.internalPlayerDisplayArea.y,
                oldw: this.internalPlayerDisplayArea.w,
                oldh: this.internalPlayerDisplayArea.h
            };

            if (typeof(x) === "object" && typeof(x.x) === "number" && typeof(x.y) === "number" && typeof(x.w) === "number" && typeof(x.h) === "number") {
                this.internalPlayerDisplayArea = x;
            } else if (typeof(x) === "number" && typeof(y) === "number" && typeof(w) === "number" && typeof(h) === "number") {
                this.internalPlayerDisplayArea = {
                    x: x,
                    y: y,
                    w: w,
                    h: h
                };
            } else {
                var error = "Invalid display area. Aborting setCorrectedDisplayArea";
                this.log(error);
                throw error;
            }

            if (this.internalPlayerDisplayArea.w > this._screen_width) {
                this.internalPlayerDisplayArea.w = this._screen_width;
            }
            if (this.internalPlayerDisplayArea.h > this._screen_height) {
                this.internalPlayerDisplayArea.h = this._screen_height;
            }

            this.getActivePlayer().setDisplayRect(this.internalPlayerDisplayArea.x, this.internalPlayerDisplayArea.y, this.internalPlayerDisplayArea.w, this.internalPlayerDisplayArea.h);

            changeObject.x = this.internalPlayerDisplayArea.x;
            changeObject.y = this.internalPlayerDisplayArea.y;
            changeObject.w = this.internalPlayerDisplayArea.w;
            changeObject.h = this.internalPlayerDisplayArea.h;

            this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, changeObject);
        }
    };

    //Starts buffering a given Url on the dormant player.
    Obj.prototype.startBufferingVideo = function (url, ms, prefunc) {
        var self = this;

        if (!this.enablePrebuffering) {
            this.log("Abort prebuffer: prebuffering is disabled/unsupported");
            return false;
        }

        this.log("Prebuffer logic: Start buffering " + url);


        if (!url) {
            this.log("Prebuffer failure - URL is: " + url);
            return false;
        }

        //var tryAsync = (!adfw.TizenWebkitUtils.is2015Model() && this.enablePrepareAsync); //prepareAsync is not possible in Tizen 2015, and is currently not advisable in all Tizen platforms.
        //var tryAsync = true; //NO PREPAREASYNC!
        if ((typeof(this.getDormantPlayer().prepareAsync) !== 'function')) {
            this.log("Prebuffer failure - dormant player prepareAsync is: " + (typeof(this.getDormantPlayer().prepareAsync)));
            return false;
        }

        this._prebufferedUrl = url;

        this.replaceAVPlayerInstance(this.getDormantPlayer());
        var dormantPlayer = this.getDormantPlayer();

        this.log('[DORMANT PLAYER] open()');
        dormantPlayer.open(url);
        this.log('hooking avplayer event listeners for dormant...');
        this.hookEventListeners(dormantPlayer);		

        if (typeof(prefunc) === 'function') {
            prefunc(dormantPlayer);
        }
        this._prebufferingPrepareDeferred = adfw.Q.defer();
        this._prebufferingPrepareDeferred.promise.catch(function (err) {
            self.log('prebufferingPrepareDeferred was rejected: ' + err);
            self._prebufferedUrl = null;
            self._prebufferSeekTime = null;
            self._prebufferingPrepareDeferred = null;
        });

        //Although we NEED to set PREBUFFER_MODE to get prebuffering to work properly, it does not actually fast-forward content to the correct position. We will need an additional seek hack (found later in the code).
        var str_ms = '' + ms;
	this.log('[DORMANT PLAYER] setStreamingProperty("PREBUFFER_MODE", ' + str_ms + ')');
	dormantPlayer.setStreamingProperty('PREBUFFER_MODE', str_ms);

        dormantPlayer.setDisplayRect(this.internalPlayerDisplayArea.x, this.internalPlayerDisplayArea.y, this.internalPlayerDisplayArea.w, this.internalPlayerDisplayArea.h);
        this.log('[DORMANT PLAYER] prepareAsync()');
        dormantPlayer.prepareAsync(function () {
            //WARNING: This probably won't ever get executed because prepareAsync() callbacks won't fire if we are using prebuffering. Instead, we resolve the prepareDeferred when the dormant player's buffering is complete
            self.log('[DORMANT PLAYER] prepareAsync has finished!');
            self._prebufferingPrepareDeferred.resolve();
        }, function (err) {
            self.log("[DORMANT PLAYER] Failed to prepare prebuffered video: " + err);
            self.log("rejecting prepare deferred");
            self._prebufferingPrepareDeferred.reject('prepareAsync error: ' + err);
        });
        this._prebufferingPrepareDeferred.promise.then(function () {
            self.log("Dormant player has finished preparing!");
        });

        return this._prebufferedUrl;
    };

    //Swaps the active player with the dormant (prebuffered) player.
    Obj.prototype.playBufferedVideo = function () {
        var self = this;
        this.log("Prebuffer logic: Play buffered video (waiting for prebuffer prepare)");
        self.getActivePlayer().stop();
        this._prebufferingPrepareDeferred.promise
            .then(function () {
                self.log("Prebuffer Prepare resolved! Playing prebuffered video...");
                self.swapPlayers();
                self._prebufferedUrl = null;
                self._prebufferSeekTime = null;
                self.getActivePlayer().play();
                self.log('[ACTIVE PLAYER] play()');
                self._prebufferingPrepareDeferred = null;
            });
    };

//Returns the Url of the currently buffered video (if any)
    Obj.prototype.cancelBufferedVideo = function () {
        this.log('cancelBufferedVideo');
        this._prebufferedUrl = null;
        if (this.getDormantPlayer()) {
            this.getDormantPlayer().stop();
        }
        if (this._prebufferingPrepareDeferred) {
            this._prebufferingPrepareDeferred.reject('cancel buffered video');
        }
    };

//Returns the Url of the currently buffered video (if any)
    Obj.prototype.getBufferedVideoUrl = function () {
        return this._prebufferedUrl;
    };

//Other less commonly used functions
    Obj.prototype.close = function () {
        this.getActivePlayer().close();
        this.getDormantPlayer().close();
    };
    Obj.prototype.getInternalPlayer = function () {
        return this.getActivePlayer();
    };

    Obj.prototype.destroyAVPlayerInstance = function (player) {
        try {
            player.setListener({});
            player.stop();
            player.close();
            player = null;
            this.log('destroyed avplayer instance');
        }
        catch (e) {
            this.error('failed to destroy avplayer instance: ' + e);
        }
    };

    Obj.prototype.createAVPlayerInstance = function () {
        this.log('creating avplayer instance...');
        var player = (webapis.avplaystore && webapis.avplaystore.getPlayer ) ? webapis.avplaystore.getPlayer() : webapis.avplayservice.getPlayer();
        //this.log('hooking avplayer event listeners...');
        //this.hookEventListeners(player);
        this.log('created avplayer instance');
        return player;
    };

    Obj.prototype.replaceAVPlayerInstance = function (oldPlayer) {
        this.log('replacing AVPlayer instance...');
        var isActive = this.getActivePlayer() === oldPlayer;
        var isFirstPlayer = this._player1 === oldPlayer;
        this.destroyAVPlayerInstance(oldPlayer);
        var newPlayer = this.createAVPlayerInstance();
        if (isFirstPlayer) {
            this._player1 = newPlayer;
        }
        else {
            this._player2 = newPlayer;
        }
        if (isActive) {
            this._activePlayer = newPlayer;
        }
        this.log('replaced avplayer instance ' + (isFirstPlayer ? '1' : '2') + ' ' + (isActive ? '(active)' : '(dormant)'));
    };

//Stop the currently active player, and make the dormant player become the active player
    Obj.prototype.swapPlayers = function () {
        var dormantPlayer = this.getDormantPlayer();
        if (!dormantPlayer) {
            return;
        }
        else {
            this.getActivePlayer().stop();
            this._activePlayer = dormantPlayer;
            this.state = this.getActivePlayer().getState();
            this.log("Prebuffer logic: Swapping players! Player state = " + this.state);
            this._prebufferedUrl = null;
        }
    };

//Active Player Event Handlers
    Obj.prototype.handleBufferingStart = function (data1, data2, data3, data4) {
        this.log("active player buffering start");
        this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_START, {});
    };

    Obj.prototype.handleBufferingProgress = function (data1, data2, data3, data4) {
        this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_PROGRESS, {
            percent: data1,
        });
        var bufferingPercentage = parseInt(data1, 10);
        if (bufferingPercentage % 30 === 0 || bufferingPercentage === 10) {
            this.log("active player buffering progress: " + data1);
        }
    };

    Obj.prototype.handleBufferingComplete = function (data1, data2, data3, data4) {
        this.log("active player buffering complete");
        this.bufferDeferred.resolve();
        this.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_COMPLETE, {});
    };

    Obj.prototype.handleCurrentPlaytime = function (data1, data2, data3, data4) {
        //this.log('playtime is ' + data1 + ' and state is ' + this.state);
        if (this.state != "PLAYING" && data1) {
            this.handleStreamStarted();
            this.state = this.getActivePlayer().getState();
        }
        this._playhead = data1;
        this.dispatchEvent(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, {
            ms: data1
        });
    };

    Obj.prototype.handleStreamStarted = function (data1, data2, data3, data4) {
        this.log("active player stream started");
        this.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_START, {});
    };

    Obj.prototype.handleStreamCompleted = function (data1, data2, data3, data4) {
        this.log("active player stream completed");
        this.getActivePlayer().stop();
        this.state = this.getActivePlayer().getState();
        this.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_COMPLETE, {});
    };

    Obj.prototype.handleResolutionChanged = function (data1, data2, data3, data4) {
        //this.log("active player resolution changed");
        this.dispatchEvent(adfw.PlayerAdapter.Events.RESOLUTION_CHANGED, {});
    };

    Obj.prototype.handleSubtitle = function (data1, data2, data3, data4) {
        var eventMap = {
            duration: data1,
            text: data2,
            attributes: data4
        };

        this.dispatchEvent(adfw.PlayerAdapter.Events.SUBTITLE, eventMap);
    };

    Obj.prototype.parseSparseTrack = function (raw) {
        if (!raw) {
            throw new Error('sparse track string is empty');
        }
        var parseRegex = /([\s\S]*)\|(\d+)/;
        var regexParseData = parseRegex.exec(raw);

        var time = parseInt(regexParseData[2]);
        var data = regexParseData[1];

        var parsed = {
            time: time,
            data: data,
            raw: raw
        };
        return parsed;
    };

    Obj.prototype.handleEvent = function (data1, data2, data3, data4) {
        if (data1 === Obj.AVPlayerMessageCodes.SPARSE_TRACK_DETECT) {
            try {
                var eventMap = this.parseSparseTrack(data2);
                this.log('active player sparse track: ' + JSON.stringify(eventMap));
                this.dispatchEvent(adfw.PlayerAdapter.Events.SPARSE_TRACK, eventMap);
            }
            catch (e) {
                this.error('failed to parse sparse track...' + e);
                this.error('Failed to parse sparse track data2=(' + typeof(data2) + ') "' + data2 + '": ' + '| data3=(' + typeof(data3) + ') "' + data3 + '": ' + e);
            }
        }
        else {
            //this.log("unhandled active AVPlayer message: " + data1 + " | " + data2);
        }
    };

    Obj.prototype.handleError = function (data1, data2, data3, data4) {
        this.error("ACTIVE PLAYER AVPlayer Error: " + data1 + " | " + data2);
        if (data1 === Obj.AVPlayerErrorCodes.CONNECTION_FAILED) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.CONNECTION_FAILED, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_URI) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NOT_SUPPORTED_FILE) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NO_SUCH_FILE) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.VIDEO_CODEC_NOT_SUPPORTED) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NO_AUTH) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.AUTHENTICATION_FAILED);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.GENERIC) {
            this.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_OPERATION) {
            this.log("Swallowing error: " + data1);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_PARAMETER) {
            this.log("Swallowing error: " + data1);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NONE) {
            this.log("Swallowing error: " + data1);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.RESTORE) {
            this.log("Swallowing error: " + data1);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.AUDIO_CODEC_NOT_SUPPORTED) {
            this.log("Swallowing error: " + data1);
        }
        else {
            this.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
    };

//Dormant Player Event Handlers
    Obj.prototype.handleDormantPlayerBufferingStart = function (data1, data2, data3, data4) {
        this.log("dormant player buffering start");
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_START, {});
    };

    Obj.prototype.handleDormantPlayerBufferingProgress = function (data1, data2, data3, data4) {
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_PROGRESS, {
            percent: data1,
        });
        var bufferingPercentage = parseInt(data1, 10);
        if (bufferingPercentage % 30 === 0 || bufferingPercentage === 10) {
            this.log("dormant player buffering progress: " + data1);
        }
    };

    Obj.prototype.handleDormantPlayerBufferingComplete = function (data1, data2, data3, data4) {
        this.log("dormant player buffering complete. prebufferingPrepareDeferred exists? " + !!this._prebufferingPrepareDeferred);
        if (this._prebufferingPrepareDeferred) {
            //A hack because prepareAsync()'s successCb never fires - we interpret buffering complete as the successCb instead
            this._prebufferingPrepareDeferred.resolve();
        }
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_COMPLETE, {});
    };

    Obj.prototype.handleDormantPlayerCurrentPlaytime = function (data1, data2, data3, data4) {
        this.log("dormant player playtime: " + data1);
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_CURRENT_PLAYBACK_TIME, {
            ms: data1
        });
    };

    Obj.prototype.handleDormantPlayerStreamStarted = function (data1, data2, data3, data4) {
        this.log("dormant player stream started");
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDERING_START, {});
    };

    Obj.prototype.handleDormantPlayerStreamCompleted = function (data1, data2, data3, data4) {
        this.log("dormant player stream completed");
        this.getDormantPlayer().stop();
    };

    Obj.prototype.handleDormantPlayerResolutionChanged = function (data1, data2, data3, data4) {
        //this.log("DORMANT PLAYER RESOLUTION CHANGED");
        this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RESOLUTION_CHANGED, {});
    };

    Obj.prototype.handleDormantPlayerEvent = function (data1, data2, data3, data4) {
        if (data1 === Obj.AVPlayerMessageCodes.SPARSE_TRACK_DETECT) {
            try {
                var eventMap = this.parseSparseTrack(data2);
                this.log('prebuffering player sparse track: ' + JSON.stringify(eventMap));
                this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_SPARSE_TRACK, eventMap);
            }
            catch (e) {
                this.error('Failed to parse sparse track data2=(' + typeof(data2) + ') "' + data2 + '": ' + '| data3=(' + typeof(data3) + ') "' + data3 + '": ' + e);
            }
        }
        else {
            this.log("unhandled dormant AVPlayer message: " + data1 + " | " + data2);
        }
    };

    Obj.prototype.handleDormantPlayerError = function (data1, data2, data3, data4) {
        this.error("DORMANT PLAYER AVPlayer Error: " + data1 + " | " + data2);
        if (data1 === Obj.AVPlayerErrorCodes.CONNECTION_FAILED) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_CONNECTION_FAILED, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_URI) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NOT_SUPPORTED_FILE) {
            this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NO_SUCH_FILE) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.VIDEO_CODEC_NOT_SUPPORTED) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NO_AUTH) {
            this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_AUTHENTICATION_FAILED);
        }
        else if (data1 === Obj.AVPlayerErrorCodes.GENERIC) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_OPERATION) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.INVALID_PARAMETER) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.NONE) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.RESTORE) {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
        else if (data1 === Obj.AVPlayerErrorCodes.AUDIO_CODEC_NOT_SUPPORTED) {
            this.log("Swallowing error: " + data1);
        }
        else {
            //this.cancelBufferedVideo();
            this.dispatchEvent(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, {
                code: data1,
                message: data2
            });
        }
    };

    Obj.prototype.hookEventListeners = function (avplay) {
        var self = this;

        var isActivePlayer = function () {
            return (self.getActivePlayer() === avplay);
        };

        var listenerObject = {
            onbufferingstart: function () {
                if (isActivePlayer()) {
                    self.handleBufferingStart.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerBufferingStart.apply(self, arguments);
                }
            },
            onbufferingprogress: function () {
                if (isActivePlayer()) {
                    self.handleBufferingProgress.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerBufferingProgress.apply(self, arguments);
                }
            },
            onbufferingcomplete: function () {
                if (isActivePlayer()) {
                    self.handleBufferingComplete.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerBufferingComplete.apply(self, arguments);
                }
            },
            oncurrentplaytime: function () {
                if (isActivePlayer()) {
                    self.handleCurrentPlaytime.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerCurrentPlaytime.apply(self, arguments);
                }
            },
            //doesn't actually exist...?
            //onstreamstarted: function () {
            //    if (isActivePlayer()) {
            //        self.handleStreamStarted.apply(self, arguments);
            //    }
            //    else {
            //        self.handleStreamStarted.apply(self, arguments);
            //    }
            //},
            onstreamcompleted: function () {
                if (isActivePlayer()) {
                    self.handleStreamCompleted.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerStreamCompleted.apply(self, arguments);
                }
            },
            onresolutionchanged: function () {
                if (isActivePlayer()) {
                    self.handleResolutionChanged.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerResolutionChanged.apply(self, arguments);
                }
            },
            onevent: function () {
                if (isActivePlayer()) {
                    self.handleEvent.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerEvent.apply(self, arguments);
                }
            },
            onerror: function () {
                if (isActivePlayer()) {
                    self.handleError.apply(self, arguments);
                }
                else {
                    self.handleDormantPlayerError.apply(self, arguments);
                }
            },
            onsubtitlechange: function () {
                if (isActivePlayer()) {
                    self.handleSubtitle.apply(self, arguments);
                }
            }
        };

        avplay.setListener(listenerObject);
    };

    return Obj;
}());

adfw.TVPlusIPAdapter = (function () {
    "use strict";

    var dummyFunction = function () {
    }; //Do nothing

    //Constructor: set up prototype chain
    var Obj = function (params) {
        adfw.PlayerAdapter.call(this);
        this.initialize();
    };
    Obj.prototype = Object.create(adfw.PlayerAdapter.prototype);
    Obj.prototype.constructor = Obj;
    Obj.Events = adfw.PlayerAdapter.Events;

    Obj.prototype.getAdapterType = function () {
        return adfw.PlayerAdapter.AdapterType.TIZEN_TVPLUS_IP;
    };

    //Need to provide at least 1 ID of a Video element. Providing a second enables prebuffering.
    Obj.prototype.initialize = function (params) {
        var self = this;

        if (this.initialized === true) {
            return false;
        }
        this.initialized = true;

        this._player = tvplusapis.tvplus;
        this.log('tvplus: ' + (!!this._player));
        this.hookEventListeners(this._player);

        this._playhead = null;
        this.initialized = true;

        this.internalPlayerDisplayArea = {x: 0, y: 0, w: 1920, h: 1080};
    };

    //Initialize player with a Url
    Obj.prototype.initPlayer = function (url) {
        this._currentUrl = url;
    };

    //Starts playback. If given a number in milliseconds, will start playback at that time.
    Obj.prototype.startPlayback = function (milliseconds) {
        var ms = typeof(milliseconds) === "number" && milliseconds > 999 ? milliseconds / 1000 : 0;
        var sec = Math.round(ms / 1000);
        this._playhead = sec * 1000;
        this._duration = 0;


        this.log('startPlayback (using initPlayer) @' + sec + 's: ' + this._currentUrl);
        if (ms) {
            this._player.initPlayer(this._currentUrl, ms, false);
        }
        else {
            this._player.initPlayer(this._currentUrl, 0, false);
        }
        //this._player.play(this._playhead); //REMOVED - initPlayer() API will start playback on its own
    };

    //Play/Pause/Stop/Resume
    Obj.prototype.play = function (url, milliseconds) {
        this.log("play " + url);
    };
    Obj.prototype.stop = function () {
        this.log("stop");
        this._player.stop();
        this._playhead = 0;
        this._duration = 0;
        this.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_STOPPED);
    };
    Obj.prototype.pause = function () {
        //this.log("pause");
        this._player.pause();
    };
    Obj.prototype.resume = function () {
        this.log("resume");
        this._player.resume();
    };

    //Jumps forward or backward given an unsigned integer representing milliseconds. It actually needs to round down to the lowest second.
    Obj.prototype.jump = function (ms) {
        this.log("jump " + ms);
        if (typeof ms === "number" && ms > 500) {
            return this.jumpForward(ms);
        }
        else if (typeof ms === "number" && ms < 500) {
            return this.jumpBackward(ms);
        }
        return false;
    };
    Obj.prototype.jumpForward = function (ms) {
        var sec = Math.round(ms / 1000);
        return this._player.jumpForward(sec);
    };
    Obj.prototype.jumpBackward = function (ms) {
        var sec = Math.round(ms / 1000);
        return this._player.jumpBackward(sec);
    };

    //Gets the duration, in MS, of the currently playing video.
    Obj.prototype.getDuration = function () {
        return this._duration;
    };

    //Gets the current playhead
    Obj.prototype.getPlayhead = function () {
        return this._playhead;
    };

    //Get the coordinates of the display area, relative to 960x540 resolution
    Obj.prototype.getRelativeDisplayRect = function () {
        return adfw.PlatformUtils.scaleTo960(this.internalPlayerDisplayArea);
    };

    //Gets the display area relative to the window's true size
    Obj.prototype.getDisplayRect = function () {
        return {
            x: this.internalPlayerDisplayArea.x,
            y: this.internalPlayerDisplayArea.y,
            w: this.internalPlayerDisplayArea.w,
            h: this.internalPlayerDisplayArea.h,
        };
    };

    //Resize and move the video window, using 960x540 scale
    Obj.prototype.setRelativeDisplayRect = function (x, y, w, h) {
        this.log("setRelativeDisplayRect: " + x + ", " + y + ", " + w + ", " + h);
        var displayArea = adfw.PlatformUtils.scaleFrom960(x, y, w, h);
        this.setDisplayRect(displayArea.x, displayArea.y, displayArea.w, displayArea.h);
    };

    //Resize and move the video window, using true window size
    Obj.prototype.setDisplayRect = function (x, y, w, h) {

        if (typeof(y) !== "number" || typeof(w) !== "number" || typeof(h) !== "number") {
            if (!x || typeof(x.x) !== "number" || typeof(x.y) !== "number" || typeof(x.w) !== "number" || typeof(x.h) !== "number") {
                return false;
            }
            else {
                h = x.h;
                w = x.w;
                y = x.y;
                x = x.x;
            }
        }

        var changeObject = {
            oldx: this.internalPlayerDisplayArea.x,
            oldy: this.internalPlayerDisplayArea.y,
            oldw: this.internalPlayerDisplayArea.w,
            oldh: this.internalPlayerDisplayArea.h,
            x: x,
            y: y,
            w: w,
            h: h,
        };

        this.internalPlayerDisplayArea.x = x;
        this.internalPlayerDisplayArea.y = y;
        this.internalPlayerDisplayArea.w = w;
        this.internalPlayerDisplayArea.h = h;

        this.log("set corrected display area: " + x + ", " + y + ", " + w + ", " + h);

        this._player.setDisplayRect(x, y, w, h);

        this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, changeObject);
        //this.dispatchEvent(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED);
    };

    Obj.prototype.setFullScreen = function () {
        this.setDisplayRect(0, 0, 1920, 1080);
    };

    //Starts buffering a given Url on the dormant player.
    Obj.prototype.startBufferingVideo = function (url, ms, prefunc) {
        if (url === this._prebufferedUrl) {
            return false;
        }
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            this.log("Abort prebuffer: prebuffering is disabled/unsupported");
            return false;
        }
        return false;
    };

    //Swaps the active player with the dormant (prebuffered) player.
    Obj.prototype.playBufferedVideo = function () {
        if (!this._prebufferedUrl) {
            return false;
        }
        if (!this._getDormantPlayer()) {
            return false;
        }

        this.swapPlayers();
        this._prebufferedUrl = null;
        this._prebufferingSeekPosition = null;
        this._player.play();
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.cancelBufferedVideo = function () {
        this._prebufferedUrl = null;
        this._prebufferingSeekPosition = null;
        var dormantPlayer = this._getDormantPlayer();
        if (dormantPlayer) {
            dormantPlayer.pause();
            dormantPlayer.src = "";
            dormantPlayer.load();
        }
    };

    //Returns the Url of the currently buffered video (if any)
    Obj.prototype.getBufferedVideoUrl = function () {
        return this._prebufferedUrl;
    };

    //Other less commonly used functions
    Obj.prototype.close = function () {
        return;
    };
    Obj.prototype.getInternalPlayer = function () {
        return this._player;
    };

    //Gets the dormant player (the one that is not being used to play any video - we'll use this one for prebuffering)
    Obj.prototype._getDormantPlayer = function () {
        return null;
    };

    //Stop the currently active player, and make the dormant player become the active player
    Obj.prototype.swapPlayers = function () {
        var dormantPlayer = this._getDormantPlayer();
        if (!dormantPlayer) {
            return;
        }
    };

    Obj.PlayerEvents = {
        "INIT_COMPLETE": 32,
        "BUFFERING": 131,
        "CURRENT_POSITION": 137,
        "BEGIN_OF_STREAM": 96,
        "STOP_SUCCESS": 36,
        "SEEK_COMPLETED": 35,
        "END_OF_STREAM": 97,
        "ERROR": 98,
        "FILE_NOT_FOUND": 134,
        "PAUSE_COMPLETE": 33,
        "RESUME_COMPLETE": 34
    };
    Obj.prototype.hookEventListeners = function (player) {

        var self = this;

        self.log('hooking event listeners');

        player.addEventListener(function (msgType, p1, p2) {

            self.log('player event ' + msgType + ' (' + typeof(msgType) + ') ' + p1 + ' | ' + p2);

            if (msgType === Obj.PlayerEvents.INIT_COMPLETE) {
                self.dispatchEvent(adfw.PlayerAdapter.Events.STREAM_INFO_READY, {
                    raw: p1,
                    channelType: p2
                });
            }
            else if (msgType === Obj.PlayerEvents.BUFFERING) {
                var percent = parseInt(p1);
                if (percent === 0) {
                    self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_START, {})

                }
                else if (percent === 100) {
                    self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_COMPLETE, {})
                }
                else {
                    self.dispatchEvent(adfw.PlayerAdapter.Events.BUFFERING_PROGRESS, {percent: percent});
                }
            }
            else if (msgType === Obj.PlayerEvents.CURRENT_POSITION) {
                var currentPosition = parseInt(p1);
                var duration = parseInt(p2);
                self._playhead = currentPosition;
                self._duration = duration;
                self.dispatchEvent(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, {
                    ms: self._playhead
                });
            }
            else if (msgType === Obj.PlayerEvents.BEGIN_OF_STREAM) {
                self.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_START, {});
            }
            else if (msgType === Obj.PlayerEvents.STOP_SUCCESS) {
                self.log('STOP_SUCCESS');
            }
            else if (msgType === Obj.PlayerEvents.SEEK_COMPLETED) {
                self.log('SEEK_COMPLETED');
            }
            else if (msgType === Obj.PlayerEvents.END_OF_STREAM) {
                self._playhead = 0;
                self._duration = 0;
                self.dispatchEvent(adfw.PlayerAdapter.Events.RENDERING_COMPLETE, {});
            }
            else if (msgType === Obj.PlayerEvents.ERROR) {
                self.log('ERROR_' + p1);
               	self.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                    message: p1,
                    code: p1
                });
            }
            else if (msgType === Obj.PlayerEvents.FILE_NOT_FOUND) {
                self.log('FILE_NOT_FOUND');
                self.dispatchEvent(adfw.PlayerAdapter.Events.RENDER_ERROR, {
                    message: p1,
                    code: p1
                });
            }
            else if (msgType === Obj.PlayerEvents.PAUSE_COMPLETE) {
                self.log('PAUSE_COMPLETE');
            }
            else if (msgType === Obj.PlayerEvents.RESUME_COMPLETE) {
                self.log('RESUME_COMPLETE');
            }
            else {
                self.log('Unknown player event: ' + msgType + '(' + typeof(msgType) + ')');
            }
        });
    };

    return Obj;
}());
adfw.ServerInterface = (function () {

    "use strict";

    var trackingUrlModifierFunction = null;
    var errorUrlModifierFunction = null;

    var log = function (msg) {
        adfw.Utils.log(msg, "[ADFW SERVERINTERFACE]");
    };
    var error = function (msg) {
        adfw.Utils.error(msg, "[ADFW SERVERINTERFACE]");
    };

    var setTrackingUrlModifierFunction = function (func) {
        if (typeof func === "function") {
            trackingUrlModifierFunction = func;
        }
        else {
            trackingUrlModifierFunction = null;
        }
    };

    var setErrorUrlModifierFunction = function (func) {
        if (typeof func === "function") {
            errorUrlModifierFunction = func;
        }
        else {
            errorUrlModifierFunction = null;
        }
    };

    var fireError = function (tracker, code, message, contentPlayhead, adAssetURI) {
        return feHelper(tracker, code, message, contentPlayhead, adAssetURI);
    };
    var feHelper = function (tracker, code, message, contentPlayhead, adAssetURI) {
        var originalUrl = tracker.getUrl();
        var modifiedUrl = originalUrl;
        if (typeof errorUrlModifierFunction === "function") {
            try {
                var tempModifiedUrl = errorUrlModifierFunction(originalUrl, code);
                if (typeof tempModifiedUrl === "string") {
                    modifiedUrl = tempModifiedUrl;
                }
            }
            catch (e) {
                modifiedUrl = originalUrl;
                error("Exception while modifying error Url: " + e);
            }
        }
        var processedUrl = adfw.MacroHelper.replaceErrorMacros(modifiedUrl, code, message, contentPlayhead, adAssetURI);
        adfw.Utils.fireTrackerUrl(processedUrl);
        adfw.Events.dispatchEvent(adfw.Events.ERROR_TRACKER, {code: code, message: message, url: processedUrl});
        return processedUrl;
    };

    //Given a Tracker object, fires its tracking Url.
    var fireTracker = function (tracker, contentPlayhead, adAssetURI) {
        return ftHelper(tracker, contentPlayhead, adAssetURI);
    };
    var ftHelper = function (tracker, contentPlayhead, adAssetURI) {
        var originalUrl = tracker.getUrl();
        var modifiedUrl = originalUrl;
        if (typeof trackingUrlModifierFunction === "function") {
            try {
                var tempModifiedUrl = trackingUrlModifierFunction(originalUrl, tracker.getID());
                if (typeof tempModifiedUrl === "string") {
                    modifiedUrl = tempModifiedUrl;
                }
            }
            catch (e) {
                modifiedUrl = originalUrl;
                error("Exception while modifying tracker Url: " + e);
            }
        }
        var processedUrl = adfw.MacroHelper.replaceTrackingMacros(modifiedUrl, contentPlayhead, adAssetURI);
        //adfw.Utils.log("Firing tracker: ID=" + tracker.getID() + " Url=" + processedUrl);
        adfw.Utils.fireTrackerUrl(processedUrl);
        adfw.Events.dispatchEvent(adfw.Events.TRACKING_EVENT, {event: tracker.getID(), url: processedUrl});
        return processedUrl;
    };
    return {
        fireTracker: fireTracker,
        fireError: fireError,
        setTrackingUrlModifierFunction: setTrackingUrlModifierFunction,
        setErrorUrlModifierFunction: setErrorUrlModifierFunction,
    };
}());

adfw.Parser = (function () {
    
    "use strict";
    
    var log = function (msg) {
        adfw.Utils.log(msg, "[ADFW PARSER]");
    };
    var error = function (msg) {
        adfw.Utils.error(msg, "[ADFW PARSER]");
    };

    //The progress events
    var progressRegex = new RegExp("\\s*progress\\s*", "i");
    var firstQuartileRegex = new RegExp("\\s*firstQuartile\\s*", "i");
    var midpointRegex = new RegExp("\\s*midpoint\\s*", "i");
    var thirdQuartileRegex = new RegExp("\\s*thirdQuartile\\s*", "i");

    //Other one-time tracker events
    var startRegex = new RegExp("\\s*start\\s*", "i");
    var creativeViewRegex = new RegExp("\\s*creativeView\\s*", "i");
    var completeRegex = new RegExp("\\s*complete\\s*", "i");
    var skipRegex = new RegExp("\\s*skip\\s*", "i");

    /**
     * parse takes VAST/VMAP and converts it into Ad Framework's internal representation (model) of VAST/VMAP. It returns a promise for a list of ads or ad breaks (depending on whether VAST or VMAP was input)
     * @param input Input to the parser - expected to be VAST/VMAP XML. You can pass in String, DOM, or Url to a VAST/VMAP document.
     * @param context Context for parsing, including information such as remaining timeout, whether or not to parse wrappers, etc. Leave null if you don't know what you're doing.
     * @returns {*|promise}
     */
    var parse = function (input, context) {
    	log("Parse");
        context = getNewContext(context);

        var xml;

        //Is the input already XML element?
        if (isXML(input)) {            xml = input;
            log("Parsing from XML Document");
            return parseHelper(xml, context);
        }
        else {
            //Is the input an XML String? If so, convert it to XML object and parse it
            try {
                xml = new adfw.DOMParser().parseFromString(input, "text/xml");
            }
            catch (e) {
                xml = null;
            }
            //If it's valid XML, then parse it
            if (isXML(xml) && (isVAST(xml) || isVMAP(xml))) {
                log("Parsing from XML String");
                return parseHelper(xml, context);
            }
            //Bummer, it's not XML - must be a Url? Let's try AJAXing it
            else {
                //log("Parsing from XML Url");

                return adfw.Utils.ajax(input)
                    .then(function (xhr) {
                        xml = xhr.responseXML;
                        return parseHelper(xml, context);
                    })
                    .timeout(adfw.Config.get("AD_RETRIEVAL_TIMEOUT"), "Ran out of time to retrieve ad XML");
            }
        }
    };

    var parseHelper = function (xml, context) {
        log("parseHelper");
        try {
            if (isVMAP(xml)) {
                return parseVMAPXMLAsync(xml);
            } else if (isVAST(xml)) {
                return parseVASTXMLAsync(xml, context);
            } else {
                sendVSuiteParseError(101, context);
                return adfw.Q.reject("Not a VMAP/VAST document");
            }
        }
        catch (e) {
            error("parseHelper: " + e);
            return adfw.Q.reject("Failed to parse: " + e);
        }
    };

    //Parse a VMAP XmlDocument asynchronously
    var parseVMAPXMLAsync = function (xmlDocument) {
	log("parseVMAPXMLAsync");
        var context = getNewContext();

        //log("parse vmap: " + new XMLSerializer().serializeToString(xmlDocument));

        if (xmlDocument.documentElement) {
            xmlDocument = xmlDocument.documentElement;
        }

        var adBreakNodes = getVMAPNode(xmlDocument, "AdBreak");

        var adBreaks = []; //A list of AdBreak objects

        //Any global extensions?
        for (var nodePosition = 0; nodePosition < xmlDocument.childNodes.length; nodePosition++) {
            var childNode = xmlDocument.childNodes[nodePosition];
            if (childNode.tagName && childNode.tagName.toLowerCase().indexOf("extensions") >= 0) {
                var globalExtensionNodes = getVMAPNode(childNode, "Extension");
                if (globalExtensionNodes) {
                    for (var globalExtensionIndex = 0; globalExtensionIndex < globalExtensionNodes.length; globalExtensionIndex++) {
                        context.globalVMAPExtensions.push((new adfw.XMLSerializer()).serializeToString(globalExtensionNodes[globalExtensionIndex]));
                        //log("Global VMAP Extension: " + context.globalVMAPExtensions[globalExtensionIndex]);
                    }
                }
                break;
            }
        }

        var adbreakParsePromiseArray = [];

        //For each adBreak in the XML...
        for (var i = 0, len = adBreakNodes.length; i < adBreakNodes.length; i++) {
            try {
                var adbreakParsePromise = parseVMAPAdBreakNodeAsync(adBreakNodes[i], context)
                        .then(function (adbreak) {
                            adBreaks.push(adbreak);
                        })
                        .catch(function (err) {
                            error("Failed to parse VMAP adbreak node: " + err);
                        });
                adbreakParsePromiseArray.push(adbreakParsePromise);
            }
            catch (e) {
                error("Failed to parse VMAP adbreak node: " + e);
            }
        }

        return adfw.Q.allSettled(adbreakParsePromiseArray)
            .then(function () {
                if (!adBreaks.length) {
                    var serialized = new adfw.XMLSerializer().serializeToString(xmlDocument).replace(/\s{2,}/gi, " ");
                    error("Empty or problematic VMAP: " + serialized);
                    adfw.Events.dispatchEvent(adfw.Events.PARSING_ERROR, {
                        code: 0,
                        message: "Empty or problematic VMAP",
                        source: serialized
                    });
                }
                return adBreaks;
            });
    };
	
    //Parse a VMAP AdBreak node asynchronously
    var parseVMAPAdBreakNodeAsync = function (adBreakNode, context) {
    	log("parseVMAPAdBreakNodeAsync");
        context = getNewContext(context);

        var errorCode = null; //Gets changed later
        var errorMessage = null; //Gets changed later
        var allowMultipleAds = true; //Gets changed later
        var followRedirects = true; //Gets changed later
        var offset = new adfw.Offset(adBreakNode.getAttribute("timeOffset"));
        var breakType = adBreakNode.getAttribute("breakType");
        var breakID = adBreakNode.getAttribute("breakId");

        //Parse AdBreak TrackingEvents
        var eventTrackerList = [];
        var errorTrackerList = [];
        var trackingNodes = getVMAPNode(adBreakNode, "Tracking");
        if (trackingNodes && trackingNodes.length > 0) {
            for (var j = 0, len = trackingNodes.length; j < len; j++) {
                var trackingNode = trackingNodes[j];
                var event = trackingNode.getAttribute("event");
                var url = getSingleNodeValue(trackingNode);
                if (event && url) {
                    if (event.toLowerCase().trim() === "error") {
                        errorTrackerList.push(new adfw.ErrorTracker(url));
                        context.adParseErrorUrls.push(url);
                    } else {
                        eventTrackerList.push(new adfw.OneTimeTracker(event, url));
                    }
                }
            }
        } else {
            //log("No Tracker nodes detected in VMAP...");
        }

        //Logic for repeating ad breaks (basically save a copy of the XML and parsing context so we can dupe this adbreak)
        var repeatAfter = adBreakNode.getAttribute("repeatAfter");
        var repeatAfterMS = null;
        var stringifiedAdBreakNode = null;
        var parsingContext = null;
        if (typeof repeatAfter === "string") {
            repeatAfterMS = adfw.Utils.convertHMS(repeatAfter);
        }
        if (repeatAfterMS && adBreakNode) {
            //Save a stringified version of ad source node
            stringifiedAdBreakNode = new adfw.XMLSerializer().serializeToString(adBreakNode);
            parsingContext = getNewContext(context);
        }

        //Parse AdBreak AdSource (the thing that holds all of the ads)
        var adSourceID = null;
        var ads = null;
        var adSourceNode = null;

        var adSourceNodes = getVMAPNode(adBreakNode, "AdSource");
        if (adSourceNodes && adSourceNodes.length > 0) {
            adSourceNode = adSourceNodes[0];
        }

        var extensions = {
            global: context.globalVMAPExtensions,
            local: [],
        };
        var extensionNodes = getVMAPNode(adBreakNode, "Extension");
        if (extensionNodes && extensionNodes.length) {
            for (var extensionIndex = 0; extensionIndex < extensionNodes.length; extensionIndex++) {
                var extensionNode = extensionNodes[extensionIndex];
                extensions.local.push((new adfw.XMLSerializer()).serializeToString(extensionNodes[extensionIndex]))
                //log("Local VMAP Extension: " + extensions.local[extensionIndex]);
            }
        }

        if (adSourceNode) {

            adSourceID = adSourceNode.getAttribute("id");

            allowMultipleAds = adSourceNode.getAttribute("allowMultipleAds") || allowMultipleAds;
            followRedirects = adSourceNode.getAttribute("followRedirects") || followRedirects;
            context.allowMultipleAds = adfw.Utils.parseBoolean(allowMultipleAds);
            context.followRedirects = adfw.Utils.parseBoolean(followRedirects);

            //Finish parsing the ad source node
            return parseVMAPAdSourceNodeAsync(adSourceNode, offset, context)
                .then(function (returnedAds) {
                    var adBreak;
                    if (returnedAds instanceof Array) {
                        adBreak = new adfw.AdBreak({
                            offset: offset,
                            breakType: breakType,
                            breakID: breakID,
                            eventTrackers: eventTrackerList,
                            errorTrackers: errorTrackerList,
                            ads: returnedAds,
                            adSourceID: adSourceID,
                            allowMultipleAds: allowMultipleAds,
                            followRedirects: followRedirects,
                            extensions: extensions,
                            repeatAfter: repeatAfterMS,
                            adBreakXMLString: stringifiedAdBreakNode,
                            parsingContext: parsingContext,
                        });
                    }
                    else if (returnedAds instanceof adfw.LazyVASTResolver) {
                        adBreak = new adfw.AdBreak({
                            offset: offset,
                            breakType: breakType,
                            breakID: breakID,
                            eventTrackers: eventTrackerList,
                            errorTrackers: errorTrackerList,
                            ads: [],
                            lazyVASTResolver: returnedAds,
                            adSourceID: adSourceID,
                            allowMultipleAds: allowMultipleAds,
                            followRedirects: followRedirects,
                            extensions: extensions,
                            repeatAfter: repeatAfterMS,
                            adBreakXMLString: stringifiedAdBreakNode,
                            parsingContext: parsingContext,
                        });
                    }

                    return adBreak;
                })
                .catch(function (result) {
                    ads = null;
                    sendVSuiteParseError(1006, context, "Failed to retrieve VAST AdSource");
                    if (eventTrackerList || (extensions.global || extensions.local)) {
                        var adBreak = new adfw.AdBreak({
                            offset: offset,
                            breakType: breakType,
                            breakID: breakID,
                            eventTrackers: eventTrackerList,
                            errorTrackers: errorTrackerList,
                            ads: [],
                            adSourceID: adSourceID,
                            allowMultipleAds: allowMultipleAds,
                            followRedirects: followRedirects,
                            extensions: extensions,
                            repeatAfter: repeatAfterMS,
                            adBreakXMLString: stringifiedAdBreakNode,
                            parsingContext: parsingContext,
                        });
                        return adBreak;
                    } else {
                        return adfw.Q.reject("Failed to parse adbreaks!");
                    }
                })
                .timeout(adfw.Config.get("AD_RETRIEVAL_TIMEOUT"));

        }
        else {
            //log("No AdSource node detected in VMAP... we should fire tracking events anyway though.");
            var errorMessage = "No AdSource node detected from VMAP AdBreak";
            return adfw.Q.reject(errorMessage);
        }
    };


    //Parses a VMAP AdSource node (either inline VAST XML or a redirect to it). The promise that this function is given will be fulfilled with a list of ads.
    var parseVMAPAdSourceNodeAsync = function (adSourceNode, offset, context) {
	log("parseVMAPAdSourceNodeAsync");
        var templateType;

        //2 methods to grab the VASTData because of an error (inconsistency) in the way the VAST data is supposed to be delivered.
        var vastAdData = getVMAPNode(adSourceNode, "VASTData")[0];
        if (!vastAdData) {
            vastAdData = getVMAPNode(adSourceNode, "VASTAdData")[0];
        }

        //If the Ad Source is VAST 3.0 (our favorite)
        if (vastAdData && adSourceNode.getElementsByTagNameNS("*", "VAST")[0]) {
            var vastNode = vastAdData.getElementsByTagNameNS("*", "VAST")[0];
            //log("Reading VAST3 ads...");
            return parseVASTXMLAsync(vastNode, context);
        }

        /*
         * If the Ad Source is a redirect Url...
         * First we need to check if the document will be VAST3 or VAST2. If it isn't it's not supported anyway, so don't grab the redirect.
         * If it's a supported document type, grab it and parse its ads.
         * */
        else if (getVMAPNode(adSourceNode, "AdTagURI") && getVMAPNode(adSourceNode, "AdTagURI").length) {
            var redirectNode = getVMAPNode(adSourceNode, "AdTagURI")[0];
            if (redirectNode) {
                var redirectUrl = getSingleNodeValue(redirectNode);
                templateType = redirectNode.getAttribute("templateType");
            }

            if (templateType && (templateType.toLowerCase().trim() === "vast2" || templateType.toLowerCase().trim() === "vast3")) {
                //log("Reading " + templateType + " from redirect Url: " + redirectUrl);


                if (true === adfw.Config.get("ADBREAK_LAZY_LOAD") && !(offset.getType() === adfw.Offset.OffsetType.STATIC_OFFSET_START)) {
                    //If it's not a preroll, and we have ADBREAK_LAZY_LOAD on, we will lazy-load this adbreak instead
                    var lazyLoader = new adfw.LazyVASTResolver(redirectUrl, getNewContext(context));
                    return adfw.Q(lazyLoader);
                }
                else {
                    return parse(redirectUrl, context);
                }


            } else {
                var errorMessage = "Unsupported ad templateType: " + templateType;
                sendVSuiteParseError(1005, context, errorMessage);
                return adfw.Q.reject(errorMessage);
            }
        }

        /*
         * If the Ad Source is CustomAdData
         * First we need to check if the CustomAdData will be VAST2. If it isn't it's not supported, so we don't parse it.
         * If it's VAST2, we take the CDATA string and make it into a VAST2 XML, and load ads from it.
         * */
        else if (getVMAPNode(adSourceNode, "CustomAdData") && getVMAPNode(adSourceNode, "CustomAdData").length) {
            var customAdDataNode = getVMAPNode(adSourceNode, "CustomAdData")[0];
            templateType = customAdDataNode.getAttribute("templateType");
            if (templateType && templateType.toLowerCase().trim() === "vast2") {
                var cdataString = getSingleNodeValue(customAdDataNode);
                //log("Parsing custom ad data: " + templateType);
                return parseVASTXMLAsync(new adfw.DOMParser().parseFromString(cdataString, "text/xml"), context)
            } else {
                var errorMessage = "Unsupported ad templateType: " + templateType;
                sendVSuiteParseError(1005, context, errorMessage);
                return adfw.Q.reject(errorMessage);
            }
        } else {
            //log("No AdSource detected in VMAP... we should fire tracking events anyway though.");
            var errorMessage = "No valid AdSource detected from VMAP AdBreak"
            sendVSuiteParseError(1005, context, errorMessage);
            return adfw.Q.reject(errorMessage);
        }
    };

    var parseVASTXMLAsync = function (xml, context) {
	log("parseVASTXMLAsync");
        context = getNewContext(context);

        //Parse the VAST error Urls. This Url is only called if we fail to get any ads during the parsing stage (it's not used to track playback errors).
        //Note that there are several <Error> tags in VAST - one belonging to the root <VAST> node, the other belonging to the <Ad> node. We ONLY want the root error. Therefore we can't use getElementsByTagName
        try {
            var document = xml;
            if (xml.nodeName !== "VAST") {
                document = xml.getElementsByTagName("VAST")[0];
            }
            for (var nodePosition = 0, len = document.childNodes.length; nodePosition < len; nodePosition++) {
                var childNode = document.childNodes[nodePosition];
                if (childNode.tagName && childNode.tagName.toLowerCase() === "error") {
                    context.adParseErrorUrls.push(getSingleNodeValue(childNode));
                    //log(getSingleNodeValue(childNode));
                }
            }

            //Verify VAST Version
            var versionString = document.getAttribute("version");
            try {
                var versionNumber = parseFloat(versionString, 10);
                if (versionNumber < 2) {
                    sendVSuiteParseError(102, context, "Only VAST versions 2.0 to 4.0 are supported: " + versionNumber);
                    return adfw.Q.reject("Only VAST versions 2.0 to 3.0 are supported: " + versionNumber);
                } else if (versionNumber > 4) {
                    sendVSuiteParseError(102, context, "Only VAST versions 2.0 to 4.0 are officially supported, but will make an attempt to parse: " + versionNumber);
                }

            } catch (e) {
                sendVSuiteParseError(100, context, "Unable to verify VAST version, but will attempt to parse: " + versionString);
            }
        } catch (e) {
            error("Failed to parse VAST error nodes: " + e);
        }

        var wrapperPromisesArray = [];
        var adElementList = makeList(xml.getElementsByTagName("Ad"));
        var currentNode = null;
        var wrapperUrl = null;
        var ads = [];
        var tempAd = null;
        var i = 0;
        var x = 0;
        var j = 0;
        var y = 0;
        var llen, nlen;

        try {
            for (i = 0; i < adElementList.length; i++) {
                var thisadElementList = adElementList[i];
                var adID = thisadElementList.getAttribute("id");
                var sequence = thisadElementList.getAttribute("sequence");
                sequence = parseInt(sequence, 10);
                if (+sequence !== sequence) { //isNaN
                    sequence = null;
                }
                if (thisadElementList.getElementsByTagName("InLine").length > 0) {
                    currentNode = thisadElementList.getElementsByTagName("InLine")[0];
                    try {
                        tempAd = parseInLineAdElementSync(currentNode, context, sequence);
                        if (tempAd) {
                            ads.push({
                                id: adID,
                                type: "inline",
                                status: "fulfilled",
                                ads: [tempAd],
                                depth: context.depth,
                                sequence: sequence,
                            });
                        }
                    } catch (e) {
                        sendVSuiteParseError(100, context, "Exception while parsing InLine ad element: " + e);
                    }
                } else if (thisadElementList.getElementsByTagName("Wrapper").length > 0) {
                    currentNode = thisadElementList.getElementsByTagName("Wrapper")[0];
                    wrapperUrl = getSingleNodeValue(currentNode.getElementsByTagName("VASTAdTagURI"));

                    if (!wrapperUrl || !wrapperUrl.trim()) {
                        sendVSuiteParseError(101, context, "Failed to parse Wrapper ad element: Missing VastAdTagURI");
                        continue;
                    }

                    //Check if we're allowed to parse the wrapper. Then go get it.
                    if ((context.depth + 1) > adfw.Config.get("MAX_VAST_WRAPPER_DEPTH")) {
                        sendVSuiteParseError(302, context, "maximum wrapper depth reached: " + context.depth);
                    } else if (context.followRedirects === false) {
                        log("followRedirects is disabled");
                    } else if (context.followAdditionalWrappers === false) {
                        log("followAdditionalWrappers is disabled");
                    } else {
                        //Parse the wrapper.

                        //First let's get it a new context so it doesn't pollute this scope.
                        var wrapperContext = getNewContext(context);

                        //Fill up the wrapperContext with this wrapper's information
                        var creativeNodes = currentNode.getElementsByTagName("Creative");
                        for (var y = 0, len = creativeNodes.length; y < len; y++) {
                            var creativeNode = creativeNodes[y];
                            var linearNode = creativeNode.getElementsByTagName("Linear")[0]; //Assume 0 or 1 nodes (this may be incorrect - the spec is ambiguous)
                            var nonLinearNode = creativeNode.getElementsByTagName("NonLinearAds")[0]; //Assume 0 or 1 nodes (this may be incorrect - the spec is ambiguous)
                            var companionNodes = creativeNode.getElementsByTagName("Companion"); //0 or more nodes
                            var currentTrackingNode;
                            if (linearNode) {
                                var trackingNodes = linearNode.getElementsByTagName("Tracking");
                                for (x = 0, llen = trackingNodes.length; x < llen; x++) {
                                    currentTrackingNode = trackingNodes[x];
                                    var tempMap = {
                                        url: getSingleNodeValue(currentTrackingNode),
                                        id: currentTrackingNode.getAttribute("event"),
                                        offset: currentTrackingNode.getAttribute("offset")
                                    };
                                    wrapperContext.linearCreativeTrackerTemp.push(tempMap);
                                }

                                var clicksNodes = linearNode.getElementsByTagName("ClickTracking");

                                for (x = 0; x < clicksNodes.length; x++) {
                                    currentTrackingNode = clicksNodes[x];
                                    var tempMap = {
                                        url: getSingleNodeValue(currentTrackingNode),
                                        id: currentTrackingNode.getAttribute("id")
                                    };
                                    wrapperContext.linearCreativeClicksTemp.push(tempMap);
                                }
                                var iconNodes = linearNode.getElementsByTagName("Icon");
                                for (x = 0; x < iconNodes.length; x++) {
                                    var currentIconNode = iconNodes[x];
                                    var currentIconNodeString = (new adfw.XMLSerializer()).serializeToString(currentIconNode);
                                    var tempMap = {
                                        iconNodeString: currentIconNodeString,
                                        depth: context.depth
                                    };
                                    wrapperContext.linearCreativeIconsTemp.push(tempMap);
                                }

                            }
                            if (nonLinearNode) {
                                var trackingNodes = nonLinearNode.getElementsByTagName("Tracking");
                                for (j = 0, nlen = trackingNodes.length; j < nlen; j++) {
                                    currentTrackingNode = trackingNodes[j];
                                    var tempMap = {
                                        url: getSingleNodeValue(currentTrackingNode),
                                        id: currentTrackingNode.getAttribute("event"),
                                        offset: currentTrackingNode.getAttribute("offset")
                                    };
                                    wrapperContext.nonLinearCreativeTrackerTemp.push(tempMap);
                                }

                                var clicksNodes = nonLinearNode.getElementsByTagName("NonLinearClickTracking");
                                for (x = 0; x < clicksNodes.length; x++) {
                                    currentTrackingNode = clicksNodes[x];
                                    var tempMap = {
                                        url: getSingleNodeValue(currentTrackingNode),
                                        id: currentTrackingNode.getAttribute("id")
                                    };
                                    wrapperContext.nonLinearCreativeClicksTemp.push(tempMap);
                                }
                            }
                            if (companionNodes.length > 0) {
                                //Saving creativeNode into Context
                                //XMLNode To String
                                var creativeNodeString = (new adfw.XMLSerializer()).serializeToString(creativeNode);
                                var tempMap = {
                                    creativeNodeString: creativeNodeString,
                                    depth: context.depth
                                };
                                wrapperContext.companionCreativeNode.push(tempMap);
                            }

                        }

                        //Parse VAST extensions and place them in the context
                        var extensionsNode = currentNode.getElementsByTagName("Extensions");
                        var parsedExtensions = parseVASTExtensionsNode(extensionsNode);
                        wrapperContext.vastExtensions = wrapperContext.vastExtensions ? wrapperContext.vastExtensions.concat(parsedExtensions) : parsedExtensions;
                        //I am not sure if the <Wrapper> <Error> Urls should be called during parsing errors - doing it anyway. Comment this line out to stop.
                        wrapperContext.adParseErrorUrls = wrapperContext.adParseErrorUrls.concat(getMultipleNodeValues(currentNode.getElementsByTagName("Error")));

                        wrapperContext.errorUrls = wrapperContext.errorUrls.concat(getMultipleNodeValues(currentNode.getElementsByTagName("Error")));
                        wrapperContext.impressionUrls = wrapperContext.impressionUrls.concat(getMultipleNodeValues(currentNode.getElementsByTagName("Impression")));
                        //log(getSingleNodeValue(currentNode.getElementsByTagName("AdSystem")) + " impressions: " + currentNode.getElementsByTagName("Impression").length);

                        var followAdditionalWrappers = currentNode.getAttribute("followAdditionalWrappers");
                        followAdditionalWrappers = followAdditionalWrappers ? adfw.Utils.parseBoolean(followAdditionalWrappers) : true;
                        wrapperContext.followAdditionalWrappers = followAdditionalWrappers && wrapperContext.followAdditionalWrappers;

                        var allowMultipleAds = currentNode.getAttribute("allowMultipleAds");
                        allowMultipleAds = allowMultipleAds ? adfw.Utils.parseBoolean(allowMultipleAds) : true;
                        wrapperContext.allowMultipleAds = allowMultipleAds && wrapperContext.allowMultipleAds;

                        //Parse the wrapper
                        (function () {
                            var promisedAds = {
                                id: adID,
                                type: "wrapper",
                                status: "promised " + i,
                                depth: wrapperContext.depth,
                                sequence: sequence,
                                ads: []
                            };
                            ads.push(promisedAds);

                            var wrapperSystem = getSingleNodeValue(currentNode.getElementsByTagName("AdSystem"));

                            var fallbackOnNoAd = currentNode.getAttribute("fallbackOnNoAd");
                            fallbackOnNoAd = fallbackOnNoAd ? adfw.Utils.parseBoolean(fallbackOnNoAd) : false;

                            var wrapperPromise = parseWrapperAdElementAsync(wrapperUrl, wrapperContext)
                                    .then(function (list) {
                                        promisedAds.status = "fulfilled";
                                        promisedAds.ads = list;

                                        //Check if allowMultipleAds is on
                                        if (wrapperContext.allowMultipleAds === false && list && list.length > 0) {
                                            var singleAd = list[0];
                                            for (var n = 0; n < list.length; n++) {
                                                if (!list[n].sequence) {
                                                    singleAd = list[n];
                                                }
                                            }
                                            promisedAds.ads = [singleAd];
                                        }
                                        return list;
                                    })
                                    .catch(function (result) {
                                        promisedAds.status = "broken";

                                        if (fallbackOnNoAd === true) {
                                            try {

                                                //Yank out one of the inLine NONSEQUENCED ads and stick it where the fallback should be.
                                                for (var f = 0; f < ads.length; f++) {
                                                    var adHolder = ads[f];
                                                    if (adHolder.type === "inline" && adHolder.ads && !adHolder.sequence) {
                                                        promisedAds.ads = adHolder.ads;
                                                        promisedAds.ads[0].sequence = promisedAds.sequence;
                                                        promisedAds.status = "fallback";
                                                        ads.splice(f, 1);
                                                        log(promisedAds.id + " broken; replacing with " + adHolder.id);
                                                        break;
                                                    }
                                                }
                                            } catch (e) {
                                                log("FALLBACKONNOAD error: " + e);
                                            }
                                        }
                                    })
                                    .timeout(getRetrievalTimeRemaining(wrapperContext));

                            wrapperPromisesArray.push(wrapperPromise);
                        }());
                    }
                } else {
                    var errorMessage = "Ad has no InLine or Wrapper tags! " + thisadElementList.getAttribute("id");
                    sendVSuiteParseError(101, context, errorMessage);
                }

            }

            return adfw.Q.allSettled(wrapperPromisesArray)
                .then(function () {
                    ads.sort(function (a, b) {
                        var ret = 0;
                        var a_sequence = parseInt(a.sequence, 10),
                            b_sequence = parseInt(b.sequence, 10);

                        if (a_sequence > b_sequence) {
                            ret = 1;
                        } else if (a_sequence < b_sequence) {
                            ret = -1;
                        } else if (+a_sequence !== a_sequence) { //a_sequence is NaN
                            if (+b_sequence === b_sequence) { //b_sequence is NUMBER
                                ret = 1;
                            }
                        } else if (+b_sequence !== b_sequence) { //b_sequence is NaN
                            if (+a_sequence === a_sequence) { //a_sequence is NUMBER
                                ret = -1;
                            }
                        }

                        return ret;
                    });
                    var mergedAds = deepMerge(ads);

                    if (!mergedAds.length) {
                        var serialized = new adfw.XMLSerializer().serializeToString(xml).replace(/\s{2,}/gi, " ");
                        error("Empty or problematic VAST: " + serialized);
                        adfw.Events.dispatchEvent(adfw.Events.PARSING_ERROR, {
                            code: 0,
                            message: "Empty or problematic VAST",
                            source: serialized
                        });
                    }

                    return mergedAds;
                });
        }
        catch (e) {
            error("Failed to parse VAST: " + e);
            return adfw.Q.reject(e);
        }
    };

    //Parse a VAST Wrapper Url asynchronously
    var parseWrapperAdElementAsync = function (wrapperUrl, context) {
	log("parseWrapperAdElementAsync");
        context = getNewContext(context);
        context.depth++;

        return adfw.Utils.ajax(wrapperUrl)
            .then(function (xhr) {
                if (xhr && xhr.responseXML) {
                    if (isVAST(xhr.responseXML)) {
                        if (xhr.responseXML.getElementsByTagName("Ad").length > 0) {
                            return parseVASTXMLAsync(xhr.responseXML, context);
                        } else {
                            var errorCode = 303;
                            var errorMessage = adfw.Errors[errorCode];
                            sendVSuiteParseError(errorCode, context, errorMessage);
                            return adfw.Q.reject(errorMessage);
                        }
                    } else {
                        var errorMessage = "Retrieved wrapper Url is not a valid VAST document";
                        sendVSuiteParseError(101, context, errorMessage);
                        return adfw.Q.reject(errorMessage);
                    }
                } else {
                    var errorMessage = "Wrapper AJAX request returned no data";
                    sendVSuiteParseError(300, context, errorMessage);
                    return adfw.Q.reject(errorMessage);
                }
            })
            .catch(function (result) {
                var errorCode = 301;
                var errorMessage = adfw.Errors[errorCode];
                sendVSuiteParseError(errorCode, context, errorMessage);
                throw(errorMessage);
            })
            .timeout(getRetrievalTimeRemaining(context), "Ran out of time to get wrapper!");
    };

    //Parse a VAST InLine node. This is synchronous because there are no wrappers or redirects possibles in InLines
    //Creates an adfw.Ad object that holds a list of creatives.
    var parseInLineAdElementSync = function (adEle, context, sequence) {
    	log("parseInLineAdElementSync");
        try {
            context = getNewContext(context); //Copy the params map so that it does not pollute the previous function's params
            var adSystem = getSingleNodeValue(adEle.getElementsByTagName("AdSystem"));
            if (typeof adSystem === 'string') {
                adSystem = adSystem.trim();
            }
            if (!adSystem) {
                sendVSuiteParseError(101, context, "AdSystem is a required attribute, however the parsing will continue as planned.");
            }
            var adTitle = getSingleNodeValue(adEle.getElementsByTagName("AdTitle"));
            if (typeof adTitle === 'string') {
                adTitle = adTitle.trim();
            }
            if (!adTitle) {
                sendVSuiteParseError(101, context, "AdTitle is a required attribute, however the parsing will continue as planned.");
            }

            var errorTrackers = parseErrorNodes(adEle.getElementsByTagName("Error"));
            if (context.errorUrls) {
                errorTrackers = errorTrackers.concat(parseErrorNodes(context.errorUrls));
            }
            var impressionTrackers = parseImpressionNodes(adEle.getElementsByTagName("Impression"));
            if (context.impressionUrls) {
                impressionTrackers = impressionTrackers.concat(parseImpressionNodes(context.impressionUrls));
            }
            if (!impressionTrackers || !impressionTrackers.length) {
                sendVSuiteParseError(101, context, "Failed to parse Ad: Ad's Impression node is missing");
                return null;
            }


            var adDescription = getSingleNodeValue(adEle.getElementsByTagName("Description"));
            var advertiser = getSingleNodeValue(adEle.getElementsByTagName("Advertiser"));
            var pricing = getSingleNodeValue(adEle.getElementsByTagName("Pricing"));
            var survey = getSingleNodeValue(adEle.getElementsByTagName("Survey"));

            var extensionsNode = adEle.getElementsByTagName("Extensions");
            var parsedExtensions = parseVASTExtensionsNode(extensionsNode);
            var extensions = context.vastExtensions ? context.vastExtensions.concat(parsedExtensions) : parsedExtensions;

            //TODO: Make this better (I've commented it out for now)
            // 			var internalExtensions = {};
            // 			//Parse internal extensions such as secondscreen
            // 			if(extensionsNode && extensionsNode.childNodes && extensionsNode.childNodes.length) 
            // 			{
            // 				//log("Second Screen Parser");

            // 				// Parse Second Screen Extension
            // 				var secondScreen = {};
            // 				var secondScreenNode = extensionsNode.getElementsByTagName("SecondScreen")[0];
            // 				if(secondScreenNode)
            // 				{
            // 					//log("secondScreenNode is not null");

            // 					var bgImage = getSingleNodeValue(secondScreenNode.getElementsByTagName("BgImage"));
            // 					var bgImageWidth = secondScreenNode.getElementsByTagName("BgImage")[0].getAttribute("width");
            // 					var bgImageHeight = secondScreenNode.getElementsByTagName("BgImage")[0].getAttribute("height");
            // 					var title = getSingleNodeValue(secondScreenNode.getElementsByTagName("Title"));
            // 					var go = getSingleNodeValue(secondScreenNode.getElementsByTagName("GO"));
            // 					var go_tracking = secondScreenNode.getElementsByTagName("GO")[0].getAttribute("tracking");
            // 					var buy = getSingleNodeValue(secondScreenNode.getElementsByTagName("BUY"));
            // 					var buy_tracking = secondScreenNode.getElementsByTagName("BUY")[0].getAttribute("tracking");
            // 					var share = getSingleNodeValue(secondScreenNode.getElementsByTagName("SHARE"));
            // 					var share_tracking = secondScreenNode.getElementsByTagName("SHARE")[0].getAttribute("tracking");
            // 					var replay = getSingleNodeValue(secondScreenNode.getElementsByTagName("REPLAY"));
            // 					var replay_tracking = secondScreenNode.getElementsByTagName("REPLAY")[0].getAttribute("tracking");
            // 					var coupon = getSingleNodeValue(secondScreenNode.getElementsByTagName("COUPON"));
            // 					var coupon_tracking = secondScreenNode.getElementsByTagName("COUPON")[0].getAttribute("tracking");

            // 					secondScreen.bgImage = bgImage;
            // 					secondScreen.bgImageWidth = bgImageWidth;
            // 					secondScreen.bgImageHeight = bgImageHeight;
            // 					secondScreen.title = title;
            // 					secondScreen.go = go;
            // 					secondScreen.go_tracking = go_tracking;
            // 					secondScreen.buy = buy;
            // 					secondScreen.buy_tracking = buy_tracking;
            // 					secondScreen.share = share;
            // 					secondScreen.share_tracking = share_tracking;
            // 					secondScreen.replay = replay;
            // 					secondScreen.replay_tracking = replay_tracking;
            // 					secondScreen.coupon = coupon;
            // 					secondScreen.coupon_tracking = coupon_tracking;

            // //                  log("bgImage: " + bgImage);
            // //                  log("bgImageWidth: " + bgImageWidth);
            // //                  log("bgImageHeight: " + bgImageHeight);
            // //                  log("title: " + title);
            // //                  log("go: " + go);
            // //                  log("go_tracking: " + go_tracking);
            // //                  log("buy: " + buy);
            // //                  log("buy_tracking: " + buy_tracking);
            // //                  log("share: " + share);
            // //                  log("share_tracking: " + share_tracking);
            // //                  log("replay: " + replay);
            // //                  log("replay_tracking: " + replay_tracking);
            // //                  log("coupon: " + coupon);
            // //                  log("coupon_tracking: " + coupon_tracking);
            // 				}
            // 				internalExtensions.secondScreen = secondScreen;

            // //              for(var extensionNodeNumber = 0; extensionNodeNumber < extensionsNode.childNodes.length; extensionNodeNumber++) 
            // //              {
            // //                  if(extensionsNode.childNodes[extensionNodeNumber] && extensionsNode.childNodes[extensionNodeNumber].tagName) 
            // //                  {
            // //                      var vastExtensionNodeXML = (new XMLSerializer()).serializeToString(extensionsNode.childNodes[extensionNodeNumber]);
            // //                      vastExtensionStringList.push(vastExtensionNodeXML);
            // //                      //log("Extension Parsed: " + vastExtensionNodeXML);
            // //                  }                   
            // //              }
            // 			}

            try {
                var creativesNode = adEle.getElementsByTagName("Creatives")[0];
                var creatives = parseCreativeNodes(creativesNode.getElementsByTagName("Creative"), context);
                if (!creatives || !creatives.length) {

                    sendVSuiteParseError(101, context, "Failed to parse Ad: InLine Ad Element has no valid creatives");
                    return null;
                } else {
                    return new adfw.Ad({
                        impressionTrackers: impressionTrackers,
                        errorTrackers: errorTrackers,
                        creatives: creatives,
                        adSystem: adSystem,
                        adTitle: adTitle,
                        advertiser: advertiser,
                        sequence: sequence,
                        originalSequence: sequence,
                        description: adDescription,
                        pricing: pricing,
                        survey: survey,
                        //internalExtensions: internalExtensions,
                        extensions: extensions,
                        type: 'inline'
                    });
                }
            } catch (e) {
                sendVSuiteParseError(101, context, "Failed to parse Ad: InLine Ad Element has no valid creatives: " + e);
            }

        } catch (e) {
            log(e);
        }
    };

    //Parse a collection of Creative nodes
    var parseCreativeNodes = function (creativeNodes, context) {
    	log("parseCreativeNodes");
        context = getNewContext(context);
        var creatives = [];
        if (!creativeNodes || !creativeNodes.length) {
            return creatives;
        }
        for (var i = 0; i < creativeNodes.length; i++) {
            var creativeNode = creativeNodes[i];
            var creativeObject = parseCreativeNode(creativeNode, context);
            if (creativeObject) {
                creatives.push(creativeObject);
            }
        }
        var tempcreative = getCompanionCreativeFromContext(context);
        if (tempcreative) {
            creatives = creatives.concat(tempcreative);
        }

        return creatives;
    };

    var getCompanionCreativeFromContext = function (context) {
	log("getCompanionCreativeFromContext");
        var creatives = [];
        if (context.companionCreativeNode) {
            for (var i = 0; i < context.companionCreativeNode.length; i++) {
                var creativeNodeString = context.companionCreativeNode[i].creativeNodeString,
                    creativeNode = (new adfw.DOMParser()).parseFromString(creativeNodeString, "text/xml").firstChild,
                    companionNodes = creativeNode.getElementsByTagName("Companion"); //0 or more nodes
                creatives.push(companionParser.companionNodesToCompanionCreative(creativeNode, companionNodes));
            }
        }
        return creatives;
    };

    //Given a VAST extensions node, serializes all <Extension> tags and places them into an array
    var parseVASTExtensionsNode = function (extensionsNode) {
    	log("parseVASTExtensionsNode");
        if (extensionsNode && extensionsNode.length) {
            extensionsNode = extensionsNode[0];
        }
        var extensions = [];
        if (extensionsNode && extensionsNode.childNodes && extensionsNode.childNodes.length) {
            var extensionNodes = extensionsNode.getElementsByTagName("Extension");
            if (extensionNodes && extensionNodes.length) {
                for (var extensionIndex = 0; extensionIndex < extensionNodes.length; extensionIndex++) {
                    var extensionNode = extensionNodes[extensionIndex];
                    extensions.push((new adfw.XMLSerializer()).serializeToString(extensionNodes[extensionIndex]))
                    //log("VAST Extension: " + extensions[extensionIndex]);
                }
            }
        }
        return extensions;
    };

    //Parse a single <Creative> node. A creative may be Linear, Nonlinear, or Companion. This function will return any of those 3 (as an instanceof Creative)
    var parseCreativeNode = function (creativeNode, context) {
    	log("parseCreativeNode");
        context = getNewContext(context);
        var creativeID = creativeNode.getAttribute("id");
        var creativeSequence = creativeNode.getAttribute("sequence");
        var creativeAdID = creativeNode.getAttribute("adID");
        var creativeAPIFramework = creativeNode.getAttribute("apiFramework");

        var linearNode = creativeNode.getElementsByTagName("Linear")[0]; //Assume 0 or 1 nodes (this may be incorrect - the spec is ambiguous)
        var nonLinearNode = creativeNode.getElementsByTagName("NonLinearAds")[0]; //Assume 0 or 1 nodes that contain multiple variations
        var companionNodes = creativeNode.getElementsByTagName("Companion"); //0 or more nodes

        var creativeObject = null;
        if (linearNode) {
            var skipOffset = linearNode.getAttribute("skipoffset");

            var adParametersNode = linearNode.getElementsByTagName("AdParameters");
            var adParameters = null;
            if (adParametersNode) {
                adParameters = getSingleNodeValue(adParametersNode);
            }

            var originalDuration = getSingleNodeValue(linearNode.getElementsByTagName("Duration"));
            var duration = adfw.Utils.convertHMS(originalDuration);
            if (!duration || isNaN(duration)) {
                sendVSuiteParseError(101, context, "Failed to parse LinearCreative: Invalid Duration " + duration + " | " + originalDuration);
                return null;
            }

            //Parse ad media files
            var mediaFiles = [];
            var mediaFilesNode = linearNode.getElementsByTagName("MediaFile");

            // nilsh: Add support for VAST 4.0 InteractiveCreativeFile
            var interactiveCreativeFile = linearNode.getElementsByTagName("InteractiveCreativeFile");

            if (interactiveCreativeFile.length > 0) {
                // If the InteractiveCreativeFile is found it should be loaded first.
                // It will be interpreted as VPAID.
                mediaFiles.unshift(
                    new adfw.LinearMediaFile({
                        url: getSingleNodeValue(interactiveCreativeFile[0]),
                        type: interactiveCreativeFile[0].getAttribute("type"), 
                        width: "0",
                        height: "0",
                        delivery: interactiveCreativeFile[0].getAttribute('delivery'),
                        scalable: "",
                        bitrate: "",
                        maxBitrate: "",
                        minBitrate: "",
                        codec: "",
                        apiFramework: interactiveCreativeFile[0].getAttribute("apiFramework"), 
                        maintainAspectRatio: "",
                        isInteractiveCreativeFile: true
                    })
                );
            }

            for (var i = 0; i < mediaFilesNode.length; i++) {

                var mediaFileDelivery = mediaFilesNode[i].getAttribute("delivery");
                var mediaFileType = mediaFilesNode[i].getAttribute("type");
                var mediaFileUrl = getSingleNodeValue(mediaFilesNode[i]);

                if (!mediaFileDelivery || !mediaFileDelivery.trim()) {
                    sendVSuiteParseError(101, context, "Failed to parse MediaFile: Missing Delivery");
                } else if (!mediaFileType || !mediaFileType.trim()) {
                    sendVSuiteParseError(101, context, "Failed to parse MediaFile: Missing Type");
                } else if (!mediaFileUrl || !mediaFileUrl.trim()) {
                    sendVSuiteParseError(101, context, "Failed to parse MediaFile: Missing Url");
                } else {
                    mediaFiles.push(new adfw.LinearMediaFile({
                        url: mediaFileUrl,
                        type: mediaFileType,
                        width: mediaFilesNode[i].getAttribute("width"),
                        height: mediaFilesNode[i].getAttribute("height"),
                        delivery: mediaFileDelivery,
                        scalable: mediaFilesNode[i].getAttribute("scalable"),
                        bitrate: mediaFilesNode[i].getAttribute("bitrate"),
                        maxBitrate: mediaFilesNode[i].getAttribute("maxBitrate"),
                        minBitrate: mediaFilesNode[i].getAttribute("minBitrate"),
                        codec: mediaFilesNode[i].getAttribute("codec"),
                        apiFramework: mediaFilesNode[i].getAttribute("apiFramework"),
                        maintainAspectRatio: mediaFilesNode[i].getAttribute("maintainAspectRatio")
                    }));
                }
            }
            if (!mediaFiles || !mediaFiles.length) {
                sendVSuiteParseError(101, context, "Failed to parse LinearCreative: Missing MediaFiles");
                return null;
            }

            //Parse ad trackers
            var trackerNodes = linearNode.getElementsByTagName("Tracking");
            var eventTrackers = parseTrackerNodes(trackerNodes);
            //Get trackers from parent wrappers

            if (context.linearCreativeTrackerTemp) {
                for (var x = 0, len = context.linearCreativeTrackerTemp.length; x < len; x++) {
                    if (context.linearCreativeTrackerTemp[x].id) {
                        var trackerID = context.linearCreativeTrackerTemp[x].id;
                        var trackerUrl = context.linearCreativeTrackerTemp[x].url;

                        if (firstQuartileRegex.test(trackerID)) {
                            eventTrackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "25%"));
                        } else if (midpointRegex.test(trackerID)) {
                            eventTrackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "50%"));
                        } else if (thirdQuartileRegex.test(trackerID)) {
                            eventTrackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "75%"));
                        } else if (progressRegex.test(trackerID)) {
                            eventTrackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, context.linearCreativeTrackerTemp[i].offset));
                        } else {
                            if (startRegex.test(trackerID) || creativeViewRegex.test(trackerID) || completeRegex.test(trackerID) || skipRegex.test(trackerID)) {
                                eventTrackers.push(new adfw.OneTimeTracker(trackerID, trackerUrl));
                            } else {
                                eventTrackers.push(new adfw.Tracker(trackerID, trackerUrl));
                            }
                        }
                    }
                }
            }

            var clickThrough = getSingleNodeValue(linearNode.getElementsByTagName("ClickThrough"));
            var clickTrackers = parseClickTrackingNodes(linearNode.getElementsByTagName("ClickTracking"));
            if (context.linearCreativeClicksTemp) {
                for (var r = 0; r < context.linearCreativeClicksTemp.length; r++) {
                    var trackerUrl = context.linearCreativeClicksTemp[r].url;
                    var trackerID = context.linearCreativeClicksTemp[r].id;
                    clickTrackers.push(new adfw.ClickTracker(trackerID, trackerUrl));
                }
            }

            //Support parsing icons
            var icons = [];

            //Icons from wrappers
            if (context.linearCreativeIconsTemp) {
                for (var i = 0; i < context.linearCreativeIconsTemp.length; i++) {
                    var iconXMLString = context.linearCreativeIconsTemp[i].iconNodeString;
                    var depth = context.linearCreativeIconsTemp[i].depth;
                    var iconXML = new adfw.DOMParser().parseFromString(iconXMLString, "text/xml");
                    icons.push(iconParser.iconNodeToIconObjects(iconXML.documentElement, depth));
                }
            }

            //Icons from inline
            var iconNodes = linearNode.getElementsByTagName("Icon");
            for (var i = 0; i < iconNodes.length; i++) {
                icons.push(iconParser.iconNodeToIconObjects(iconNodes[i], 0));
            }
            creativeObject = new adfw.LinearCreative({
                //General Creative stuff
                id: creativeID,
                sequence: creativeSequence,
                adID: creativeAdID,
                apiFramework: creativeAPIFramework,
                adParameters: adParameters,
                //Variables specific to Linears
                skipOffset: skipOffset,
                duration: duration,
                mediaFiles: mediaFiles,
                eventTrackers: eventTrackers,
                icons: icons,
                clickThrough: clickThrough,
                clickTrackers: clickTrackers
            });
        }
        if (nonLinearNode) {

            //Parse ad trackers
            var trackerNodes = nonLinearNode.getElementsByTagName("Tracking");
            var eventTrackers = parseTrackerNodes(trackerNodes);
            if (context.nonLinearCreativeTrackerTemp) {
                for (var u = 0; u < context.nonLinearCreativeTrackerTemp.length; u++) {
                    var trackerUrl = context.nonLinearCreativeTrackerTemp[u].url;
                    var trackerID = context.nonLinearCreativeTrackerTemp[u].id;
                    if (creativeViewRegex.test(trackerID)) {
                        eventTrackers.push(new adfw.OneTimeTracker(trackerID, trackerUrl));
                    } else {
                        eventTrackers.push(new adfw.Tracker(trackerID, trackerUrl));
                    }
                }
            }

            var variations = [];

            //Parse NonLinear variations
            var nonLinearNodes = nonLinearNode.getElementsByTagName("NonLinear");
            for (var j = 0; j < nonLinearNodes.length; j++) {
                var variationNode = nonLinearNodes[j];
                var id = variationNode.getAttribute("id");
                var width = variationNode.getAttribute("width");
                var height = variationNode.getAttribute("height");
                var expandedWidth = variationNode.getAttribute("expandedWidth");
                var expandedHeight = variationNode.getAttribute("expandedHeight");
                var scalable = variationNode.getAttribute("scalable");
                var maintainAspectRatio = variationNode.getAttribute("maintainAspectRatio");
                var minSuggestedDuration = variationNode.getAttribute("minSuggestedDuration");
                var apiFramework = variationNode.getAttribute("apiFramework");

                var clickThrough = getSingleNodeValue(variationNode.getElementsByTagName("NonLinearClickThrough"));

                var clickTrackingNodes = variationNode.getElementsByTagName("NonLinearClickTracking");
                var clickTrackingUrls = getMultipleNodeValues(clickTrackingNodes);
                var clickTrackers = parseClickTrackingNodes(clickTrackingNodes);
                if (context.nonLinearCreativeClicksTemp) {
                    for (var r = 0; r < context.nonLinearCreativeClicksTemp.length; r++) {
                        var trackerUrl = context.nonLinearCreativeClicksTemp[r].url;
                        var trackerID = context.nonLinearCreativeClicksTemp[r].id;
                        clickTrackers.push(new adfw.ClickTracker(trackerID, trackerUrl));
                    }
                }
                //Each NonLinearClickTracking has a "id", unfortunately we throw this info away

                var adParameters = getSingleNodeValue(variationNode.getElementsByTagName("AdParameters"));

                var resources = [];
                var resourceNode = null;
                var creativeType = null;
                var resource = null;
                var n = null;

                var staticResourceNodes = variationNode.getElementsByTagName("StaticResource");
                //staticResource has a creativeType attribute, image/gif, image/jpeg, image/png, application/x-javascript, application/x-shockwave-flash
                if (staticResourceNodes && staticResourceNodes.length) {
                    for (n = 0; n < staticResourceNodes.length; n++) {
                        resourceNode = staticResourceNodes[n];
                        creativeType = resourceNode.getAttribute("creativeType");

                        var resourceValue = getSingleNodeValue(resourceNode);
                        var inferredCreativeType = null;

                        if (!creativeType) {
                            sendVSuiteParseError(101, context, "No CreativeType provided for NonLinear StaticResource");
                            continue;
                        } else if (adfw.Utils.isGIFMIME(creativeType) ||
                                   adfw.Utils.isJPEGMIME(creativeType) ||
                                   adfw.Utils.isPNGMIME(creativeType)) {
                            inferredCreativeType = adfw.NonLinearResource.ResourceType.STATIC_IMAGE;
                        } else if (adfw.Utils.isJSMIME(creativeType)) {
                            inferredCreativeType = adfw.NonLinearResource.ResourceType.STATIC_JS;
                        } else if (adfw.Utils.isFlashMIME(creativeType)) {
                            inferredCreativeType = adfw.NonLinearResource.ResourceType.STATIC_FLASH;
                        }

                        if (resourceValue && inferredCreativeType) {
                            resource = new adfw.NonLinearResource({
                                resource: resourceValue,
                                type: inferredCreativeType
                            });
                            resources.push(resource);
                        } else {
                            sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad StaticResource: missing resource(" + resourceValue + ") or creative type(" + inferredCreativeType + ")");
                        }
                    }
                }

                var iframeResourceNodes = variationNode.getElementsByTagName("IFrameResource");
                if (iframeResourceNodes) {
                    for (n = 0; n < iframeResourceNodes.length; n++) {
                        resourceNode = iframeResourceNodes[n];
                        var resourceValue = getSingleNodeValue(resourceNode);
                        if (resourceValue) {
                            resource = new adfw.NonLinearResource({
                                resource: resourceValue,
                                type: adfw.NonLinearResource.ResourceType.IFRAME
                            });
                            resources.push(resource);
                        } else {
                            sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad: missing resource value inside IFrameResource");
                        }
                    }
                }

                var htmlResourceNodes = variationNode.getElementsByTagName("HTMLResource");
                if (htmlResourceNodes) {
                    for (n = 0; n < htmlResourceNodes.length; n++) {
                        resourceNode = htmlResourceNodes[n];
                        var resourceValue = getSingleNodeValue(resourceNode);
                        if (resourceValue) {
                            resource = new adfw.NonLinearResource({
                                resource: resourceValue,
                                type: adfw.NonLinearResource.ResourceType.HTML
                            });
                            resources.push(resource);
                        } else {
                            sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad: missing resource value inside HTMLResource");
                        }
                    }
                }

                if (!width || !height) {
                    sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad: missing width/height");
                } else if (resources.length <= 0) {
                    sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad: no valid resources found");
                } else {
                    var nonLinearVariation = new adfw.NonLinearVariation({
                        id: id,
                        width: width,
                        height: height,
                        expandedWidth: expandedWidth,
                        expandedHeight: expandedHeight,
                        scalable: scalable,
                        maintainAspectRatio: maintainAspectRatio,
                        minSuggestedDuration: minSuggestedDuration,
                        apiFramework: apiFramework,
                        clickThrough: clickThrough,
                        clickTrackers: clickTrackers,
                        adParameters: adParameters,
                        resources: resources
                    });
                    variations.push(nonLinearVariation);
                }
            }

            if (variations.length <= 0) {
                sendVSuiteParseError(101, context, "Unable to parse Nonlinear ad: no valid NonLinear nodes found");
            } else {
                creativeObject = new adfw.NonLinearCreative({
                    //General Creative stuff
                    id: creativeID,
                    sequence: creativeSequence,
                    adID: creativeAdID,
                    apiFramework: creativeAPIFramework,
                    eventTrackers: eventTrackers,
                    //Variables specific to NonLinears
                    variations: variations,
                });
            }
        }
        if (companionNodes.length > 0) {
            creativeObject = companionParser.companionNodesToCompanionCreative(creativeNode, companionNodes);
        }
        return creativeObject;
    };

    var companionParser = {
        //Main companion Parser.
        //Input: companionNodes
        //Output: companionCreativeObjects creativeObject
        companionNodesToCompanionCreative: function (creativeNode, companionNodes) {

            var companionNodeArray = Array.prototype.slice.call(companionNodes),
                companionObjects = [],
                creativeObject = [],
                resourcesList = [];

            //Loop Thru companion
            for (var i = 0; i < companionNodeArray.length; i++) {
                var node = companionNodeArray[i];
                //Parsing CompansionResource
                resourcesList = companionParser.companionNodeToResourceObjects(node);

                if (!resourcesList || !resourcesList.length) {
                    sendVSuiteParseError(603, {}, "Unable to fetch CompanionAds/Companion resource.");
                    return null;
                }

                var altTextNode = node.getElementsByTagName("AltText")[0] ? node.getElementsByTagName("AltText")[0] : '',
                    trackingEventsNode = node.getElementsByTagName("TrackingEvents")[0] ? node.getElementsByTagName("TrackingEvents")[0] : null,
                    adParametersNode = node.getElementsByTagName("AdParameters")[0] ? node.getElementsByTagName("AdParameters")[0] : null;

                //Parse TrackingEvents
                var eventTrackerList = [],
                    trackingNodes = trackingEventsNode ? trackingEventsNode.getElementsByTagName("Tracking") : null;
                if (trackingNodes && trackingNodes.length > 0) {
                    for (var j = 0; j < trackingNodes.length; j++) {
                        var trackingNode = trackingNodes[j];
                        var event = trackingNode.getAttribute("event");
                        var url = getSingleNodeValue(trackingNode);
                        if (event && url) {
                            eventTrackerList.push(new adfw.OneTimeTracker(event, url));
                        }
                    }
                } else {
                    log("No Tracker nodes detected in VAST Companion...");
                }

                companionObjects.push(new adfw.Companion({
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height"),
                    id: node.getAttribute("id") ? node.getAttribute("id") : null,
                    assetWidth: node.getAttribute("assetWidth") ? node.getAttribute("assetWidth") : null,
                    assetHeight: node.getAttribute("assetHeight") ? node.getAttribute("assetHeight") : null,
                    expandedWidth: node.getAttribute("expandedWidth") ? node.getAttribute("expandedWidth") : null,
                    expandedHeight: node.getAttribute("expandedHeight") ? node.getAttribute("expandedHeight") : null,
                    adSlotID: node.getAttribute("adSlotID") ? node.getAttribute("adSlotID") : null,

                    resources: resourcesList,
                    altText: getSingleNodeValue(altTextNode),
                    eventTrackers: eventTrackerList,
                    apiFramework: node.getAttribute("apiFramework"),
                    adParameters: node.getAttribute("adParameters"),
                }));

            }

            var creativeID = creativeNode.getAttribute("id"),
                creativeSequence = creativeNode.getAttribute("sequence"),
                creativeAdID = creativeNode.getAttribute("adID"),
                creativeAPIFramework = creativeNode.getAttribute("apiFramework"),
                required = creativeNode.getElementsByTagName("CompanionAds")[0].getAttribute("required");

            creativeObject = new adfw.CompanionCreative({
                //General Creative stuff
                id: creativeID,
                sequence: creativeSequence,
                adID: creativeAdID,
                apiFramework: creativeAPIFramework,
                //Variables specific to Companion
                companions: companionObjects,
                required: required ? required : null,

            });

            return creativeObject;
        },
        //Parse Companion Resources.
        //Input: companionNode
        //Output: companionResourceObjects Array
        companionNodeToResourceObjects: function (companionNode) {
            var companionResourceObjects = [];
            //Parsing Resource
            //Companion Resource Elements - at least one [staticResource,IFrameResource,HTMLResource].
            var staticResource = companionNode.getElementsByTagName("StaticResource")[0],
                iFrameResource = companionNode.getElementsByTagName("IFrameResource")[0],
                htmlResource = companionNode.getElementsByTagName("HTMLResource")[0],
                companionClickThroughNode = companionNode.getElementsByTagName("CompanionClickThrough")[0],
                companionClickTrackingNode = companionNode.getElementsByTagName("CompanionClickTracking");

            if (staticResource) {
                var content = getSingleNodeValue(staticResource),
                    category = "STATIC",
                    creativeType = staticResource.getAttribute("creativeType"),
                    clickThrough = getSingleNodeValue(companionClickThroughNode),
                    clickTrackers = parseClickTrackingNodes(companionClickTrackingNode);

                companionResourceObjects.push(companionParser.companionResourceConverter(content, category, creativeType, clickThrough, clickTrackers));
            }
            if (iFrameResource) {
                var content = getSingleNodeValue(iFrameResource),
                    category = "IFRAME";

                companionResourceObjects.push(companionParser.companionResourceConverter(content, category));
            }
            if (htmlResource) {
                var content = getSingleNodeValue(htmlResource),
                    category = "HTML";

                companionResourceObjects.push(companionParser.companionResourceConverter(content, category));
            }
            return companionResourceObjects;
        },
        //Create CompanionResources Object.
        //Input: (content, category, creativeType, clickThrough, clickTrackers)
        //Output: companionResourceObjects
        companionResourceConverter: function (content, category, creativeType, clickThrough, clickTrackers) {
            return (new adfw.CompanionResource({
                content: content,
                resourceCategory: category,
                creativeType: creativeType || null,
                clickThrough: clickThrough || null,
                clickTrackers: clickTrackers || null
            }));
        }
    };

    var iconParser = {
        //Parse Icon.
        //Input: IconNode
        //Output: IconObjects Array
        iconNodeToIconObjects: function (iconNode, depth) {

            if (typeof depth !== 'number') {
                depth = 0;
            }
            var duration = adfw.Utils.convertHMS(iconNode.getAttribute("duration"));
            var offset = adfw.Utils.convertHMS(iconNode.getAttribute("offset"));

            var resourcesList = iconParser.iconNodeToResourceObjects(iconNode);
            return (new adfw.Icon({
                program: iconNode.getAttribute("program"),
                width: iconNode.getAttribute("width"),
                height: iconNode.getAttribute("height"),
                xPosition: iconNode.getAttribute("xPosition"),
                yPosition: iconNode.getAttribute("yPosition"),
                offset: offset,
                duration: duration,
                resources: resourcesList,
                apiFramework: iconNode.getAttribute("apiFramework"),
                depth: depth
            }));
        },
        //Parse Icon Resources.
        //Input: IconNode
        //Output: IconResourceObjects Array
        iconNodeToResourceObjects: function (iconNode) {
            var iconResourceObjects = [];
            //Parsing Resource
            //Icon Resource Elements - at least one [StaticResource,IFrameResource,HTMLResource].
            var staticResource = iconNode.getElementsByTagName("StaticResource")[0],
                iFrameResource = iconNode.getElementsByTagName("IFrameResource")[0],
                htmlResource = iconNode.getElementsByTagName("HTMLResource")[0],
                iconClickThroughNode = iconNode.getElementsByTagName("IconClickThrough")[0],
                iconClickTrackingNode = iconNode.getElementsByTagName("IconClickTracking"),
                iconViewTrackingNode = iconNode.getElementsByTagName("IconViewTracking"),
                viewTrackers = parseClickTrackingNodes(iconViewTrackingNode);

            if (staticResource) {
                var content = getSingleNodeValue(staticResource),
                    category = "STATIC",
                    creativeType = staticResource.getAttribute("creativeType"),
                    clickThrough = getSingleNodeValue(iconClickThroughNode),
                    clickTrackers = parseClickTrackingNodes(iconClickTrackingNode);

                iconResourceObjects.push(iconParser.iconResourceConverter(content, category, creativeType, clickThrough, clickTrackers, viewTrackers));
            }
            if (iFrameResource) {
                var content = getSingleNodeValue(iFrameResource),
                    category = "IFRAME";

                iconResourceObjects.push(iconParser.iconResourceConverter(content, category, null, null, null, viewTrackers));
            }
            if (htmlResource) {
                var content = getSingleNodeValue(htmlResource),
                    category = "HTML";

                iconResourceObjects.push(iconParser.iconResourceConverter(content, category, null, null, null, viewTrackers));
            }

            return iconResourceObjects;
        },
        //Create IconResources Object.
        //Input: (content, category, creativeType, clickThrough, clickTrackers, viewTrackers)
        //Output: IconResourceObjects
        iconResourceConverter: function (content, category, creativeType, clickThrough, clickTrackers, viewTrackers) {
            return (new adfw.IconResource({
                content: content,
                resourceCategory: category,
                creativeType: creativeType || null,
                clickThrough: clickThrough || null,
                clickTrackers: clickTrackers || null,
                viewTrackers: viewTrackers || null
            }));
        }
    };

    //Convert a list of XML nodes into Error trackers
    var parseErrorNodes = function (errorNodes) {
        var errorTrackers = [];
        if (!errorNodes || !errorNodes.length) {
            return errorTrackers;
        }
        for (var i = 0; i < errorNodes.length; i++) {
            var url = getSingleNodeValue(errorNodes[i]);
            if (url) {
                errorTrackers.push(new adfw.ErrorTracker(url));
            }
        }

        return errorTrackers;
    };

    //Convert a list of XML nodes into Impression trackers
    var parseImpressionNodes = function (impressionNodes) {
        var impressionTrackers = [];
        if (!impressionNodes || !impressionNodes.length) {
            return impressionTrackers;
        }
        for (var i = 0; i < impressionNodes.length; i++) {
            var url = getSingleNodeValue(impressionNodes[i]);
            if (url) {
                impressionTrackers.push(new adfw.OneTimeTracker("impression", url));
            }
        }

        return impressionTrackers;
    };

    //Parse Trackers from a list of click tracking nodes. Returns a list of adfw.Tracker objects.
    var parseClickTrackingNodes = function (clickTrackingNodes) {
        var trackers = [];

        for (var i = 0; i < clickTrackingNodes.length; i++) {
            if (clickTrackingNodes[i].getAttribute("id") && clickTrackingNodes[i].textContent) {
                trackers.push(new adfw.ClickTracker(clickTrackingNodes[i].getAttribute("id"), clickTrackingNodes[i].textContent));
            }
        }

        return trackers;
    };

    //Parse Trackers from a list of event tracking nodes. Returns a list of adfw.Tracker objects.
    //USAGE: var trackingNodes = parseTrackers(linearNode.getElementsByTagName("Tracking"));
    var parseTrackerNodes = function (trackingNodes) {

        var trackers = [];
        for (var i = 0, len = trackingNodes.length; i < len; i++) {
            if (trackingNodes[i].getAttribute("event")) {
                var trackerID = trackingNodes[i].getAttribute("event");
                var trackerUrl = getSingleNodeValue(trackingNodes[i]);
                if (trackerID && trackerUrl) {
                    if (firstQuartileRegex.test(trackerID)) {
                        trackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "25%"));
                    } else if (midpointRegex.test(trackerID)) {
                        trackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "50%"));
                    } else if (thirdQuartileRegex.test(trackerID)) {
                        trackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, "75%"));
                    } else if (progressRegex.test(trackerID)) {
                        trackers.push(new adfw.OffsetTracker(trackerID, trackerUrl, trackingNodes[i].getAttribute("offset")));
                    } else {
                        if (startRegex.test(trackerID) || creativeViewRegex.test(trackerID) || completeRegex.test(trackerID) || skipRegex.test(trackerID)) {
                            trackers.push(new adfw.OneTimeTracker(trackerID, trackerUrl));
                        } else {
                            trackers.push(new adfw.Tracker(trackerID, trackerUrl));
                        }
                    }
                }
            }
        }
        return trackers;
    };

    //VAST Parsing Context - refreshes the Context that reflects the state of parsing.
    //This function is used to duplicate the context in between levels of parsing so that they don't affect each other
    var getNewContext = function (oldContext) {
        if (!oldContext) {
            oldContext = {};
        }
        if (!oldContext.timestamp) {
            oldContext.timestamp = new Date();
        }
        if (typeof oldContext.adParseErrorUrls === 'undefined') {
            oldContext.adParseErrorUrls = [];
        } //Urls to call if VAST parse errors occur
        if (+oldContext.depth !== oldContext.depth) { //not NUMBER
            oldContext.depth = 1;
        } //Depth of wrapper ad parsing
        if (typeof oldContext.impressionUrls === 'undefined') {
            oldContext.impressionUrls = [];
        } //List of Ad Impression Urls from wrappers
        if (typeof oldContext.errorUrls === 'undefined') {
            oldContext.errorUrls = [];
        } //List of Ad Error Urls from wrappers. Not the same as parsing error Urls
        if (typeof oldContext.linearCreativeTrackerTemp === 'undefined') {
            oldContext.linearCreativeTrackerTemp = [];
        } //List of Linear Creative trackers from wrapper ads { id:id, url:url }
        if (typeof oldContext.linearCreativeClicksTemp === 'undefined') {
            oldContext.linearCreativeClicksTemp = [];
        } //List of Linear Creative click trackers from wrapper ads { id:id, url:url }
        if (typeof oldContext.linearCreativeIconsTemp === 'undefined') {
            oldContext.linearCreativeIconsTemp = [];
        } //List of Linear Creative Icons from wrapper ads { iconNodeString:string, depth:number }
        if (typeof oldContext.nonLinearCreativeTrackerTemp === 'undefined') {
            oldContext.nonLinearCreativeTrackerTemp = [];
        } //List of NonLinear Creative trackers from wrapper ads { id:id, url:url }
        if (typeof oldContext.nonLinearCreativeClicksTemp === 'undefined') {
            oldContext.nonLinearCreativeClicksTemp = [];
        } //List of NonLinear Creative click trackers from wrapper ads { id:id, url:url }
        if (typeof oldContext.companionCreativeNode === 'undefined') {
            oldContext.companionCreativeNode = [];
        } //Store companionCreativeNode XML for later to parse
        if (typeof oldContext.followAdditionalWrappers === 'undefined') {
            oldContext.followAdditionalWrappers = true;
        } //Whether or not to follow additional wrappers
        if (typeof oldContext.allowMultipleAds === 'undefined') {
            oldContext.allowMultipleAds = true;
        } //Whether or not to allow multiple ads incoming from additional wrappers. If not, take the first Standalone ad.
        if (typeof oldContext.followRedirects === 'undefined') {
            oldContext.followRedirects = true;
        } //Whether or not to follow redirects
        if (typeof oldContext.globalVMAPExtensions === 'undefined') {
            oldContext.globalVMAPExtensions = [];
        } //Global VMAP extensions
        if (typeof oldContext.vastExtensions === 'undefined') {
            oldContext.vastExtensions = [];
        } //Global VMAP extensions

        var newContext = copy(oldContext);
        newContext.timestamp = new Date(newContext.timestamp);
        return newContext;
    };

    //How long do we have until we have to stop parsing?
    var getRetrievalTimeRemaining = function (context) {
        if (!context.timestamp) {
            context.timestamp = new Date();
        }
        var remaining = adfw.Config.get("AD_RETRIEVAL_TIMEOUT") - (new Date() - context.timestamp);
        if (remaining < 300) {
            remaining = 0;
        } else {
            remaining -= (75 * context.depth);
        }
        return remaining;
    };

    //Deep-clone something. Allows scope management.
    var copy = function (item) {
        if (item) {
            try {
                return JSON.parse(JSON.stringify(item));
            }
            catch (e) {
                error("Cannot stringify JSON: pre-Tizen error suspected");
                return item;
            }
        } else {
            return null;
        }
    };

    //After parsing VAST and wrappers, merges all of the ads together. The structure of the argument is a special one created during VAST parsing.
    //The structure is of nested maps. It's really ugly. Sorry.
    var deepMerge = function (adStructure) {
        var merged = deepMergeHelper(adStructure);
        return merged.sequenced.concat(merged.unsequenced);
    };
    var deepMergeHelper = function (adStructure, currentSequence, inferSequence, inferences) {
        var sequenced = [];
        var unsequenced = [];
        var ad = null;
        if (!inferences) {
            inferences = {};
        }
        if (!currentSequence) {
            currentSequence = 1;
        }

        for (var i = 0; i < adStructure.length; i++) {
            ad = adStructure[i];
            if (ad instanceof adfw.Ad) {
                if (inferences.id) {
                    ad.id = inferences.id;
                }
                if (ad.sequence || inferSequence) {
                    ad.sequence = currentSequence;
                    currentSequence++;
                    sequenced.push(ad);
                } else {
                    ad.sequence = null;
                    unsequenced.push(ad);
                }
            } else {
                if (ad.id) {
                    inferences.id = ad.id;
                }
                var deeperInference = inferSequence || ad.sequence;
                var deeper = deepMergeHelper(ad.ads, currentSequence, deeperInference, inferences);
                sequenced = sequenced.concat(deeper.sequenced);
                unsequenced = unsequenced.concat(deeper.unsequenced);
                currentSequence = deeper.currentSequence;
            }
        }
        ;

        return {
            sequenced: sequenced,
            unsequenced: unsequenced,
            currentSequence: currentSequence
        };
    };

    //Makes a NodeList into a regular List. Useful to avoid the limitations of NodeList.
    var makeList = function (nodeList) {
        var arr = [];
        for (var i = 0; i < nodeList.length; i++) {
            arr.push(nodeList[i]);
        }
        return arr;
    };

    var isXML = function (xml) {
        if (!xml || !((xml.documentElement && xml.documentElement.tagName) || xml.tagName)) {
            return false;
        }
        return true;
    };

    //Checks if a particular XML document is VMAP.
    var isVMAP = function (xml) {
        if (!isXML(xml)) {
            return false;
        }
        var rootName;
        if (xml.documentElement) {
            rootName = xml.documentElement.tagName.toLowerCase();
            if (rootName.indexOf("vmap") >= 0) {
                return true;
            }
        }
        else if (xml.tagName) {
            rootName = xml.tagName.toLowerCase();
            if (rootName.indexOf("vmap") >= 0) {
                return true;
            }
        }

        return false;
    };

    //Checks if a particular XML document is VAST.
    var isVAST = function (xml) {
        if (!isXML(xml)) {
            return false;
        }
        var rootName;

        if (xml.documentElement) {
            rootName = xml.documentElement.tagName.toLowerCase();
            if (rootName.indexOf("vast") >= 0) {
                return true;
            }
        }
        else if (xml.tagName) {
            rootName = xml.tagName.toLowerCase();
            if (rootName.indexOf("vast") >= 0) {
                return true;
            }
        }

        return false;
    };

    //Sends a VAST parsing error to all of the parsing error Urls in the current context.
    var sendVSuiteParseError = function (code, context, message) {
        var eMessage = message ? message : adfw.Errors[code];
        error(code + " | " + eMessage);
        adfw.Events.dispatchEvent(adfw.Events.PARSING_ERROR, {
            message: eMessage,
            code: code
        });
        if (context.adParseErrorUrls) {
            for (var i = 0; i < context.adParseErrorUrls.length; i++) {
                var url = context.adParseErrorUrls[i];
                url = adfw.MacroHelper.replaceErrorMacros(url, code, eMessage);
                adfw.Utils.fireTrackerUrl(url);
            }
        }
    };

    //Given a node as the first parameter, return a NodeList of elements matching the given tagName. Will only find nodes with the VMAP namespace.
    var getVMAPNode = function (givenNode, tagName) {
        var temp = givenNode.getElementsByTagNameNS("http://www.iab.net/videosuite/vmap", tagName);
        if (!temp || !temp.length) {
            //Tries to use an alternative NS (a muckup in the IAB's VMAP 1.0 spec caused confusion)
            temp = givenNode.getElementsByTagNameNS("http://www.iab.net/vmap-1.0", tagName);
        }
        if (temp.length) {
            return temp;
        }
        else {
            return [];
        }
    };

    //Magical XML node value getter for the lazy - gets you the textContent of the first node in a list of nodes (or single node) that you provide. Good if you know you've only got one node to care about.
    var getSingleNodeValue = function (xmlNodes) {
        var val = null;
        try {
            if (!xmlNodes) {
                return val;
            }
            if (typeof xmlNodes === "string") {
                return xmlNodes;
            }
            if (xmlNodes && xmlNodes.length) {
                val = xmlNodes[0].textContent.trim();
            } else if (xmlNodes.textContent || xmlNodes.childNodes) {
                if (xmlNodes && xmlNodes.childNodes && xmlNodes.childNodes[0] && xmlNodes.childNodes[0].textContent.trim()) {
                    val = xmlNodes.childNodes[0].textContent.trim();
                } else if (xmlNodes && xmlNodes.textContent.trim()) {
                    val = xmlNodes.textContent.trim();
                }
            }
        }
        catch (e) {
            error("getSingleNodeValue on " + xmlNodes + ": " + e);
        }

        return val;
    };

    //Magical XML node value getter for the lazy - gets you the textContents of all the nodes you provide, as a list.
    var getMultipleNodeValues = function (xmlNodes) {
        var valueList = [];

        if (xmlNodes && xmlNodes.length) {
            for (var i = 0; i < xmlNodes.length; i++) {
                valueList.push(getSingleNodeValue(xmlNodes[i]));
            }
        } else if (xmlNodes.textContent || xmlNodes.childNodes) {
            if (xmlNodes && xmlNodes.childNodes && xmlNodes.childNodes[0] && xmlNodes.childNodes[0].textContent.trim()) {
                valueList.push(xmlNodes.childNodes[0].textContent.trim());
            } else if (xmlNodes && xmlNodes.textContent.trim()) {
                valueList.push(xmlNodes.textContent.trim());
            }
        }
        return valueList;
    };

    return {
        parse: parse,
        parseVASTXMLAsync: parseVASTXMLAsync,
        parseVMAPXMLAsync: parseVMAPXMLAsync,
        parseVMAPAdBreakNodeAsync: parseVMAPAdBreakNodeAsync
    };
}
               ()
              )
;

//The PlaybackState holds all of the state variables for the Ad Framework. Uses a jQuery style getter/setter API.

adfw.PlaybackState = (function () {
    "use strict";

    var Obj = function () {
        this.initializeState();
    };

    //This is an enum.
    Obj.PlaybackType = {
        STOPPED: "STOPPED",
        CONTENT: "CONTENT",
        LINEAR_AD: "LINEAR_AD",
        INTERACTIVE_AD: "INTERACTIVE_AD"
    };

    Obj.prototype.resetModifierFunctions = function () {
        this._beforeContentStartFunction = null;
        this._beforeLinearAdStartFunction = null;
        this._afterContentStartFunction = null;
        this._afterLinearAdStartFunction = null;
        this._linearAdUrlModifierFunction = null;
    };

    //Resets the state
    Obj.prototype.initializeState = function () {

        //this.log("Initializing PlaybackState...");

        this._currentPlayhead = null;
        this._currentVideoUrl = null;

        this._contentBitrate = null;
        this._currentAdPlayhead = null;
        this._currentAdBreak = null;
        this._currentResolvingAdBreak = null;
        this._currentBufferedLinearAdBreak = null;
        this._currentNonLinearAdBreak = null;
        this._currentLinearAd = null;
        this._currentBufferedLinearAd = null;
        this._currentLinearCreative = null;
        this._currentNonLinearAd = null;
        this._currentPreloadedNonLinearVPAIDAd = null;
        this._currentContentPlayhead = null;
        this._currentContentVideoUrl = null;

        this._currentPlaybackType = adfw.PlaybackState.PlaybackType.STOPPED;

        this._hasHaltedForVPAID = false;
        this._isMuted = false;
        this._isLinearAdMode = false;

        this._ignoreActivePlayerProblems = false;

        this._isTrickPlaying = false;

        if (this._linearAdTimeout) {
            clearTimeout(this._linearAdTimeout);
        }
        this._linearAdTimeout = null;

        this._linearAdHasRecentlyTimedOut = false;
        if (this._linearAdTimeoutTimer) {
            clearTimeout(this._linearAdTimeoutTimer);
        }
        this._linearAdTimeoutTimer = null;

        this._retryCount = 0;
        if (this._retryAggroTimer) {
            clearTimeout(this._retryAggroTimer);
        }
        this._retryAggroTimer = null;
    };

    //Signals the state that the controller tried to restart the content video after a playback failure.
    //This function increments the retry count each time it is called. After 60 seconds of no further retries, the count resets.
    Obj.prototype.triedToRestartVideo = function () {

        if (!this._retryHelper) {
            var retryHelper = function () {
                this._retryCount = 0;
                this._retryAggroTimer = null;
            };
            this._retryHelper = adfw.Utils.bind(retryHelper, this);
        }

        var self = this;
        this._retryCount++;
        if (this._retryAggroTimer) {
            clearTimeout(this._retryAggroTimer);
        }
        this._retryAggroTimer = setTimeout(this._retryHelper, 10000);
    };

    Obj.prototype.canRetryPlayback = function () {
        if (this._retryCount >= adfw.Config.get("PLAYBACK_FAILURE_RETRY_COUNT")) {
            return false;
        } else {
            return true;
        }
    };

    Obj.prototype.linearAdHasRecentlyTimedOut = function (truth) {

        if (!this._linearAdTimeoutHelper) {
            var linearAdTimeoutHelper = function () {
                this._linearAdHasRecentlyTimedOut = false;
                if (this._linearAdTimeoutTimer) {
                    clearTimeout(this._linearAdTimeoutTimer);
                }
                this._linearAdTimeoutTimer = null;
            };
            this._linearAdTimeoutHelper = adfw.Utils.bind(linearAdTimeoutHelper, this);
        }

        if (truth === true) {
            this._linearAdTimeoutHelper();
            this._linearAdHasRecentlyTimedOut = true;
            this._linearAdTimeoutTimer = setTimeout(this._linearAdTimeoutHelper, 60000);
        } else if (truth === false) {
            this._linearAdTimeoutHelper();
        } else {
            return this._linearAdHasRecentlyTimedOut;
        }

    };

    //Sets several variables that assist in content playback
    Obj.prototype.switchToContentMode = function () {
        this._isLinearAdMode = false;
        this.hasHaltedForVPAID(false);
        this.currentPlayhead(null); //Milliseconds we are into the current video (ad or content)
        this.currentAdPlayhead(null); //Milliseconds we are into the current ad
        this.currentLinearAd(null);
        this.currentBufferedLinearAd(null);
        this.currentBufferedLinearAdBreak(null);
        this.currentLinearCreative(null);
        this.currentAdBreak(null);
        this.currentPlaybackType(adfw.PlaybackState.PlaybackType.CONTENT);

        if (this.linearAdTimeout()) {
            clearTimeout(this.linearAdTimeout());
        }
        this.linearAdTimeout(null);
    };

    //Sets several variables that assist in linear ad playback
    Obj.prototype.switchToLinearAdMode = function (ad, linearCreative) {
        this._isLinearAdMode = true;
        this.currentPlayhead(null); //Milliseconds we are into the current video (ad or content)
        this.currentLinearAd(ad);
        this.currentLinearCreative(linearCreative);
        this.currentPlaybackType(adfw.PlaybackState.PlaybackType.LINEAR_AD);
    };

    //Is the framework in linear ad mode?
    Obj.prototype.isLinearAdMode = function () {
        return this._isLinearAdMode;
    };

    //Is the content currently trickplaying?
    Obj.prototype.isTrickPlaying = function (truth) {
        if (typeof truth !== "undefined") {
            this._isTrickPlaying = truth;
        } else {
            return this._isTrickPlaying;
        }
    };

    //Is the framework audio muted?
    Obj.prototype.isMuted = function (truth) {
        if (typeof truth !== "undefined") {
            this._isMuted = truth;
        } else {
            return this._isMuted;
        }
    };

    //Have we stopped due to a VPAID Linear ad playing?
    Obj.prototype.hasHaltedForVPAID = function (truth) {
        if (typeof truth !== "undefined") {
            this._hasHaltedForVPAID = truth;
        } else {
            return this._hasHaltedForVPAID;
        }
    };

    //This is for ignoring Active player problems for the time being. This is useful if we want to prevent overreacting to multiple render errors thrown from a single failure.
    Obj.prototype.ignoreActivePlayerProblems = function (truth) {
        if (typeof truth !== "undefined") {
            this._ignoreActivePlayerProblems = truth;
        } else {
            return this._ignoreActivePlayerProblems;
        }
    };

    //Record the content bitrate before starting an ad break (for resumption purposes)
    Obj.prototype.contentBitrate = function (bitrate) {
        if (typeof bitrate !== "undefined") {
            this._contentBitrate = bitrate;
        } else {
            return this._contentBitrate;
        }
    };

    //Sets a function to execute before starting/resuming content. Useful for DRM purposes
    Obj.prototype.beforeContentStart = function (func) {
        if (typeof func !== "undefined") {
            this._beforeContentStartFunction = func;
        } else {
            return this._beforeContentStartFunction;
        }
    };

    //Sets a function to execute before starting linear ad playback. Useful for DRM purposes
    Obj.prototype.beforeLinearAdStart = function (func) {
        if (typeof func !== "undefined") {
            this._beforeLinearAdStartFunction = func;
        } else {
            return this._beforeLinearAdStartFunction;
        }
    };

    //Sets a function to execute before starting/resuming content. Useful for DRM purposes
    Obj.prototype.afterContentStart = function (func) {
        if (typeof func !== "undefined") {
            this._afterContentStartFunction = func;
        } else {
            return this._afterContentStartFunction;
        }
    };

    //Sets a function to execute before starting linear ad playback. Useful for DRM purposes
    Obj.prototype.afterLinearAdStart = function (func) {
        if (typeof func !== "undefined") {
            this._afterLinearAdStartFunction = func;
        } else {
            return this._afterLinearAdStartFunction;
        }
    };

    //Sets a function to execute that is allowed to influence the linear ad Url by giving a String return value. Useful for login/token purposes
    Obj.prototype.linearAdUrlModifier = function (func) {
        if (typeof func !== "undefined") {
            this._linearAdUrlModifierFunction = func;
        } else {
            return this._linearAdUrlModifierFunction;
        }
    };

    //A timeout that the controller uses in order to detect failures to load linear ads
    Obj.prototype.linearAdTimeout = function (timeout) {
        if (typeof timeout !== "undefined") {
            this._linearAdTimeout = timeout;
        } else {
            return this._linearAdTimeout;
        }
    };

    //Url of the current video (content or linear ad)
    Obj.prototype.currentVideoUrl = function (newUrl) {
        if (typeof newUrl !== "undefined") {
            this._currentVideoUrl = newUrl;
        } else {
            return this._currentVideoUrl;
        }
    };

    //Url of the current video (content)
    Obj.prototype.currentContentVideoUrl = function (newUrl) {
        if (typeof newUrl !== "undefined") {
            this._currentContentVideoUrl = newUrl;
            //this.log("Change current content video Url: " + newUrl);
        } else {
            return this._currentContentVideoUrl;
        }
    };

    //What is the state of video playback in the ad framework?
    Obj.prototype.currentPlaybackType = function (newType) {
        if (typeof newType !== "undefined") {
            this._currentPlaybackType = newType;
        } else {
            return this._currentPlaybackType;
        }
    };

    //Playhead of the current video (content or linear ad)
    Obj.prototype.currentPlayhead = function (newPlayhead) {
        if (typeof newPlayhead !== "undefined") {
            this._currentPlayhead = newPlayhead;
        } else {
            return this._currentPlayhead;
        }
    };

    //Playhead of the current content video.
    Obj.prototype.currentContentPlayhead = function (newPlayhead) {
        if (typeof newPlayhead !== "undefined") {
            this._currentContentPlayhead = newPlayhead;
        } else {
            return this._currentContentPlayhead;
        }
    };

    //Playhead of the current linear ad.
    Obj.prototype.currentAdPlayhead = function (newPlayhead) {
        if (typeof newPlayhead !== "undefined") {
            this._currentAdPlayhead = newPlayhead;
        } else {
            return this._currentAdPlayhead;
        }
    };

    //Current ad break that is occurring.
    Obj.prototype.currentAdBreak = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentAdBreak = newObject;
        } else {
            return this._currentAdBreak;
        }
    };

    //Current ad break that is resolving (but not yet playing).
    Obj.prototype.currentResolvingAdBreak = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentResolvingAdBreak = newObject;
        } else {
            return this._currentResolvingAdBreak;
        }
    };

    //Current linear ad break that is being buffered.
    Obj.prototype.currentBufferedLinearAdBreak = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentBufferedLinearAdBreak = newObject;
        } else {
            return this._currentBufferedLinearAdBreak;
        }
    };

    //Current nonlinear ad break that is scheduled for display at next opportunity.
    Obj.prototype.currentNonLinearAdBreak = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentNonLinearAdBreak = newObject;
        } else {
            return this._currentNonLinearAdBreak;
        }
    };

    //Current linear ad that is playing
    Obj.prototype.currentLinearAd = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentLinearAd = newObject;
        } else {
            return this._currentLinearAd;
        }
    };

    //Current linear ad that is playing
    Obj.prototype.currentBufferedLinearAd = function (newObject) {

        if (typeof newObject !== "undefined") {
            this._currentBufferedLinearAd = newObject;
        } else {
            return this._currentBufferedLinearAd;
        }
    };

    //Current linear creative that is playing
    Obj.prototype.currentLinearCreative = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentLinearCreative = newObject;
        } else {
            return this._currentLinearCreative;
        }
    };

    //An ad with a nonlinear, scheduled to play at the next opportunity.
    Obj.prototype.currentNonLinearAd = function (newObject) {
        if (typeof newObject !== "undefined") {
            this._currentNonLinearAd = newObject;
        } else {
            return this._currentNonLinearAd;
        }
    };


    //Current Non linear VPaid ad that is loaded
    Obj.prototype.currentPreloadedNonLinearVPAIDAd = function (newObject) {

        if (typeof newObject !== "undefined") {
            this._currentPreloadedNonLinearVPAIDAd = newObject;
        } else {
            return this._currentPreloadedNonLinearVPAIDAd;
        }
    };

    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW STATE]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW STATE]");
    }

    return Obj;
}());

//The Schedule maintains a list of prerolls/midrolls/postrolls and the logic to insert/manage them.

adfw.Schedule = (function () {
    "use strict";

    var Obj = function (playbackState) {
        this.playbackState = playbackState; //The schedule needs a reference to the playback state when scheduling ads.
        this.initializeState();
    };

    //Resets the Schedule's state
    Obj.prototype.initializeState = function () {
    	this.log("initializeState");
        this._ready = true;
        this._prerolls = [];
        this._midrolls = [];
        this._postrolls = [];
        this._adInsertionPolicy = "default";
        this.adRetrievalPromise = adfw.Q(true);
    };

    Obj.prototype.skipForwardHelper = function (playhead, duration, adbreakSkipBehavior, skipPrerollsToo) {
        if (adbreakSkipBehavior == "PLAY_ALL") {
            //Midroll behavior is set to PLAY_ALL, don't skip anything
            return;
        }

        var chosenMidroll = null;
        var chosenPreroll = null;

        //Go through all midrolls and skip them, except for one
        for (var i = 0; i < this._midrolls.length; i++) {
            var midroll = this._midrolls[i];
            if (midroll.test(playhead, duration)) {
                if (!chosenMidroll) {
                    chosenMidroll = midroll;
                }
                else {
                    midroll.setSkipped();
                }
            }
        }

        //Go through all prerolls and skip them, except for one
        if (skipPrerollsToo) {

            for (var i = 0; i < this._prerolls.length; i++) {
                var preroll = this._prerolls[i];
                if (!chosenPreroll) {
                    chosenPreroll = preroll;
                }
                else {
                    preroll.setSkipped();
                }
            }
        }

        //Skip both the reserved midroll and postroll
        if (adbreakSkipBehavior == "PLAY_NONE") {
            if (chosenMidroll) {
                chosenMidroll.setSkipped();
            }
            if (chosenPreroll) {
                chosenPreroll.setSkipped();
            }
        }

        //Select only one adbreak to play. If we have both a midroll and preroll, then skip the midroll
        else if (adbreakSkipBehavior == "PLAY_ONE") {
            if (chosenMidroll && chosenPreroll) {
                chosenMidroll.setSkipped();
            }
            //If we don't have a preroll and a midroll, we can do nothing here and be OK
        }
    };

    //Signals to the schedule that content playback is starting at a specific time. The schedule will then cancel any appropriate prerolls/midrolls.
    Obj.prototype.startAt = function (playhead, duration) {
        if (!playhead) {
            return;
        }
	this.log("startAt. playhead : " + playhead);
        this.skipForwardHelper(playhead, duration, adfw.Config.get("RESUME_ADBREAK_BEHAVIOR"), adfw.Config.get("RESUME_ADBREAK_BEHAVIOR_SKIPS_PREROLLS_TOO"));
    };

    //After a FastForward to a particular Playhead, this function is used to skip all midrolls up to a certain point, according to the behavior specified in the config
    Obj.prototype.skipUpTo = function (playhead, duration) {
        this.log("skipUpTo " + playhead + "/" + duration);
        this.skipForwardHelper(playhead, duration, adfw.Config.get("FF_MIDROLL_BEHAVIOR"), false);
    };

    //When rewinding, this function is used to restore skipped or previously played midrolls
    Obj.prototype.skipBackTo = function (playhead, duration) {

        this.log("skipBackTo " + playhead + "/" + duration);

        if (playhead < 0) {
            playhead = 0;
        }

        var hasAlreadyRestoredPlayedMidroll = false;

        for (var i = 0; i < this._midrolls.length; i++) {
            var midroll = this._midrolls[i];
            if (!midroll.getOffset().test(playhead, duration)) {
                //Restore skipped midrolls
                if (midroll.isSkipped()) {
                    this.log("skipBackTo restored a skipped midroll: " + midroll);
                    midroll.unsetSkipped();
                }
                //Restore played midrolls if the config dictates
                if (midroll.isPlayed() && adfw.Config.get("RW_MIDROLL_BEHAVIOR") !== adfw.Config.RW_MIDROLL_BEHAVIOR.RESTORE_NONE) {
                    if (adfw.Config.get("RW_MIDROLL_BEHAVIOR") === adfw.Config.RW_MIDROLL_BEHAVIOR.RESTORE_ONE && !hasAlreadyRestoredPlayedMidroll) {
                        this.log("skipBackTo restored a played midroll: " + midroll);
                        midroll.unsetPlayed();
                        hasAlreadyRestoredPlayedMidroll = true;
                    }
                    else if (adfw.Config.get("RW_MIDROLL_BEHAVIOR") === adfw.Config.RW_MIDROLL_BEHAVIOR.RESTORE_ALL) {
                        this.log("skipBackTo restored a played midroll: " + midroll);
                        midroll.unsetPlayed();
                        hasAlreadyRestoredPlayedMidroll = true;
                    }
                }
                for (var j = 0; j < midroll.getAds().length; j++) {
                    var selectedad = midroll.getAds()[j];
                    if (selectedad.isSkipped()) {
                        selectedad.unsetSkipped();
                    }
                }
            }
        }
    };

    Obj.prototype.getAdBreakTimes = function (contentDuration) {
		this.log("getAdBreakTimes");
        var list = [];
        var i;
        for (i = 0; i < this._prerolls.length; i++) {
            list.push(0);
        }
        for (i = 0; i < this._midrolls.length; i++) {
            var midroll = this._midrolls[i];
            var triggerMS = midroll.getOffset().getTriggerMS(contentDuration);
            if (typeof triggerMS == 'number' && !isNaN(triggerMS) && isFinite(triggerMS)) {
                list.push(triggerMS);
            }
        }
        if (typeof contentDuration === 'number') {
            for (i = 0; i < this._postrolls.length; i++) {
                list.push(contentDuration);
            }
        }
        return list;
    };

	Obj.prototype.getPlayableAdBreakTimes = function (contentDuration) {
		this.log("getPlayableAdBreakTimes");
        var list = [];
        var i;
        for (i = 0; i < this._prerolls.length; i++) {
            list.push(0);
        }
        for (i = 0; i < this._midrolls.length; i++) {
            var midroll = this._midrolls[i];
            var triggerMS = midroll.getOffset().getTriggerMS(contentDuration);
            if (typeof triggerMS == 'number' && !isNaN(triggerMS) && isFinite(triggerMS)) {
                if(!midroll.isSkipped() && !midroll.isPlayed())
                {
                    list.push(triggerMS);
                }
                else
                {
                    this.log("Do not send skipped or played ad time information, [" + triggerMS + "]");
                }
            }
        }
        if (typeof contentDuration === 'number') {
            for (i = 0; i < this._postrolls.length; i++) {
                list.push(contentDuration);
            }
        }
        return list;
    };

    //Gets the next unplayed preroll/midroll/postroll.
    Obj.prototype.getNextUnplayedPreroll = function () {
    	this.log("getNextUnplayedPreroll");
        return this.getNextUnplayedAdbreak(this._prerolls);
    };
    Obj.prototype.getNextUnplayedPostroll = function () {
	this.log("getNextUnplayedPostroll");
        return this.getNextUnplayedAdbreak(this._postrolls);
    };
    Obj.prototype.getNextUnplayedAdbreak = function (rollArray) {
	this.log("getNextUnplayedAdbreak");
        var adBreakToBePlayedFirst = null;
        if (rollArray) {
            for (var i = 0; i < rollArray.length; i++) {
                var adbreak = rollArray[i];
                if (!adbreak.isPlayed() && !adbreak.isSkipped()) {
                    adBreakToBePlayedFirst = adbreak;
                    break;
                }
            }
        }
        if (adBreakToBePlayedFirst) {
            return adBreakToBePlayedFirst;
        }
        else {
            return false;
        }
    };
    Obj.prototype.getNextUnplayedMidroll = function (playhead, duration) {
	this.log("getNextUnplayedMidroll");
        var chosenMidroll = null;
        for (var i = 0; i < this._midrolls.length; i++) {
            var midroll = this._midrolls[i];
            if (!midroll.isPlayed() && !midroll.isSkipped()) {
                if (!chosenMidroll) {
                    chosenMidroll = midroll;
                    if(this.getAdInsertionPolicy() === "interval")
                    {
                        continue;
                    }
                    break;
                }
                else {
                    if(this.getAdInsertionPolicy() === "interval")
                    {
                        if (midroll.getOffset().getTriggerMS(duration) < chosenMidroll.getOffset().getTriggerMS(duration)) {
                            chosenMidroll = midroll;
                            continue;
                        }
                    }
                }
            }
        }
        return chosenMidroll;
    };

    //Is an ad XML retrieval in progress?
    Obj.prototype.isReady = function () {
        return !this.adRetrievalPromise.isPending();
    };

    //When the schedule has finished retrieving XML, then perform action
    Obj.prototype.whenReady = function (action) {
        return this.adRetrievalPromise
            .then(action);
    };

    Obj.prototype.insertAdBreakFromVast = function (url, params) {
        var self = this;

        if (!params) {
            params = {};
        }
        this.log("insertAdBreakFromVast - time = " + params.time);
        this.log("insertAdBreakFromVast from " + url);

        if (adfw.Config.get("ADBREAK_LAZY_LOAD") && (params.time || typeof(params.time === 'number'))) {
            var lazyVASTResolver = new adfw.LazyVASTResolver(url);
            var newAdbreak = new adfw.AdBreak({
                offset: new adfw.Offset(params.time),
                breakType: "linear",
                eventTrackers: [],
                errorTrackers: [],
                lazyVASTResolver: lazyVASTResolver,
            });

            if (params.skip === true) {
                newAdbreak.setSkipped();
            }

            this.scheduleAdbreak(newAdbreak);
        }
        else {
            this.insertAdBreak(url, params);
        }
    };

    Obj.prototype.insertAdBreaksFromVmap = function (url, params) {
        this.insertAdBreak(url, params);
    };

    /*
     * Given a VMAP/VAST Url, Inserts an advertisement.
     * PARAM MAP
     * 	time: milliseconds to insert ad at. If blank, inserts immediately.
     */
    Obj.prototype.getAdInsertionPolicy = function() {
        return this._adInsertionPolicy;
    };
    Obj.prototype.setAdInsertionPolicy = function (adInsertionPolicy) {
        this._adInsertionPolicy = adInsertionPolicy;
    };
	
    Obj.prototype.insertAdBreak = function (url, params) {
        this.log("insertAdBreak");
        var self = this;

        if (!params) {
            params = {};
        }
		
        if(params.time)
        {
            if(typeof(params.time) !== "number" && params.time !== "start" && params.time !== "end" && params.time !== "now")
            {
                throw(time + " is not an appropriate format. It can't insert AdBreak in that time.");
            }
            this.log("insertAdBreak from " + url + " | time=" + params.time);
        }

        var promise = adfw.Parser.parse(url, params.context)
            .then(function (adThing) {
                if (!adThing || !adThing.length) {
                    throw "No ads to insert!";
                }
                self.insertAdObject(adThing, params);
				
                //check if mid rolls need to be sorted or not
                if(self.getAdInsertionPolicy() !== "interval")
                {
                    self.log("Sort midroll queue");
                    self.sortMidroll();
                }
                else
                {
                    self.log("In case of Interval policy, it doesn't sort midroll queue");
                }
            })
            .catch(function (err) {
                adfw.Events.dispatchEvent(adfw.Events.ADBREAK_INSERTION_FAILURE, {
                    message: "Failed to insert ads: " + err
                });
                self.log("Adbreak insertion failure: " + err);
            });

        if (this.isReady()) {
            this.adRetrievalPromise = promise;
        }
        else {
            this.adRetrievalPromise = adfw.Q.allSettled([this.adRetrievalPromise, promise]);
        }

        return this.adRetrievalPromise;
    };

    //The controller will notify the schedule of the content playhead so that it can resolve ad tags just-in-time
    Obj.prototype.notifyContentPlayhead = function (time, duration) {
        this.log("notifyContentPlayhead: " + time + " / " + duration);

        if (typeof time !== "number" || typeof duration !== "number" || isNaN(time) || isNaN(duration)) {
            return false;
        }

        var adTagRetrievalTime = time + adfw.Config.get("AD_RETRIEVAL_TIMEOUT") + adfw.Config.get("AD_PREBUFFER_ADVANCE_TIME") + 1000;

        //Resolve midrolls
        for (var i = 0; i < this._midrolls.length; i++) {
            if (!this._midrolls[i].hasTriedToResolve() && this._midrolls[i].test(adTagRetrievalTime, duration)) {
                this._midrolls[i].resolve();
            }
        }
        //Resolve postrolls
        if ((time + adTagRetrievalTime) >= duration) {
            for (var x = 0; x < this._postrolls.length; x++) {
                this._postrolls[x].resolve();
            }
        }
    };

    Obj.prototype.insertAdObject = function (adThing, params) {
        this.log("insertAdObject");
        this.cleanOldMidrolls();

        if (adThing[0] instanceof adfw.Ad) {
            //We just parsed a VAST
			
            var offset;
            if (params && params.time) {
                offset = new adfw.Offset(params.time);
            }
            else {
                var playhead = this.playbackState.currentContentPlayhead();
                if (!playhead) {
                    playhead = "start";
                }
                offset = new adfw.Offset(playhead);
            }

            var newAdbreak = new adfw.AdBreak({
                offset: offset,
                breakType: "linear",
                eventTrackers: [],
                errorTrackers: [],
                ads: adThing
            });

            if (params.skip === true) {
                newAdbreak.setSkipped();
            }

            this.scheduleAdbreak(newAdbreak);
            //this.log("Adbreak inserted at: " + newAdbreak.getOffset().toString());
            var message = "AdBreak containing " + adThing.length + " ads was inserted at " + newAdbreak.getOffset().toString();
            this.log(message);

        }
        else if (adThing[0] instanceof adfw.AdBreak) {

            if (adfw.Utils.parseBoolean(params.firstBreakOnly) === true) {
                adThing = adThing.slice(0, 1);
                //this.log("Only first break from XML will be inserted: " + adThing);
            }
            else {
                //this.log("Keeping everything: " + params.firstBreakOnly);
            }

            //We just parsed a VMAP
            if (params && params.time) {
                //We are overriding the adbreak's default time
                for (var i = 0; i < adThing.length; i++) {
                    //try {
                    if (params.time === "now") {
                        params.time = this.playbackState.currentContentPlayhead();
                    }
                    adThing[i].setOffset(new adfw.Offset(params.time));

                    if (params.skip === true) {
                        adThing[i].setSkipped();
                    }

                    this.scheduleAdbreak(adThing[i]);
                    //this.log("Adbreak inserted at (overridden) offset: " + adThing[i].getOffset().toString());
                    var message = "AdBreak containing " + adThing[i].getAds().length + " ads was inserted at : " + adThing[i].getOffset().toString();
                    this.log(message);
                    //}
                    //catch(e) {
                    //	this.log("WTF: " + e);
                    //}
                }
            }
            else {
                for (var j = 0; j < adThing.length; j++) {
                    //try {

                    if (params.skip === true) {
                        adThing[j].setSkipped();
                    }

                    this.scheduleAdbreak(adThing[j]);
                    var message = "AdBreak containing " + adThing[j].getAds().length + " ads was inserted at : " + adThing[j].getOffset().toString();
                    this.log(message);
                }
            }
        }
        else {
            this.error("We have no idea what we just parsed..." + adThing[i].getOffset().toString());
            return false;
        }
        return true;
    };

    Obj.prototype.cleanOldMidrolls = function () {
	this.log("cleanOldMidrolls");
        //If we have too many adbreaks in the midroll list, it's time to trim out any that have already played or have been skipped.
        var originalLength = this._midrolls.length;
        var limit = adfw.Config.get("MIDROLL_TRIM_LIMIT");
        if (!limit || typeof limit !== "number") {
            limit = 25;
            adfw.Config.set("MIDROLL_TRIM_LIMIT", limit);
        }
        if (this._midrolls.length > limit) {
            var index = this._midrolls.length;
            while (index--) {
                if (this._midrolls[index] && this._midrolls[index].isPlayed()) {
                    this._midrolls.splice(index, 1);
                }
            }
        }
        //If we are still over the limit then we'll need to start trimming the skipped midrolls too.
        if (this._midrolls.length > limit) {
            var index = this._midrolls.length;
            while (index--) {
                if (this._midrolls[index] && (this._midrolls[index].isPlayed() || this._midrolls[index].isSkipped())) {
                    this._midrolls.splice(index, 1);
                }
            }
        }
        //If we are still over the limit, then we need to increase the limit so we don't check every time.
        if (this._midrolls.length > limit) {
            adfw.Config.set("MIDROLL_TRIM_LIMIT", (this._midrolls.length + 10));
        }

        if (this._midrolls.length != originalLength) {
            this.log("Midroll list trimmed from " + originalLength + " to " + this._midrolls.length);
        }
    };

    //Given an adbreak object, determines whether it's a preroll, midroll, or postroll, and puts it in the appropriate list.
    Obj.prototype.scheduleAdbreak = function (adbreak) {
    	this.log("scheduleAdbreak");
        if (adbreak.getOffset().getType() === adfw.Offset.OffsetType.STATIC_OFFSET_START) {
            this._prerolls.push(adbreak);
            adfw.Events.dispatchEvent(adfw.Events.ADBREAK_INSERTION_SUCCESS, {
                message: "Preroll scheduled",
                offset: adbreak.getOffset().toString(),
            });
        }
        else if (adbreak.getOffset().getType() === adfw.Offset.OffsetType.STATIC_OFFSET_END) {
            this._postrolls.push(adbreak);
            adfw.Events.dispatchEvent(adfw.Events.ADBREAK_INSERTION_SUCCESS, {
                message: "Postroll scheduled",
                offset: adbreak.getOffset().toString(),
            });
        }
        else if (adbreak.getOffset()) {
            //It's not a preroll or postroll, so it's a midroll.
            this._midrolls.push(adbreak);
            adfw.Events.dispatchEvent(adfw.Events.ADBREAK_INSERTION_SUCCESS, {
                message: "Midroll scheduled at " + adbreak.getOffset().toString(),
                offset: adbreak.getOffset().toString(),
            });
        }
        else {
            this.error("Scheduled adbreak does not have a valid offset: " + adbreak.getOffset());
            adfw.Events.dispatchEvent(adfw.Events.ADBREAK_INSERTION_FAILURE, {
                message: "Scheduled adbreak does not have a valid offset: " + adbreak.getOffset()
            });
        }
    };

    Obj.prototype.sortMidroll = function () {
        if(this._midrolls.length > 1){
            this.log("Sorting midrolls. Total length:"+this._midrolls.length);
            this._midrolls.sort(function(a, b){
                return a.getOffset().getTriggerMSWithoutTypecheck() - b.getOffset().getTriggerMSWithoutTypecheck()
            });
        }		
    }
 /* This function performs a binary search on Sorted Midroll Array and returns -1 in case particular time offset is not found in the provided xml.
    * Otherwise it return the index of the adbreak in the midroll array
    */
    Obj.prototype.findMidRoll = function( low,  high,  key) {
        var mid = parseInt((high-low)/2) + low;
        if(low > high)
            return -1;
        
        if(this._midrolls[mid].getOffset().getTriggerMS() > key){
            return this.findMidRoll(low, mid-1, key);
        }
        else if (this._midrolls[mid].getOffset().getTriggerMS() < key) {
            return this.findMidRoll(mid+1, high, key);   
        }
        else{
            /**
            * Go to the first index of the midroll with the given timestamp
            * This will help in cancelling all the adbreaks with the given timestamp, since xml can have multiple adbreaks scheduled at the same time.
            **/
            while(mid-1 >= 0 && this._midrolls[mid-1].getOffset().getTriggerMS() == key)
                    mid--;
            return mid;
        }
    }
    
    /* This function checks if the cancellation is called for Preroll, Midroll or Postroll Ad */
    Obj.prototype.cancelScheduledAd = function(ms){
        this.log("Cancel Ad Break at "+ ms.toString());
        if (ms.toString().toLowerCase() === 'start') {
            //Cancelling Preroll Ad
            var i;
            for(i = 0; i < this._prerolls.length ; i++)
                this._prerolls[i].setSkipped();
            this.log("Preroll Ads are cancelled");
        }
        else if (ms.toString().toLowerCase() === 'end') {
            //Cancelling Postroll Ad
            var i;
            for(i =0;i < this._postrolls.length; i++)
                this._postrolls[i].setSkipped();
            this.log("Postroll Ads are cancelled");
        }
        else{
            //If not Preroll os Postroll, than it is definitely Midroll
            var res = ms.indexOf(' ',0);        //Finding index of ' '(Space) before ms
            res = ms.substring(0,res);          
            ms = parseInt(res);                 //converting string value to integer for comparison operators
            var index = this.findMidRoll(0,this._midrolls.length-1,ms); 
            if(index != -1){
               /**
               * From the first index to the last index of midroll where timestamp is equal to the ms, we have to skip the ads.
               * This will ensure that all the adbreaks are cancelled with given timestamp
               **/
                while(index < this._midrolls.length && this._midrolls[index].getOffset().getTriggerMS() == ms){
                    this._midrolls[index].setSkipped();
                    index++;
                }
                this.log("Midroll scheduled at "+ms.toString()+" ms is cancelled");
            }
            else{
                this.log("No Midroll scheduled at "+ms.toString()+" ms");
            }
        }
    }
    
    /**
    *This Function will cancel the next ad from playing.
    * If the next ad is preroll, it will cancel the remaining preroll.
    * If the next ad is midroll, it will cancel that particular midroll.
    * If the next ad is postroll, it will cancel the entire postroll.
    **/
    Obj.prototype.cancelNextScheduledAd = function () {
        for(var i =0; i < this._prerolls.length; i++){
            if(!(this._prerolls[i].isPlayed() || this._prerolls[i].isSkipped())){
                while(i != this._prerolls.length){
                    this._prerolls[i++].setSkipped();
                }
                return;
            }
        }
        for(var i =0; i < this._midrolls.length; i++){
            if(!(this._midrolls[i].isPlayed() || this._midrolls[i].isSkipped())){
                this._midrolls[i++].setSkipped();
                while(i < this._midrolls.length && this._midrolls[i].getOffset().getTriggerMS() === this._midrolls[i-1].getOffset().getTriggerMS()){
                    this._midrolls[i++].setSkipped();
                }
                return;
            }
        }
        for(var i =0;  i < this._postrolls.length ;i++){
            if(!(this._postrolls[i].isPlayed() || this._postrolls[i].isSkipped())){
                while(i != this._postrolls.length){
                    this._postrolls[i++].setSkipped();
                }
                return;
            }
        }
        
    }
    
    Obj.prototype.log = function (msg) {
        adfw.Utils.log(msg, "[ADFW SCHEDULE]");
    };
    Obj.prototype.error = function (msg) {
        adfw.Utils.error(msg, "[ADFW SCHEDULE]");
    }

    return Obj;
}());

adfw.Controller = (function () {

    "use strict";

    //Version and date, we'll log this out on each initialize()
    var buildVersion = "2.3.0";
    buildVersion += "";
    var buildDate = "2019-05-09";

    var getVersion = function () {
        return buildVersion + " | " + buildDate;
    };

    //*******************************************************************************************************
    //STATE

    var self = null;
    var player = null; //Should be a PlayerAdapter, once initialized
    var audio = null; //Should be the SAMSUNG-INFOLINK-AUDIO, once initialized

    var currentAdCallback = null;

    var state = null; //Should be adfw.PlaybackState
    var schedule = null; //Should be adfw.Schedule

    //Stuff for Disable Content Control
    var disableContentControl = false; //Boolean - if true, ad framework will not try to control the content. Instead, it will dispatch and expect events	
    var mockContentDuration = 0;
    var alreadyTriedToBufferContent = false;

    var contentStopDeferred = adfw.Q.defer();

    var refreshContentStopDeferred = function () {
        if (contentStopDeferred) {
            contentStopDeferred.reject();
        }
        contentStopDeferred = adfw.Q.defer();
    };

    //Backdoor into the state, returns PlaybackType
    var getCurrentPlaybackType = function () {
        return state.currentPlaybackType(); //returns one of the PlaybackType
    };

    //Resets the schedule and internal state of the Ad Framework.
    var resetState = function () {
        log("resetState");
        player.cancelBufferedVideo();
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT || state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            //player.stop(); //TODO: This was disabled since it's better to trust that the player is already stopped... VERIFY THAT IT'S WORKING ON ALL PLATFORMS
        }
        currentAdCallback = null;
        state.initializeState();
        schedule.initializeState();
    };
    /** reset VPAID */
    var resetVPaid = function () {
    	log("resetVPaid");
        if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
            adfw.VisualOverlay.VPAIDWrapper.stopAd();
        }
    };

    var playerInstanceCheck = function (player) {
        if(!player)
        {
            throw("player instance is not created");
        }
    };

    var initialize = function (params) {
        var initString = "AD FRAMEWORK INITIALIZATION: " + getVersion() + " | Platform " + adfw.PlatformUtils.getPlatform();
        log("initialize : " + initString);

        if (player) {
            try {
                player.close();
                player = null;
            }
            catch (e) {
                throw('Failed in close ' + e);
            }
        }
        if(params !== undefined  && (params === null || typeof params !== 'object')){
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");
        }
        
        var validKeys = {        
            disableContentControl : undefined,
            adapterType : undefined,
            playerID1 : undefined,
            playerID2 : undefined,
            audioID : undefined,
            enablePrebuffering : undefined
        }
        var key;
        for (key in params) {
            if(!validKeys.hasOwnProperty(key))
                throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"Invalid value"+key);
        }
        if (!params) {
            params = {};
        }
        log(JSON.stringify(params));

        if(params.disableContentControl != undefined)
           disableContentControl = params.disableContentControl;

        state = new adfw.PlaybackState();
        schedule = new adfw.Schedule(state);

        player = setAdapterType(params);
        log("Selected Adapter Type: " + params.adapterType);

        setErrorListener();
        setEventListener();

    };

    var setAdapterType = function (params) {
        log("setAdapterType");

        if (params.adapterType === undefined) {
            if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.ORSAY_WEBKIT) {
                params.adapterType = adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF;
            }
            else if (adfw.PlatformUtils.getPlatform() === adfw.PlatformUtils.Platform.TIZEN_WEBKIT) {
                params.adapterType = adfw.PlayerAdapter.AdapterType.TIZEN_WEBKIT_AVPLAY;
            }
            else {                                                                                                                        
                params.adapterType = adfw.PlayerAdapter.AdapterType.HTML5;
            }
        }

        if (params.adapterType === adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF) {
            if (!audioID) {
                audio = adfw.OrsayWebkitUtils.generateAudioPlugin();
            } else {
                audio = document.getElementById(params.audioID);
            }
            player = new adfw.SEFAdapter(params);
            adfw.DisplayHandler.init();
        }
        else if (params.adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_WEBKIT_AVPLAY) {
            player = new adfw.AVPlayAdapter(params);
            adfw.DisplayHandler.init();
        }
        else if (params.adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_VOLT_LWPLAYER) {
            player = new adfw.LWPlayerAdapter(params);
        }
        else if (params.adapterType === adfw.PlayerAdapter.AdapterType.HTML5) {
            player = new adfw.HTML5Adapter(params);
            adfw.DisplayHandler.init();
        }
        else if (params.adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_TVPLUS_IP) {
            player = new adfw.TVPlusIPAdapter(params);
        }
        else {
            var errorMessage = "Unknown adapter type: " + params.adapterType;
            this.error(errorMessage);
            throw(errorMessage);
        }
        return player;
    };

    var onError = function (evt, params) {
        switch(evt) {
            case adfw.PlayerAdapter.Events.RENDER_ERROR:
            case adfw.PlayerAdapter.Events.CONNECTION_FAILED:
            case adfw.PlayerAdapter.Events.AUTHENTICATION_FAILED:
            case adfw.PlayerAdapter.Events.STREAM_NOT_FOUND:
            case adfw.PlayerAdapter.Events.NETWORK_DISCONNECTED:
                internalOnActivePlayerProblem(evt, params);
                break;
            case adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR:
            case adfw.PlayerAdapter.Events.PREBUFFERING_CONNECTION_FAILED:
            case adfw.PlayerAdapter.Events.PREBUFFERING_AUTHENTICATION_FAILED:
            case adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND:
            case adfw.PlayerAdapter.Events.PREBUFFERING_NETWORK_DISCONNECTED:
                internalOnDormantPlayerProblem(evt, params);
                break;
        }
    };

    var setErrorListener = function () {
        log("setErrorListener");

        player.addListener(adfw.PlayerAdapter.Events.RENDER_ERROR, onError);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR, onError);
        player.addListener(adfw.PlayerAdapter.Events.CONNECTION_FAILED, onError);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_CONNECTION_FAILED, onError);
        player.addListener(adfw.PlayerAdapter.Events.AUTHENTICATION_FAILED, onError);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_AUTHENTICATION_FAILED, onError);
        player.addListener(adfw.PlayerAdapter.Events.STREAM_NOT_FOUND, onError);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND, onError);
        player.addListener(adfw.PlayerAdapter.Events.NETWORK_DISCONNECTED, onError);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_NETWORK_DISCONNECTED, onError);
    };

    var onEvent = function (evt, params) {
        log("onEvent, event : " + evt);
        switch(evt) {
            case adfw.PlayerAdapter.Events.BUFFERING_START:
                internalOnBufferingStart(evt, params);
                break;
            case adfw.PlayerAdapter.Events.BUFFERING_COMPLETE:
                internalOnBufferingComplete(evt, params);
                break;
            case adfw.PlayerAdapter.Events.BUFFERING_PROGRESS:
                internalOnBufferingProgress(evt, params);
                break;
            case adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_START:
                internalOnPrebufferingStart(evt, params);
                break;
            case adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_COMPLETE:
                internalOnPreBufferingComplete(evt, params);
                break;
            case adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_PROGRESS:
                internalOnPreBufferingProgress(evt, params);
                break;
            case adfw.PlayerAdapter.Events.RENDERING_START:
                internalOnRenderingStart(evt, params);
                break;
            case adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME:
                internalOnCurrentPlaytime(evt, params);
                break;
            case adfw.PlayerAdapter.Events.RENDERING_COMPLETE:
                internalOnRenderingComplete(evt, params);
                break;
            case adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED:
                internalDisplayAreaChanged(evt, params);
                break;
            case adfw.PlayerAdapter.Events.STREAM_INFO_READY:
                internalOnStreamInfoReady(evt, params);
                break;
            case adfw.PlayerAdapter.Events.SPARSE_TRACK:
                internalOnSparseTrack(evt, params);
                break;
            case adfw.PlayerAdapter.Events.PREBUFFERING_SPARSE_TRACK:
                internalOnPreBufferingSparseTrack(evt, params);
                break;
            case adfw.PlayerAdapter.Events.SUBTITLE:
                internalOnSubtitle(evt, params);
                break;
            case adfw.Events.VPAID_LINEARITY_CHANGE:
                processVPAIDLinearityChange(evt, params);
                break;
            case adfw.Events.VPAID_LINEAR_PLAYBACK_TIME:
                internalOnCurrentPlaytime(evt, params);
                break;
        }
    };

    var setEventListener = function () {
        log("setEventListener");

        player.addListener(adfw.PlayerAdapter.Events.BUFFERING_START, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.BUFFERING_COMPLETE, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.BUFFERING_PROGRESS, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_START, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_COMPLETE, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_BUFFERING_PROGRESS, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.RENDERING_START, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.RENDERING_COMPLETE, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.DISPLAY_AREA_CHANGED, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.STREAM_INFO_READY, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.SPARSE_TRACK, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.PREBUFFERING_SPARSE_TRACK, onEvent);
        player.addListener(adfw.PlayerAdapter.Events.SUBTITLE, onEvent);

        adfw.Events.addListener(adfw.Events.VPAID_LINEARITY_CHANGE, onEvent);
        adfw.Events.addListener(adfw.Events.VPAID_LINEAR_PLAYBACK_TIME, onEvent);
    };

    var internalDisplayAreaChanged = function (evt, params) {
        if (state.isLinearAdMode()) {
            var diffW = params.w - params.oldw;
            var diffH = params.h - params.oldh;
            if (diffW > 30) {
                onLinearAdExpand();
                // if (params.w > 955 && params.oldw < 955) {
                // 	onLinearAdFullscreen();
                // }
            } else if (diffW < -30) {
                onLinearAdCollapse();
                // if (params.w < 955 && params.oldw > 955) {
                // 	onLinearAdExitFullscreen();
                // }
            }
        }
    };

    var internalOnBufferingProgress = function (evt, params) {
        if (isPlayingLinearAd() && state.linearAdTimeout()) {
            //Postpone any ad timeout checking
            log("AD " + evt + ":" + params.percent + " - extending Linear Ad timeout...");
            clearLinearAdTimeout();
            setLinearAdTimeout();
        }
        else {
            log("CONTENT Buffering progress: " + params.percent);
        }
        adfw.Events.dispatchEvent(adfw.Events.BUFFERING_PROGRESS, params);
    };

    //Executes afterContentStart and afterLinearAdStart functions
    var internalOnRenderingStart = function () {
        log("internalOnRenderingStart");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT && !disableContentControl) {
            log("Content Rendering Start!");
            var afterContentStartFunction = state.afterContentStart();
            if (typeof afterContentStartFunction === "function") {
                afterContentStartFunction(player.getInternalPlayer());
            }

        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            log("Ad Rendering Start!");
            var afterLinearAdStartFunction = state.afterLinearAdStart();
            if (typeof afterLinearAdStartFunction === "function") {
                afterLinearAdStartFunction(player.getInternalPlayer());
            }
        }
    }


    //If the current video completes rendering, handle stuff
    var internalOnRenderingComplete = function () {
        log("internalOnRenderingComplete");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdComplete();
            currentAdCallback();
        }
        else if (!disableContentControl) {
            endPlayback();
        }
    };

    var internalOnStreamInfoReady = function() {
        log("internalOnStreamInfoReady");
        var adapterType = player.getAdapterType();
        var resumeTime = state.currentContentPlayhead() ? Math.max(state.currentContentPlayhead() - (adfw.Config.get("REWIND_BEFORE_RESUME") * 1000), 0) : 0;
        
        if (adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_TVPLUS_IP && getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            log("Dispatch CONTENT_INIT_COMPLETE Event");
            adfw.Events.dispatchEvent(adfw.Events.CONTENT_INIT_COMPLETE, {
                ms: resumeTime,
                url: state.currentContentVideoUrl()
            });
        }
    };

    //A problem has occurred on the active player. If the active video is an ad, we must fire the appropriate error trackers and move onto the next ad.
    var internalOnActivePlayerProblem = function (evt, params) {
        log("internalOnActivePlayerProblem");
        if (state.ignoreActivePlayerProblems() === true) {
            log("IGNORING ACTIVE PLAYER PROBLEM: " + evt);
            return false;
        }

        if (disableContentControl && getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            log("IGNORING ACTIVE PLAYER (CONTENT) PROBLEM: " + evt);
            return false;
        }

        player.cancelBufferedVideo();

        var logMessage = evt + " | " + state.currentPlaybackType();
        if (evt === adfw.PlayerAdapter.Events.RENDER_ERROR) {
            logMessage += (" | " + params.code + " | " + params.message);
        }
        log(logMessage);

        if (evt === adfw.PlayerAdapter.Events.RENDER_ERROR && params.code == 3) {
            log("AUDIO CODEC PROBLEM: Ignoring it and continuing playback...");
            adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {

                message: "Unsupported audio codec detected"
            });
            return false;
        }

        //If we're playing content, just fire a playback error. If we're playing ad, skip ad and play next
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {

            var message;

            if (state.canRetryPlayback()) {
                message = "Content playback error [" + evt + (params.code ? params.code : "") + "], attempting to retry...";
                error(message);
                state.triedToRestartVideo();
                adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {
                    type: evt,
                    code: params.code,
                    message: message,
                    url: state.currentVideoUrl(),
                });
                //We will ignore active player problems for some time until we resume the content
                state.ignoreActivePlayerProblems(true);
                player.stop();
                state.currentVideoUrl(null);
                //Just in case, we will try to reset the state of the buffered video
                state.currentBufferedLinearAd(null);
                state.currentBufferedLinearAdBreak(null);
                player.cancelBufferedVideo();

                var delay = Math.max(500, adfw.Config.get("PLAYBACK_FAILURE_RETRY_DELAY"));

                setTimeout(function () {
                    state.ignoreActivePlayerProblems(false);
                    playOrResumeContent();
                }, delay);
            } else {
                message = "Failed to recover from content playback error [" + evt + (params.code ? params.code : "") + "]. Giving up on " + state.currentVideoUrl();
                error(message);
                adfw.Events.dispatchEvent(adfw.Events.UNRECOVERABLE_PLAYBACK_ERROR, {
                    type: evt,
                    code: params.code,
                    message: message,
                    url: state.currentVideoUrl()
                });
            }
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {

            clearLinearAdTimeout();

            var errorCode = 400;
            var errorMessage = "Unknown linear ad error";
            if (evt === adfw.PlayerAdapter.Events.RENDER_ERROR) {
                if (params.code == 1 || params.code == 2 || params.code == 3 || params.code == 4) {
                    errorCode = 405;
                    errorMessage = params.message + " | [RENDER_ERROR" + params.code + "]";
                }
            } else if (evt === adfw.PlayerAdapter.Events.CONNECTION_FAILED) {
                errorCode = 401;
                errorMessage = "Connection failed; MediaFile URI not valid";
            } else if (evt === adfw.PlayerAdapter.Events.AUTHENTICATION_FAILED) {
                errorCode = 400;
                errorMessage = "Authentication failed; Unable to authenticate to MediaFile URI";
            } else if (evt === adfw.PlayerAdapter.Events.STREAM_NOT_FOUND) {
                errorCode = 401;
                errorMessage = "Stream not found; Unable to play MediaFile stream";
            } else if (evt === adfw.PlayerAdapter.Events.NETWORK_DISCONNECTED) {
                errorCode = 400;
                errorMessage = "Client network connection has disconnected";
            } else if (evt === adfw.PlayerAdapter.Events.PLAYER_EXCEPTION) {
                errorCode = 400;
                errorMessage = "Unknown player exception";
            }
            errorMessage += " | " + state.currentLinearAd().getLinearCreative().getOptimalMediaFile().getUrl();

            error(errorMessage);
			
            adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {
                type: evt,
                message: params.message,
                vsuiteErrorText: "Ad playback error: " + errorMessage,
                ad: state.currentLinearAd(),
                url: state.currentLinearAd().getLinearCreative().getOptimalMediaFile().getUrl()
            });

            handleVSuitePlaybackError(state.currentAdBreak(), state.currentLinearAd(), errorCode, errorMessage, state.currentContentPlayhead(), state.currentLinearAd().getLinearCreative().getOptimalMediaFile().getUrl());
            state.currentLinearAd().setErrored();
            player.stop();
            currentAdCallback();
        }
    };

    //A problem has occurred on the dormant (prebuffering) player. If the prebuffering video was an ad, we must fire the appropriate error trackers and move onto the next ad.
    var internalOnDormantPlayerProblem = function (evt, params) {
	log("internalOnDormantPlayerProblem");
        if (disableContentControl && getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            log("IGNORING ACTIVE PLAYER (CONTENT) PROBLEM: " + evt);
            return false;
        }


        var logMessage = evt + " | " + state.currentPlaybackType();
        if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR) {
            logMessage += (" | " + params.code + " | " + params.message);
        }
        log(logMessage);

        if (evt === adfw.PlayerAdapter.Events.RENDER_ERROR && params.code == 3) {
            log("AUDIO CODEC PROBLEM: Ignoring it and continuing playback...");
            adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {
                type: evt,
                message: "Unsupported audio codec detected",
            });
            return false;
        }

        if (!player.getBufferedVideoUrl()) { //False alarm, there is no buffered video (this could have happened if 2 events are thrown for the same problem)
            log("internalDormantPlayerProblem: False Alarm: " + logMessage);
            return false;
        } else if (state.currentBufferedLinearAd()) { //Buffered video was an ad
            log("buffered ad fault: " + player.getBufferedVideoUrl());

            try {
                var errorCode = 400;
                var errorMessage = "Unknown prebuffered linear ad error";
                if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_RENDER_ERROR) {
                    if (params.code == 1 || params.code == 2 || params.code == 3 || params.code == 4) {
                        errorCode = 405;
                        errorMessage = params.message + " | [RENDER_ERROR" + params.code + "]";
                    }
                } else if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_CONNECTION_FAILED) {
                    errorCode = 401;
                    errorMessage = "Connection failed; MediaFile URI not valid";
                } else if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_AUTHENTICATION_FAILED) {
                    errorCode = 400;
                    errorMessage = "Authentication failed; Unable to authenticate to MediaFile URI";
                } else if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_STREAM_NOT_FOUND) {
                    errorCode = 401;
                    errorMessage = "Stream not found; Unable to play MediaFile stream";
                } else if (evt === adfw.PlayerAdapter.Events.PREBUFFERING_NETWORK_DISCONNECTED) {
                    errorCode = 400;
                    errorMessage = "Client network has disconnected";
                }
                errorMessage += " | " + state.currentBufferedLinearAd().getLinearCreative().getOptimalMediaFile().getUrl();

                adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {
                    type: evt,
                    message: "Buffered ad playback error: " + errorMessage,
                    ad: state.currentBufferedLinearAd(),
                    url: state.currentBufferedLinearAd().getLinearCreative().getOptimalMediaFile().getUrl(),
                });

                handleVSuitePlaybackError(state.currentBufferedLinearAdBreak(), state.currentBufferedLinearAd(), errorCode, errorMessage, state.currentContentPlayhead(), state.currentBufferedLinearAd().getLinearCreative().getOptimalMediaFile().getUrl());
                state.currentBufferedLinearAd().setErrored();
                state.currentBufferedLinearAd(null);
                state.currentBufferedLinearAdBreak(null);
                player.cancelBufferedVideo();
            }
            catch (e) {
                log(e);
            }
        } else { //Buffered video was content
            log("internalDormantPlayerProblem: Buffered content playback error " + logMessage);
            adfw.Events.dispatchEvent(adfw.Events.RECOVERABLE_PLAYBACK_ERROR, {
                type: evt,
                message: "Buffered content playback error, attempting to retry...",
                url: player.getBufferedVideoUrl(),
            });

            //Sometimes there are multiple events thrown upon an error. We don't want to necessarily stop video playback because of this. Instead, we just clear the buffer and hope for the best.
            error("buffered content fault: " + player.getBufferedVideoUrl());
            player.cancelBufferedVideo();
        }
    };

    //Handles time updates from the player.
    var internalOnCurrentPlaytime = function (event, params, bypassDisabledContentControl) {
        try {
            if (!params.ms) {
                params.ms = 0;
            } //Sometimes the SEF player is too jumpy and gives a playtime value of 0. We want to ignore that.
            var time = parseInt(params.ms, 10);
            log("internalOnCurrentPlaytime : " + time);
            if (state.currentPlayhead() && state.currentPlayhead() === time) {
                return; //Makes sure the time actually changed before triggering callbacks
            }
            else {
            }
            if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
                if (disableContentControl) {
                    if (bypassDisabledContentControl) {
                    }
                    else {
                        return;
                    }
                }
                state.currentPlayhead(time);
                contentOnCurrentPlaytime(time);
            } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
                state.currentPlayhead(time);
                adOnCurrentPlaytime(time);
            }
        }
        catch (e) {
            error("internalOnCurrentPlaytime: " + e);
        }
    };

    var internalOnBufferingStart = function (evt, params) {
        log("send BUFFERING_START event\n");
        adfw.Events.dispatchEvent(adfw.Events.BUFFERING_START, params);
    };
    var internalOnBufferingComplete = function (evt, params) {
        log("send BUFFERING_COMPLETE event\n");
        adfw.Events.dispatchEvent(adfw.Events.BUFFERING_COMPLETE, params);
    };
    var internalOnPrebufferingStart = function (evt, params) {
        log("send PREBUFFERING_START event\n");
        adfw.Events.dispatchEvent(adfw.Events.PREBUFFERING_BUFFERING_START, params);
    };
    var internalOnPreBufferingComplete = function (evt, params) {
        log("send PREBUFFERING_COMPLETE event\n");
        adfw.Events.dispatchEvent(adfw.Events.PREBUFFERING_BUFFERING_COMPLETE, params);
    };
    var internalOnPreBufferingProgress = function (evt, params) {
        log("send PREBUFFERING_PROGRESS event\n");
        adfw.Events.dispatchEvent(adfw.Events.PREBUFFERING_BUFFERING_PROGRESS, params);
    };
    var internalOnSparseTrack = function (evt, params) {
        log("send SPARSE_TRACK event\n");
        adfw.Events.dispatchEvent(adfw.Events.SPARSE_TRACK, params);
    };
    var internalOnPreBufferingSparseTrack = function (evt, params) {
        log("send SPARSE_TRACK event\n");
        adfw.Events.dispatchEvent(adfw.Events.PREBUFFERING_SPARSE_TRACK, params);
    };
    var internalOnSubtitle = function (evt, params) {
        log("send Subtitle event\n");
        adfw.Events.dispatchEvent(adfw.Events.SUBTITLE, params);
    };

    //*******************************************************************************************************
    //PLAYBACK/SCHEDULING CONTROLS

    //Initialize the player with Content Url and an ad schedule.
    //Params can either be a String representing VAST/VMAP, or it could be a map with several properties.
    var open = function (url, params) {
        log("open " + url);

        playerInstanceCheck(player);

        refreshContentStopDeferred();
        contentStopDeferred.resolve();

        alreadyTriedToBufferContent = false;

        if(url === undefined || typeof url !== 'string' ) {
            if(disableContentControl === true){
                url = "http://127.0.0.1/";
            }else{
                throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"Cannot open player with a null content Url (unless content control is disabled, but it is currently enabled)");
            }
        }
        resetState();
        resetVPaid();
        state.currentContentVideoUrl(url);

        if (params) {
            var adXMLUrl = null;
            if (typeof params === "string") {
                adXMLUrl = params;
            } else if (typeof params === "object") {
                //advanced mode
                /*
                 * params = {
                 *      time: Number (Seconds into playback to trigger adbreak)
                 *      adUrl: String (VMAP/VAST Url)
                 *
                 * }
                 */
                 var validKeys = {
                     time :"",
                     adUrl:""
                 }
                 for (var key in params) {
                    if (validKeys.hasOwnProperty(key)) {
                    }else{
                        throw new adfw.Utils.WebAPIExceptionForAdfw('INVALID_VALUES_ERR',"Invalid Key");
                        //return;
                    }
                }

                if (!params.adUrl) {
                    return false;
                }
                adXMLUrl = params.adUrl;

            }else {
                throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"Cannot initialize player with a invalid vmapp Url");
            }
            schedule.insertAdBreak(adXMLUrl, params);
        }
    };

    var setAdInsertionPolicy = function (adInsertionPolicy) {
        schedule.setAdInsertionPolicy(adInsertionPolicy);
    };

    //Adds a function to execute each time before the content starts. The function is passed a reference to the player object that will play content.
    var setBeforeContentStartHandler = function (func) {
        log("setBeforeContentStartHandler");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        state.beforeContentStart(func);
    };

    //Adds a function to execute each time after the content starts. The function is passed a reference to the player object that will play content.
    var setAfterContentStartHandler = function (func) {
        log("setAfterContentStartHandler");
        if(typeof func !== "function"){
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        }
        state.afterContentStart(func);
    };

    //Adds a function to execute each time before a linear ad starts. The function is passed a reference to the player object that will play content.
    var setBeforeLinearAdStartHandler = function (func) {
        log("setBeforeLinearAdStartHandler");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        state.beforeLinearAdStart(func);
    };

    //Adds a function to execute each time after a linear ad starts. The function is passed a reference to the player object that will play content.
    var setAfterLinearAdStartHandler = function (func) {
        log("setAfterLinearAdStartHandler");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        state.afterLinearAdStart(func);
    };

    //Changes the content Url. Takes effect next time the player switches from adbreak to content. Useful for changing cookies and such.
    var changeContentUrl = function (newUrl) {
        log("changeContentUrl : " + newUrl);

        if (typeof newUrl !== "string")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");

        if (newUrl) {
            state.currentContentVideoUrl(newUrl);
        }
    };

    //Adds a function to execute each time before a linear ad starts. The function is passed a String and it is expected to return a modified String.
    var setLinearAdUrlModifier = function (func) {
        log("setLinearAdUrlModifier");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        state.linearAdUrlModifier(func);
    };

    //Adds a function to execute each time before a tracking event fires. The function is passed a String and it is expected to return a modified String.
    var setTrackingUrlModifier = function (func) {
        log("setTrackingUrlModifier");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        adfw.ServerInterface.setTrackingUrlModifierFunction(func);
    };

    //Adds a function to execute each time before a tracking event fires. The function is passed a String and it is expected to return a modified String.
    var setErrorUrlModifier = function (func) {
        log("setErrorUrlModifier");
        if(typeof func !== "function")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        adfw.ServerInterface.setErrorUrlModifierFunction(func);
    };

    //Inserts an adbreak into the schedule.
    var insertAdBreak = function (input, params) {
        if(typeof input !== 'string' || input == "undefined" ){
            log("Invalid ad info");
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Url");
        }
        if(params !== undefined && typeof params !== 'object'){
            log("Invalid ad params");
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Url");
        }
        var validKeys ={
         time:"",
         skip:"",
         firstBreakOnly:""
        }
        var key;
        for (key in params) {
            if(!validKeys.hasOwnProperty(key))
                throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"Invalid Key"+key);
        }
   
        log("call insertAdBreak");
        schedule.insertAdBreak(input, params);
    };

    //Inserts an adbreak into the schedule.
    var insertAdBreakFromVast = function (input, params) {
        log("insertAdBreakFromVast");
        schedule.insertAdBreakFromVast(input, params);
    };

    /**
    * Cancel an already Scheduled Ad
    * This function takes time as arguement.
    * For Preroll, time is 'start'
    * For Postroll, time is 'end'
    * For Midroll, time is given in "HH:MM:SS" format
    **/
    var cancelScheduledAd = function (time) {
        log("cancelScheduledAd");
        var time_in_ms = 0;
        //time will be start or end in case of preroll and postroll respectively. For Midroll time will be calculated in ms.
        if(time !== 'start' && time !== 'end') {
            if((typeof (time[0]*1) !== "number") || (typeof (time[1]*1) !== "number") || (typeof (time[3]*1) !== "number") 
              || (typeof (time[4]*1) !== "number") || (typeof (time[6]*1) !== "number") || (typeof (time[7]*1) !== "number")
              || (time[2] !== ":") || (time[5] !== ":"))   
            {
                throw(time + " is not an appropriate format. It can't cancel any ad");
            }
            else
            {
                time_in_ms = time[0]*36000 + time[1]*3600 + time[3]*600 + time[4]*60 + time[6]*10 + time[7]*1;
                time_in_ms = time_in_ms * 1000;
                time = time_in_ms.toString() + " ms";
            }
        }
        log("Cancel Ad Scheduled at "+time.toString());
        schedule.cancelScheduledAd(time);
    }
    
    /**
    *This Function will cancel the next ad from playing.
    * If the next ad is preroll, it will cancel the remaining preroll.
    * If the next ad is midroll, it will cancel that particular midroll.
    * If the next ad is postroll, it will cancel the entire postroll.
    **/
    var cancelNextScheduledAd = function () {
        log("cancelNextScheduledAd");
        schedule.cancelNextScheduledAd();
    }
    
    
    //Immediately plays the first ad break found in a given VAST or VMAP. Stops everything else. This is intended to allow playback without the presence of content.
    var playAdImmediately = function (input) {
        log("playAdImmediately");
        
        if (input === "" || typeof input !== "string"){
                throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a string format. It can't be set.");
        }
        bufferStandaloneAd(input);
        playBufferedStandaloneAd();
    };

    var bufferStandaloneAd = function (input) {
        log("bufferStandaloneAd");

        if (typeof input !== "string")
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"invalid Key");

        schedule.insertAdBreak(input, {
            firstBreakOnly: true,
            time: "end",
        });
        schedule.whenReady(bufferStandaloneAdPartTwo);
    };

    var bufferStandaloneAdPartTwo = function () {
        log("bufferStandaloneAdPartTwo");
        var adbreak = schedule.getNextUnplayedPostroll();
        if (!adbreak) {
            error("Couldn't find a standalone ad to buffer");
            return;
        }

        var nextAd = adbreak.getNextAd(); 
        if (!nextAd) {
            error("Couldn't find a standalone ad to buffer");
            return;
        }
        tryBufferingAd(adbreak, nextAd);
        //log("Buffered standalone ad: " + nextAd);
    };

    var playBufferedStandaloneAd = function () {
        log("playBufferedStandaloneAd");
        schedule.whenReady(endPlayback);
    };

    //Starts playback of previously initialized schedule/content.
    var startPlayback = function (playhead) {
        log("startPlayback. playhead : " + playhead);
        if(typeof playhead === "undefined") {
            log("startPLayback. playhead : 0");
            state.currentContentPlayhead(0);
        }
        else if (typeof playhead === "number" && !isNaN(playhead)) {
            state.currentContentPlayhead(playhead); //Save the playhead so when we resume, it starts there
        }
        else 
        {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR', + playhead + " is not an appropriate format or value.");
        }

        schedule.whenReady(startPlaybackHelper); //Waits for the schedule to be ready initializing its VAST/VMAP.
    };

    //Plays the prerolls, then plays the VOD. Uses callback function techniques to accomplish this.
    var startPlaybackHelper = function () {
        log("startPlaybackHelper");

        schedule.startAt(state.currentContentPlayhead());
        var adBreakToBePlayedFirst = schedule.getNextUnplayedPreroll();
        //Disable Ad Insertion logic
        if (adBreakToBePlayedFirst && adfw.Config.get("DISABLE_AD_INSERTION") === true) {
            adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                message: "Skipping ad break: Ad insertion has been disabled"
            });
            adBreakToBePlayedFirst.setSkipped();
            adBreakToBePlayedFirst = null;
        }

        if (adBreakToBePlayedFirst) {
            //Play prerolls first, then come back to this function

            if (adBreakToBePlayedFirst.isLinear()) {
                state.currentPlaybackType(adfw.PlaybackState.PlaybackType.LINEAR_AD);
                adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TYPE, {
                    type: "preroll"
                });
            }

            playAdBreak(adBreakToBePlayedFirst, startPlayback);
            checkRepeatingAdBreak(adBreakToBePlayedFirst, 0);


        } else {
            //Start playback, no more prerolls to be displayed
            playOrResumeContent();
        }
    };

    //Called at the end of the Content rendering - the correct time to play postrolls.
    var endPlayback = function () {
        log("endPlayback");
        state.currentContentVideoUrl(null);
        var adBreakToBePlayedFirst = schedule.getNextUnplayedPostroll();

        //Disable Ad Insertion logic
        if (adBreakToBePlayedFirst && adfw.Config.get("DISABLE_AD_INSERTION") === true) {
            adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                message: "Skipping ad break: Ad insertion has been disabled"
            });
            adBreakToBePlayedFirst.setSkipped();
            adBreakToBePlayedFirst = null;
        }

        if (adBreakToBePlayedFirst) {
            //Play postrolls first, then come back to this function

            var isLinear = adBreakToBePlayedFirst.isLinear();
            if (isLinear) {
                state.currentPlaybackType(adfw.PlaybackState.PlaybackType.LINEAR_AD);
            }

            if (isLinear) {
                adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TYPE, {
                    type: "postroll"
                });
            }

            /*if (isLinear && disableContentControl) {
                playAdBreak(adBreakToBePlayedFirst, endPlayback);
            }
            else {*/
                playAdBreak(adBreakToBePlayedFirst, endPlayback);
            //}  //both path call the same


        } else {
            //Stop playback, no more postrolls to be displayed
            resetState();
            if (!disableContentControl) {
                stop();
            }
            adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TYPE, {
                type: "none"
            });
            adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_COMPLETE, {});
        }
    };

    //Stops video playback cold, but does NOT reset the state of the ad framework. Content can be resumed.
    //Used before a NonLinear VPAID ad switches to Linear mode.
    var processVPAIDLinearityChange = function (evt, params) {
    	log("processVPAIDLinearityChange");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD &&
            params.isLinear === false) {
            //adLinear is false, resume the content.
            if (state.currentAdBreak() && state.currentAdBreak.getNextAd()) {
                //There's more ads after this one, so we cannot drop down to nonlinear mode w/content. Sorry VPAID ad, you have to die.
                log("Stopping VPAID ad: Unable to accommodate dropdown to NonLinear mode");
                params.wrapper.stopAd()
                    .then(function () {
                        log("Resuming ad break after killing VPAID...");
                        playAdBreak(state.currentAdBreak());
                    });
            } else {
                //There are no more ads after this one, so we can drop down to nonlinear mode while playing content.
                log("Resuming content from VPAID Linear (dropdown to VPAID NonLinear mode)");
                adfw.VisualOverlay.VPAIDStopAllVideo();
                playOrResumeContent();
            }
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT &&
            params.isLinear === true) {
            //Stop the content
            log("VPAID click-to-linear detected. Stopping SEF video...");
            state.switchToLinearAdMode(params.wrapper.getInternalAd(), params.wrapper.getInternalCreative());
            state.currentVideoUrl(null);
            player.stop();
            state.hasHaltedForVPAID(true);
        } else {
            var linearString = params.isLinear ? "linear" : "nonlinear";
            error("Invalid VPAID linearity change to " + linearString + " while playback type is " + state.currentPlaybackType());
        }
    }

    //Stops video playback cold. Will reset the state of the ad framework.
    var stop = function () {
        log("stop");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            if (state.currentLinearCreative()) {
                log("Ad forced to close due to STOP command");
                onLinearAdClose();
            }
            adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_END, {});
            adfw.Events.dispatchEvent(adfw.Events.ADBREAK_END, {});
            player.stop();
            player.cancelBufferedVideo();
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            player.stop();
            player.cancelBufferedVideo();
        }
        if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
            adfw.Events.removeListener(adfw.Events.VPAID_COMPLETE);
            adfw.Events.removeListener(adfw.Events.VPAID_ERROR);
            adfw.VisualOverlay.VPAIDWrapper.stopAd();
            log("Stopped VPAID");
        }
        resetState();
    };

    //This does exactly what you expect it to.
    var pause = function () {
    	log("pause");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.STOPPED) {
            log("currently stopped; aborting pause...");
            return;
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdPause();
            if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
                adfw.VisualOverlay.VPAIDWrapper.pauseAd();
            }
            else {
                player.pause();
            }
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            if (!disableContentControl) {
                player.pause();
            }
        }
    };

    //This does exactly what you expect it to.
    var resume = function () {
    	log("resume");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.STOPPED) {
            log("currently stopped; aborting resume...");
            return;
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdResume();
            if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
                adfw.VisualOverlay.VPAIDWrapper.resumeAd();
            }
            else {
                player.resume();
            }
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            if (!disableContentControl) {
                player.resume();
            }
        }
    };

    //Skipping forward behaves differently between ads and content.
    //In Content, it simply forwards the number of seconds specified.
    //In Ad mode, it cannot fast forward, unless the current linear ad is skippable. Then it skips the whole ad.
    var jumpForward = function (seconds) {
    	log("jumpForward");
        if (seconds === undefined || typeof seconds !== 'number') {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',seconds + " is not a number; aborting jump");
        }
        var ms = Math.round(seconds * 1000);
        log("jumpForward: " + ms);
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.STOPPED) {
            log("currently stopped; aborting jumpForward...");
            return;
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD && adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
            //Check the VPAID wrapper for skippability
            adfw.VisualOverlay.VPAIDWrapper.skipAd();
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            //OK check the LinearCreative for skippability
            if (state.currentLinearCreative().isSkippable() && state.currentLinearCreative().canSkipNow(state.currentAdPlayhead(), getDuration())) {
                log("Ad skipped");
                onLinearAdSkip();
                player.stop();
                state.currentLinearAd().setSkipped();
                if (typeof currentAdCallback === "function") {
                    currentAdCallback();
                }
            } else {
                if (adfw.Config.get("DEBUG_ENABLE_ILLEGAL_AD_SKIP") === true) {
                    //Debug only
                    log("NONSKIPPABLE LINEAR CREATIVE: You shouldn't be able to jumpForward() because a linear ad is playing, but I'll allow it for debug purposes.");
                    player.stop();
                    if (typeof currentAdCallback === "function") {
                        currentAdCallback();
                    }
                }
                else {
                    log("Aborting jump forward since we are not allowed to do that during ads");
                    return;
                }

            }
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {

            //advance the schedule
            var skipUpTo = state.currentContentPlayhead() + ms;
            schedule.skipUpTo(skipUpTo, getDuration());

            //jumps must cancel any prebuffered video for safety
            player.cancelBufferedVideo();

            if (!disableContentControl) {
                player.jumpForward(ms);
            }
        }
    };

    //This does exactly what you expect it to - go back in time on the current video for X number of seconds.
    var jumpBackward = function (seconds) {
    	log("jumpBackward");
        if (seconds === undefined || typeof seconds !== 'number') {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',seconds + " is not a number; aborting jump");
        }
        var ms = Math.round(seconds * 1000);
        log("jumpBackward: " + ms);
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.STOPPED) {
            log("currently stopped; aborting jumpBackward...");
            return;
        }
        //jumps must cancel any prebuffered video for safety
        player.cancelBufferedVideo();

        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdRewind();
            player.jumpBackward(ms);
        } else if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            schedule.skipBackTo(state.currentContentPlayhead() - ms, getDuration());
            if (!disableContentControl) {
                player.jumpBackward(ms);
            }
        }
    };

    //Offset the content playhead by N seconds. If currently playing item is CONTENT, just jumpForward. If currently playing item is AD, then change the content playhead for when the resume happens.
    var offsetContentPlayhead = function (ms) {
	log("offsetContentPlayhead : " + ms);
        if (ms === undefined  || typeof ms !== 'number') {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',ms + " is not a number; aborting offsetContentPlayhead");
        }

        var currentContentPlayhead = state.currentContentPlayhead();

        if (typeof(currentContentPlayhead) !== "number") {
            currentContentPlayhead = 0;
        }

        currentContentPlayhead += ms;
        setContentPlayhead(currentContentPlayhead);
    };

    //An alternative to FF/RW
    var setContentPlayhead = function (ms) {
    	log("setContentPlayhead : " + ms);
        if (typeof ms !== "number") {
            throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',ms + " is not a number; aborting setContentPlayhead");
        }
        log("setContentPlayhead: " + ms);
        var oldContentPlayhead = state.currentContentPlayhead();

        if (typeof(oldContentPlayhead) !== "number") {
            oldContentPlayhead = 0;
        }
        var diff = ms - oldContentPlayhead;
        var diffSec = Math.round(diff / 1000);
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            if (diffSec > 0) {
                jumpForward(diffSec);
            }
            else {
                jumpBackward(Math.abs(diffSec));
            }
        }
        else {
            state.currentContentPlayhead(ms);
        }
    };

    //While "trickplay" is active on the content, midrolls will NOT be triggered as normal
    var signalTrickPlayStart = function () {
        log("trick play start!");
        state.isTrickPlaying(true);
    };

    //When trickplay ends, adbreaks should play as defined by Config.FF_MIDROLL_BEHAVIOR
    var signalTrickPlayStop = function () {
        log("trick play stop!");
        if (state.isTrickPlaying()) {
            schedule.skipUpTo(state.currentContentPlayhead());
        }
        state.isTrickPlaying(false);
    };

    //This function allows app developer to signal mute/unmute (it does not affect TV mute state, only fires tracking events)
    var signalMuted = function (ms, dur) {
        log("signalMuted");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdMute();
        }
    };

    //This function allows app developer to signal mute/unmute (it does not affect TV mute state, only fires tracking events)
    var signalUnmuted = function (ms, dur) {
        log("signalUnmuted");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD) {
            onLinearAdUnmute();
        }
    };

    //This function is only for when content control is disabled - in that case, the app is expected to send the playback time so ad framework can keep its schedule
    var signalContentPlaybackTime = function (ms, dur) {
        log("signalContentPlaybackTime");
        if (disableContentControl && state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT && !contentStopDeferred.promise.isPending()) {
            mockContentDuration = parseInt(dur, 10);
            internalOnCurrentPlaytime(adfw.PlayerAdapter.Events.CURRENT_PLAYBACK_TIME, {
                ms: ms,
                duration: dur,
            }, true);
        }
        else {
            //error("bad call to signalContentPlaybackTime; disableContentControl=" + disableContentControl + "currentPlaybackType=" + state.currentPlaybackType() + " | stopPromise=" + contentStopPromise.isDone());
        }
    };

    //This function is only for when content control is disabled - in that case, the app is expected to send the content end event so ad framework can play its postrolls
    var signalContentPlaybackComplete = function () {
        log("signalContentPlaybackComplete and current playback type is: " + state.currentPlaybackType());
        if (disableContentControl && state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            endPlayback();
        }
    };

    //This function is only for when content control is disabled - in that case, the app is expected to receive the LINEAR_AD_START event and notify the ad framework that it has stopped the content and is ready for the ad.
    var signalContentStopped = function () {
        log("signalContentStopped");
        //log("signalContentStopped: " + contentStopPromise.status());
        if (disableContentControl && typeof(contentStopDeferred === "object")) {
            contentStopDeferred.resolve();
            return contentStopDeferred.promise;
        }
    };

    var handleIFrameOpen = function () {
        log("IFRAME OPEN, Suspending video...");
        /*if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD && state.currentLinearAd()) {
            player.stop();
            state.currentVideoUrl(null);
        }
        else {*/
            player.stop();
            state.currentVideoUrl(null);
        //}  // both the paths are same
    };

    var handleIFrameClose = function () {
        log("IFRAME CLOSE, Resuming video...");
        if (state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD && state.currentLinearAd()) {
            player.play(state.currentLinearAd().getOptimalMediaFile().getFixedUrl(), state.currentAdPlayhead());
        }
        else {
            playOrResumeContent();
        }
    };

    //*******************************************************************************************************
    //AD LOGIC

    //Takes an adbreak object and plays the ads within.
    var playAdBreak = function (adbreak, callback) {
        try {
            log("playAdBreak: hasTriedToResolve?" + adbreak.hasTriedToResolve() + " | isResolved?" + adbreak.isResolved() + " | isLinear?" + adbreak.isLinear());
            if (!adbreak.isResolved()) {
                log("Adbreak hasn't resolved yet - will wait for it to finish");
                adbreak.whenReady(function () {
                    if (!adbreak.isPlayed()) {
                        playAdBreak(adbreak, callback);
                    }
                });
                adbreak.resolve();
                return;
            }
            if (!adbreak.isPlayed()) {
                adbreak.setPlayed();
                adfw.Events.dispatchEvent(adfw.Events.ADBREAK_START, {
                    triggerTime: adbreak.getOffset().getTriggerMS(),
                    extensions: adbreak._extensions.local,
                    globalExtensions: adbreak._extensions.global,
                    adbreak: adbreak,
                    isLinear: adbreak.isLinear(),
                    linearDuration: adbreak.getLinearDuration(),
                    linearAdCount: adbreak.getLinearAdCount()
                });
            }

            state.currentAdBreak(adbreak);
            onAdBreakStart();

            var nextAd = adbreak.getNextAd();

            //Figure out how much time has really passed since the start of the adbreak
            if (!adbreak.getStartTime()) {
                //Save the start time if we haven't yet...
                adbreak.setStartTime(new Date());
            } else {
                //Check if the actual adbreak duration is longer than the maximum
                var currentBreakDuration = new Date() - adbreak.getStartTime();
                if (nextAd && adfw.Config.get("AGGRESSIVE_DURATION_ENFORCEMENT") === true && (currentBreakDuration > (adfw.Config.get("MAXIMUM_ADBREAK_DURATION") - 3000))) {
                    log("Aggressively ending adbreak. Max duration reached: " + currentBreakDuration + "/" + adfw.Config.get("MAXIMUM_ADBREAK_DURATION"));
                    handleVSuitePlaybackError(state.currentAdBreak(), nextAd, 400, "Stopping ad: Maximum allowed adbreak duration of " + (adfw.Config.get("MAXIMUM_ADBREAK_DURATION") / 1000) + "s has been exceeded, and is being enforced aggressively", state.currentContentPlayhead(), nextAd.getLinearCreative().getOptimalMediaFile().getUrl());
                    nextAd = null;
                }
            }

            if (nextAd) {

                var callbackFunc;
                if (nextAd.getLinearCreative()) {
                    callbackFunc = function () {
                        adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_END, {});
                        playAdBreak(adbreak, callback);
                    };
                } else {
                    callbackFunc = function () {
                        playAdBreak(adbreak, callback);
                    };
                }
                playSingleAd(nextAd, callbackFunc);
            } else {
                //adbreak.setPlayed();
                onAdBreakEnd();
                state.currentAdBreak(null);
                adfw.Events.dispatchEvent(adfw.Events.ADBREAK_END, {});
                callback();
            }
        }
        catch (e) {
            error('playAdBreak error: ' + e);
        }
    };

    //Given an ad object, tries to prebuffer its linear creative.
    var tryBufferingAd = function (adBreak, nextAd) {
        log("tryBufferingAd");
        if (!nextAd || state.currentBufferedLinearAd() === nextAd || (state.currentBufferedLinearAd() && state.currentBufferedLinearAd().isErrored()) || state.currentPreloadedNonLinearVPAIDAd() === nextAd) {
            return false;
        }
        if (!adfw.Config.get("PREBUFFER_ENABLED")) {
            return false;
        }
        //log("Buffering ad..." + nextAd);
        var linearCreative = nextAd.getLinearCreative();
        if (!linearCreative) {
            //If nextAd is not LinearAd, check if there is an nonLinear VPAID to preBuffer
            var nonlinearCreative = nextAd.getNonLinearCreative();
            var variation = null;
            if (nonlinearCreative) {
                variation = nonlinearCreative.getBestVariation();
            }
            if (variation && variation.apiFramework == 'VPAID') {
                prebufferNextNonLinearVPAIDAd(nextAd);
            }
            return false;
        }
        var mediaFile = linearCreative.getOptimalMediaFile();
        if (!mediaFile) {
            handleVSuitePlaybackError(adBreak, nextAd, 403, "Could not find a valid MediaFile", state.currentContentPlayhead(), null);
            nextAd.setErrored();
            return false;
        }
        else if (adfw.Utils.isImageMIME(mediaFile.getMIMEType())) {
            //We're not even going to try buffering images, nope!
            return false;
        }
        //Buffer VPAID
        //TODO: Cleanup
        if (mediaFile.apiFramework == 'VPAID') {
            //log("Try buffering vpaid ad...?");
            //If it's not JS, don't buffer it!
            if (!mediaFile.isJavaScript()) {
                nextAd.setErrored();
                handleVSuitePlaybackError(adBreak, nextAd, 403, "Could not Play non JS VPAID", state.currentContentPlayhead(), null);
                //log("VPAID mediafile is not JS, abort prebuffer");
                return false;
            } else if (!adfw.Config.get("VPAID_ENABLE")) {
                nextAd.setErrored();
                handleVSuitePlaybackError(adBreak, nextAd, 902, "VPAID is disabled in Ad Framework config", state.currentContentPlayhead(), null);
                //log("vpaid is disabled, abort prebuffer");
                return false;
            } else if (adfw.OrsayWebkitUtils.is2012Model()) {
                nextAd.setErrored();
                handleVSuitePlaybackError(adBreak, nextAd, 902, "VPAID not available on Samsung 2012 TV", state.currentContentPlayhead(), null);
                return false;
            } else {
                try {
                    nextAd.setPrebuffered();
                    state.currentBufferedLinearAd(nextAd);
                    state.currentBufferedLinearAdBreak(adBreak);
                    adfw.VisualOverlay.initVPAID(nextAd, 'linear');
                    //log("initVPAID has occurred");
                } catch (e) {
                    //log("vpaid prebuffer fail: " + e);
                }
            }
        }
        //Buffer Video
        else {
            var urlToBuffer = mediaFile.getFixedUrl();
            urlToBuffer = modifyUrlForStartingBitrate(mediaFile, urlToBuffer);

            //Allow the app developer to modify the linear ad Url
            var linearAdUrlModifierFunction = state.linearAdUrlModifier();
            if (typeof linearAdUrlModifierFunction === "function") {
                var modifiedUrl = linearAdUrlModifierFunction(urlToBuffer);
                if (typeof modifiedUrl === "string" && modifiedUrl.trim() && modifiedUrl !== urlToBuffer) {
                    urlToBuffer = modifiedUrl;
                }
            }

            //Execute beforeLinearAdStart() and start prebuffering
            var beforeLinearAdStartFunction = state.beforeLinearAdStart();

            player.startBufferingVideo(urlToBuffer, 0, beforeLinearAdStartFunction);
            nextAd.setPrebuffered();
            state.currentBufferedLinearAd(nextAd);
            state.currentBufferedLinearAdBreak(adBreak);
        }

        // adObject: Ad, title: String, description: String, advertiser: String, skippable: boolean, apiFramework: String , url: String, icons: Array
        adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_PREBUFFER_START, {
            adObject: nextAd,
            extensions: nextAd.extensions,
            title: nextAd.adTitle,
            description: nextAd.description,
            advertiser: nextAd.advertiser,
            skippable: linearCreative.isSkippable(),
            apiFramework: mediaFile.apiFramework,
            url: mediaFile.getUrl(),
            fixedUrl: mediaFile.getFixedUrl(),
            icons: linearCreative.getIcons()
        });
    };
    var modifyUrlForStartingBitrate = function (mediaFile, url) {
    log("modifyUrlForStartingBitrate");

        //If the MediaFile is streaming, set the StartBitrate
        var adapterType = player.getAdapterType();
        if ((adapterType === adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF) &&
            url.toLowerCase().indexOf("startbitrate" < 0) &&
            (mediaFile.getType() === adfw.LinearMediaFile.Types.HLS ||
            mediaFile.getType() === adfw.LinearMediaFile.Types.SMOOTH ||
            mediaFile.getType() === adfw.LinearMediaFile.Types.DASH)) {
            var startBitrate = adfw.Config.get("START_BITRATE");

            try {
                if (typeof startBitrate === "string" && startBitrate.toLowerCase() === "auto") {
                    if (adapterType === adfw.PlayerAdapter.AdapterType.ORSAY_WEBKIT_SEF) {
                        startBitrate = player.Execute("GetCurrentBitrates");
                        if (typeof startBitrate === "number" && startBitrate > 1000) {
                            startBitrate = Math.round(startBitrate * adfw.Config.get("START_BITRATE_AUTO_RATIO"));
                        }
                        else {
                            startBitrate = "AVERAGE";
                        }
                        url += "|STARTBITRATE=" + startBitrate;
                    }
                    else if (adapterType === adfw.PlayerAdapter.AdapterType.TIZEN_WEBKIT_AVPLAY) {
                        //startBitrate = "AVERAGE";
                        //url += "|STARTBITRATE=" + startBitrate;
                    }
                }
                else if (typeof startBitrate === "string" && startBitrate.trim()) {
                    url += "|STARTBITRATE=" + startBitrate;
                }
                else if (typeof startBitrate === "number" && startBitrate > 1000) {
                    url += "|STARTBITRATE=" + startBitrate;
                }
                return url;
            }
            catch (e) {
            }
        }
        return url;
    };

    //Plays a single ad. A single ad can have a linear creative, nonlinears, and companions.
    var playSingleAd = function (ad, callback) {
        log("playSingleAd");
        var linearCreative = ad.getLinearCreative(); //I'm assuming there can only be one
        var nonLinearCreative = ad.getNonLinearCreative(); //I'm assuming there can only be one
        var companionCreativeArray = ad.getCompanionCreativeArray();
        var companionRequirementFailed = false;
        //log("playSingleAd: " + linearCreative);

        //Sanity check: We need at eiter a linear or nonlinear creative present
        if (!linearCreative && !nonLinearCreative) {
            handleVSuitePlaybackError(state.currentAdBreak(), ad, 900, "Ad is missing both Linear and NonLinear creatives; unable to utilize ad", state.currentContentPlayhead(), null);
            ad.setErrored();
            callback();
            return false;
        }

        //CompanionCreativeArray need to be an Array since CompanionCreative can be inherited from wrapper!
        if (adfw.Config.get("COMPANION_AD_ENABLE") && companionCreativeArray.length > 0) {

            for (var i = 0; i < companionCreativeArray.length && !companionRequirementFailed; i++) {
                var companionCreative = companionCreativeArray[i];

                if (companionCreative) {
                    var companions = companionCreative.companions;
                    //Dispatch event so that these companions can be handled
                    adfw.Events.dispatchEvent(adfw.Events.COMPANION_ADS_CREATIVE_DETECTED, {
                        companionCreative: companionCreative,
                        ad_uid: ad.uid
                    });

                    //Check CompanionAds Require Condition [all,any,none]
                    var companionRequiredAttr = companionCreative.getRequired() || "";
                    var hasSkipped = false;
                    var hasAccepted = false;
                    for (var j = 0; j < companions.length; j++) {
                        if (true === companions[j].isShowed()) {
                            hasAccepted = true;
                            companions[j].handleEvent("creativeView",
                                state.currentAdPlayhead(), getDuration(),
                                state.currentContentPlayhead(),
                                companions[j].getAssetURI()
                            );
                        } else {
                            hasSkipped = true;
                        }
                    }
                    //Making Sure all companions are showed
                    if (companionRequiredAttr == "all" && hasSkipped) {
                        adfw.Events.dispatchEvent(adfw.Events.COMPANION_AD_FAILED_REQUIRED_ALL);
                        companionRequirementFailed = true;
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 602, "Rejected ad: Companion REQUIRED=ALL condition failed", state.currentContentPlayhead(), companionCreative.companions[i].getAssetURI());
                        //Making Sure at least one companions is showed
                    } else if (companionRequiredAttr == "any" && !hasAccepted) {
                        adfw.Events.dispatchEvent(adfw.Events.COMPANION_AD_FAILED_REQUIRED_ANY);
                        companionRequirementFailed = true;
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 602, "Rejected ad: Companion REQUIRED=ANY condition failed", state.currentContentPlayhead(), companionCreative.companions[i].getAssetURI());
                    }
                }
            }
        }

        if (nonLinearCreative && !companionRequirementFailed) {
            var variation = nonLinearCreative.getBestVariation();

            if (variation) {

                /** If VPAID, make sure only JS VPAID will be played */
                if (variation.apiFramework == 'VPAID') {
                    if (!adfw.VisualOverlay) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "This platform is not capable of displaying VPAID ads", state.currentContentPlayhead(), null);
                    }
                    else if (!adfw.Config.get("VPAID_ENABLE")) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "Ad framework was disabled to Play VPAID [Check config]", state.currentContentPlayhead(), null);
                    } else if (variation.getType() != adfw.NonLinearResource.ResourceType.STATIC_JS) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 403, "Could not Play non JS VPAID", state.currentContentPlayhead(), null);
                    } else if (adfw.OrsayWebkitUtils.is2012Model()) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "VPAID is not compatible with 2012 Samsung TVs", state.currentContentPlayhead(), null);
                    } else {
                        //log("Queueing VPAID NonLinear...");
                        state.currentNonLinearAd(ad); //Queue the ad holding the nonlinear creative
                        state.currentNonLinearAdBreak(state.currentAdBreak()); //Save the adbreak holding the nonlinear creative so that we can fire tracking events
                        state.currentNonLinearAdisVPAID = true;

                        listenForVPAIDDone(function () {
                            if (state.hasHaltedForVPAID()) {
                                state.hasHaltedForVPAID(false);
                                playOrResumeContent();
                            }
                        }, ad);
                        ad.setPlayed();
                    }
                } else {
                    //log("Queueing Linear ad...");
                    state.currentNonLinearAdisVPAID = false;
                    state.currentNonLinearAd(ad); //Queue the ad holding the nonlinear creative
                    state.currentNonLinearAdBreak(state.currentAdBreak()); //Save the adbreak holding the nonlinear creative so that we can fire tracking events
                    ad.setPlayed();
                }
            } else {
                //TODO: Error because we couldn't find a suitable variation...?
            }
        }
        if (linearCreative && !companionRequirementFailed) {

            var mediaFile = linearCreative.getOptimalMediaFile();
            //log("Playing Linear: " + mediaFile.getUrl());

            //We need to close any active NonLinear VPAID ads (regular NonLinears will close by themselves, but VPAID needs a little help)
            if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
                adfw.VisualOverlay.VPAIDWrapper.stopAd();
            }

            if (!mediaFile) {
                ad.setErrored();
                handleVSuitePlaybackError(state.currentAdBreak(), ad, 403, "Could not find a valid MediaFile", state.currentContentPlayhead(), null);
                callback();
                return;
            } else {
                setLinearAdMode(ad, linearCreative, callback);
                //check if VPAID
                if (mediaFile.apiFramework == 'VPAID') {
                    if (!adfw.VisualOverlay) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "This platform is not capable of displaying VPAID ads", state.currentContentPlayhead(), null);
                        callback();
                        return;
                    }
                    if (!adfw.Config.get("VPAID_ENABLE")) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "VPAID is disabled in ad framework config", state.currentContentPlayhead(), null);
                        callback();
                        return;
                    }
                    /** Make sure only JS VPAID will be played */
                    if (!mediaFile.isJavaScript()) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 403, "Could not Play non-JS VPAID", state.currentContentPlayhead(), null);
                        callback();
                        return;
                    }
                    if (adfw.OrsayWebkitUtils.is2012Model()) {
                        ad.setErrored();
                        handleVSuitePlaybackError(state.currentAdBreak(), ad, 902, "VPAID is not compatible with 2012 Samsung TVs", state.currentContentPlayhead(), null);
                        callback();
                        return false;
                    }

                    //Check VPAID prebuffered?
                    if (adfw.VisualOverlay.bufferingVPAIDObj && ad === adfw.VisualOverlay.bufferingVPAIDObj.ad && true === adfw.VisualOverlay.bufferingVPAIDObj.isPrebuffered) {
                        log("Play prebuffered VPAID: " + ad.uid);
                        adfw.VisualOverlay.startVPAID();
                    } else {
                        log("Play unbuffered VPAID: " + ad.uid);
                        adfw.VisualOverlay.initVPAID(ad, 'linear');
                        adfw.VisualOverlay.startVPAID()
                            .catch(function (err) {
                                log("VPAID FAILURE: " + err);
                                ad.setErrored();
                                handleVSuitePlaybackError(state.currentAdBreak(), ad, 901, ("General VPAID Error: " + err), state.currentContentPlayhead(), null);
                                callback();
                            });
                    }

                    //Dispatch LINEAR_AD_START event
                    var vpaidSkippable = null;
                    if (adfw.VisualOverlay.currentVPAIDObj && adfw.VisualOverlay.currentVPAIDObj.VPAIDWrapper) {
                        vpaidSkippable = adfw.VisualOverlay.currentVPAIDObj.VPAIDWrapper.getAdSkippableState();
                    }
                    adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_START, {
                        adObject: ad,
                        extensions: ad.extensions,
                        title: ad.adTitle,
                        description: ad.description,
                        advertiser: ad.advertiser,
                        skippable: vpaidSkippable,
                        apiFramework: mediaFile.apiFramework,
                        url: mediaFile.getUrl(),
                        fixedUrl: mediaFile.getFixedUrl(),
                        icons: null
                    });

                    //Callback when the VPAID is finished
                    listenForVPAIDDone(function () {
                        callback();
                    }, ad);
                } else if (adfw.Utils.isImageMIME(mediaFile.getMIMEType())) {
                    //If it's an image, we don't support it.
                    ad.setErrored();
                    handleVSuitePlaybackError(state.currentAdBreak(), ad, 403, "Linear Image MIME types not supported", state.currentContentPlayhead(), null);
                    callback();
                    return;
                } else {
                    //If it's a video, play it
                    //log("Attempting to play video: " + mediaFile.getUrl());
                    state.currentVideoUrl(mediaFile.getUrl()); //Record current state
                    var icons = linearCreative.getIcons();
                    //Sets a timeout for linear resource retrieval. If playback does not begin within the specified time, the linear ad will be aborted.
                    //If a timeout has occurred within the last 60 seconds, the timeout value is changed to another number.
                    setLinearAdTimeout();
                    if (player.getBufferedVideoUrl() && state.currentBufferedLinearAd() === ad) {
                        state.currentBufferedLinearAd(null);
                        state.currentBufferedLinearAdBreak(null);
                        player.playBufferedVideo();

                        adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_START, {
                            adObject: ad,
                            extensions: ad.extensions,
                            title: ad.adTitle,
                            description: ad.description,
                            advertiser: ad.advertiser,
                            skippable: linearCreative.isSkippable(),
                            apiFramework: mediaFile.apiFramework,
                            url: mediaFile.getUrl(),
                            fixedUrl: mediaFile.getFixedUrl(),
                            icons: icons
                        });
                        log("Playing buffered linear ad: " + player.getBufferedVideoUrl());
                    } else {
                        var urlToPlay = mediaFile.getFixedUrl();
                        urlToPlay = modifyUrlForStartingBitrate(mediaFile, urlToPlay);

                        //Allow the app developer to modify the linear ad Url
                        var linearAdUrlModifierFunction = state.linearAdUrlModifier();
                        if (typeof linearAdUrlModifierFunction === "function") {
                            var modifiedUrl = linearAdUrlModifierFunction(urlToPlay);
                            if (typeof modifiedUrl === "string" && modifiedUrl.trim() && modifiedUrl !== urlToPlay) {
                                urlToPlay = modifiedUrl;
                            }
                        }

                        ////If the MediaFile is streaming, set the StartBitrate
                        //if (adfw.OrsayWebkitUtils.isInfolink() && urlToPlay.toLowerCase().indexOf("startbitrate" < 0) && (mediaFile.getType() === adfw.LinearMediaFile.Types.HLS ||
                        //    mediaFile.getType() === adfw.LinearMediaFile.Types.SMOOTH ||
                        //    mediaFile.getType() === adfw.LinearMediaFile.Types.DASH)) {
                        //    var startBitrate = adfw.Config.get("START_BITRATE");
                        //
                        //    if (typeof startBitrate === "string" && startBitrate.toLowerCase() === "auto") {
                        //        startBitrate = player.Execute("GetCurrentBitrates");
                        //        if (typeof startBitrate === "number" && startBitrate > 1000) {
                        //            startBitrate = Math.round(startBitrate * adfw.Config.get("START_BITRATE_AUTO_RATIO"));
                        //        }
                        //    }
                        //
                        //    if (typeof startBitrate === "number" && startBitrate > 1000) {
                        //        urlToPlay += "|STARTBITRATE=" + startBitrate;
                        //    }
                        //}

                        try {
                            log("Playing unbuffered linear ad: " + urlToPlay);
                            //player.stop();
                            player.initPlayer(urlToPlay);
                            var beforeLinearAdStartFunction = state.beforeLinearAdStart();
                            if (typeof beforeLinearAdStartFunction === "function") {
                                try {
                                    beforeLinearAdStartFunction(player.getInternalPlayer());
                                }
                                catch (e) {
                                    error('beforeLinearAdStartFunction error: ' + e);
                                    error(beforeLinearAdStartFunction);
                                }
                            }
                            player.startPlayback();

                            adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_START, {
                                adObject: ad,
                                extensions: ad.extensions,
                                title: ad.adTitle,
                                description: ad.description,
                                advertiser: ad.advertiser,
                                skippable: linearCreative.isSkippable(),
                                apiFramework: mediaFile.apiFramework,
                                url: mediaFile.getUrl(),
                                fixedUrl: mediaFile.getFixedUrl(),
                                icons: icons
                            });
                        }
                        catch (e) {
                            error("Error while attempting to play ad: " + e);
                            error(adfw.Utils.getInspectionString(e));
                        }
                    }
                }
                ad.setPlayed();
            }
        } else {
            //No linear to play, all done, so callback immediately
            callback();
        }
    };

    var setLinearAdTimeout = function () {
        log("setLinearAdTimeout");
        var timeOutValue = adfw.Config.get("LINEAR_RESOURCE_TIMEOUT");
        if (state.linearAdHasRecentlyTimedOut()) {
            timeOutValue = Math.min(adfw.Config.get("LINEAR_RESOURCE_TIMEOUT"), adfw.Config.get("LINEAR_RESOURCE_REPEAT_TIMEOUT"));
        }
        if (timeOutValue > 1000) {
            state.linearAdTimeout(setTimeout(linearAdTimeoutHelper, timeOutValue));
        }
    };
    var clearLinearAdTimeout = function () {
        log("clearLinearAdTimeout");
        if (state.linearAdTimeout()) {
            //log("Cleared linear ad timeout");
            clearTimeout(state.linearAdTimeout());
            state.linearAdTimeout(null);
        }
    };

    //If we are waiting more than LINEAR_RESOURCE_TIMEOUT for the linear ad, we need to error out and move on.
    var linearAdTimeoutHelper = function () {
        log("linearAdTimeoutHelper");
        clearLinearAdTimeout();
        if (!state.currentLinearAd()) {
            error("Linear Ad timeout called, but there is no ad playing");
            return false;
        }
        error("Linear Ad Timeout: " + state.currentLinearAd().getLinearCreative().getOptimalMediaFile().getUrl());

        //Fake a CONNECTION_FAILED event to force the ad framework to move on
        state.linearAdHasRecentlyTimedOut(true);
        internalOnActivePlayerProblem(adfw.PlayerAdapter.Events.CONNECTION_FAILED, {
            message: 'Linear ad timed out (failed to start playback within the time limit)'
        });
    };

    //Called at the beginning of ad playback - sets some internal state, and most importantly, keeps track of what to do when the ad is finished (the callback).
    var setLinearAdMode = function (ad, linearCreative, callback) {
        log("setLinearAdMode");
        state.switchToLinearAdMode(ad, linearCreative); //Milliseconds we are into the current video (ad or content)
        if (linearCreative.getOptimalMediaFile()) {
            state.currentVideoUrl(linearCreative.getOptimalMediaFile().getFixedUrl());
        }
        currentAdCallback = callback;
    };

    //Handles current playback time updates for ads. This is a complex function, as it has to handle prebuffering, fire events, and check a lot of other stuff.
    var adOnCurrentPlaytime = function (playtime) {

        //log("Ad Playtime: " + playtime + " / " + getDuration());

        state.currentAdPlayhead(playtime);
        adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TIME, {
            ms: playtime
        });
        var params = {};
        params.ms = playtime;
        if (state.currentLinearCreative() && state.currentLinearCreative().isSkippable()) {
            var skipMS = state.currentLinearCreative().getSkipMS(playtime, getDuration());
            params.secondsUntilSkippable = Math.ceil((skipMS - state.currentAdPlayhead()) / 1000);
        }
        //log("Seconds until skippable: " + params.secondsUntilSkippable);
        adfw.Events.dispatchEvent(adfw.Events.AD_PLAYBACK_TIME, params);

        if (playtime !== 0) {
            // HTML5 player sends playtime 0 even if fake media url provided. This causes issues with ad timeout logic.
            onLinearAdProgress(state.currentAdPlayhead(), getDuration());
        }

        //Check if we've gone over the alloted adbreak time. If so, end the adbreak immediately.
        if (adfw.Config.get("AGGRESSIVE_DURATION_ENFORCEMENT") === true) {
            var adbreakCalculatedDuration = new Date() - state.currentAdBreak().getStartTime();
            if (adbreakCalculatedDuration > (adfw.Config.get("MAXIMUM_ADBREAK_DURATION") + adfw.Config.get("AGGRESSIVE_DURATION_ENFORCEMENT_CUSHION"))) {
                log("Aggressively ending adbreak. Max duration reached: " + adbreakCalculatedDuration + "/" + adfw.Config.get("MAXIMUM_ADBREAK_DURATION") + " (with " + adfw.Config.get("AGGRESSIVE_DURATION_ENFORCEMENT_CUSHION") + "ms of cushion)");
                player.stop();
                handleVSuitePlaybackError(state.currentAdBreak(), state.currentLinearAd(), 400, "Stopping ad: Maximum allowed adbreak duration of " + (adfw.Config.get("MAXIMUM_ADBREAK_DURATION") / 1000) + "s has been exceeded, and is being enforced aggressively", state.currentContentPlayhead(), state.currentLinearAd().getLinearCreative().getOptimalMediaFile().getUrl());
                currentAdCallback();
                return; //Skip prebuffering
            } else {
            }
        }

        //Prebuffering: don't do it if VPAID is next, otherwise, prebuffer
        if (!adfw.VisualOverlay || (!adfw.VisualOverlay.bufferingVPAIDObj || 'linear' !== adfw.VisualOverlay.bufferingVPAIDObj.VPAIDType)) {
            if ((getDuration() - playtime) < adfw.Config.get("AD_PREBUFFER_ADVANCE_TIME")) {
                var nextAd = state.currentAdBreak() ? state.currentAdBreak().getNextAd() : null;
                if (nextAd) {
                    tryBufferingAd(state.currentAdBreak(), nextAd);
                } else {
                    tryBufferingContent();
                }
            }
        }
    };

    var prebufferingForVPaid = function () {
        log("prebufferingForVPaid");
        var nextAd = state.currentAdBreak() ? state.currentAdBreak().getNextAd() : null;
        if (nextAd) {
            tryBufferingAd(state.currentAdBreak(), nextAd);
        } else {
            tryBufferingContent();
        }
    };

    var prebufferNextNonLinearVPAIDAd = function (nextAd) {
        log("prebufferNextNonLinearVPAIDAd");
        if (!adfw.VisualOverlay) {
            return false;
        }
        state.currentPreloadedNonLinearVPAIDAd(nextAd);
        adfw.VisualOverlay.initVPAID(nextAd, 'nonlinear');
    };
    //Displays the queued NonLinearCreative
    var playNonLinearAd = function () {
        log("playNonLinearAd");
        if (!adfw.VisualOverlay) {
            return false;
        }

        var nonLinearAd = state.currentNonLinearAd();
        var parentAdBreak = state.currentNonLinearAdBreak();
        state.currentNonLinearAd(null); //Dequeue the NonLinear
        state.currentNonLinearAdBreak(null); //Dequeue the Ad Break
        state.currentPreloadedNonLinearVPAIDAd(null);

        if (typeof state.currentNonLinearAdisVPAID !== 'undefined' && state.currentNonLinearAdisVPAID) {
            if (!adfw.VisualOverlay.bufferingVPAIDObj || nonLinearAd !== adfw.VisualOverlay.bufferingVPAIDObj.ad) {
                adfw.VisualOverlay.initVPAID(nonLinearAd, 'nonlinear');
            }
            adfw.VisualOverlay.startVPAID();
        } else {
            //All tracking events will be handled by VisualOverlay
            adfw.VisualOverlay.showNonLinearAd(parentAdBreak, nonLinearAd);
        }
    };

    //Returns a list of all adbreak times for the current content video
    //Null if content is not ready yet
    var getAdBreakTimes = function () {
        log("getAdBreakTimes");
        var breakTimes = [];
        var duration = getDuration();
        if (getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT && typeof(duration) === "number" && duration > 1) {
            breakTimes = schedule.getAdBreakTimes(duration);
        }
        else {
            breakTimes = schedule.getAdBreakTimes();
        }
        if(0===breakTimes.length)
        {
            return null;
        }
        else
        {
            return breakTimes;
        }
    };

    var getPlayableAdBreakTimes = function () {
        log("getPlayableAdBreakTimes");
        var breakTimes = [];
        var duration = getDuration();
        if (getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT && typeof(duration) === "number" && duration > 1) {
            breakTimes = schedule.getPlayableAdBreakTimes(duration);
        }
        else {
            breakTimes = schedule.getPlayableAdBreakTimes();
        }
        if(0===breakTimes.length)
        {
            return null;
        }
        else
        {
            return breakTimes;
        }
    };

    //*******************************************************************************************************
    //CONTENT LOGIC

    //Changes callbacks and player mode to be playing ads

    //Usually called at the beginning of playback or after an adbreak ends. It resumes the content at its previously recorded playhead.
    var playOrResumeContent = function () {
        //Stop if we're already playing content or have ended playback
        log("playOrResumeContent: curContent=" + state.currentContentVideoUrl() + " curVid=" + state.currentVideoUrl());

        if (state.currentContentVideoUrl() === state.currentVideoUrl()) {
            return;
        }
        if (!state.currentContentVideoUrl()) {
            endPlayback();
            return;
        }
        state.switchToContentMode();
        currentAdCallback = null;
        alreadyTriedToBufferContent = false;

        state.currentVideoUrl(state.currentContentVideoUrl());
        var resumeTime = state.currentContentPlayhead() ? Math.max(state.currentContentPlayhead() - (adfw.Config.get("REWIND_BEFORE_RESUME") * 1000), 0) : 0;

        try {
            if (!disableContentControl) {
                if (player.getBufferedVideoUrl()) {
                    log("playOrResumeContent: playBufferedVideo = " + player.getBufferedVideoUrl() + " | resumeTime = " + resumeTime);
                    player.playBufferedVideo();
                } else {
                    //player.stop();
                    player.initPlayer(state.currentContentVideoUrl());
                    var beforeContentStartFunction = state.beforeContentStart();
                    if (typeof beforeContentStartFunction === "function") {
                        try {
                            beforeContentStartFunction(player.getInternalPlayer());
                        }
                        catch (e) {
                            error('beforeContentStartFunction error: ' + e);
                            error(beforeContentStartFunction);
                        }
                    }
                    if (resumeTime && resumeTime > 0) {
                        log("playOrResumeContent (unbuffered): resume = " + resumeTime + " | " + state.currentContentVideoUrl());
                        player.startPlayback(resumeTime);
                    } else {
                        log("playOrResumeContent (unbuffered): play from beginning | " + state.currentContentVideoUrl());
                        player.startPlayback();
                    }
                }
            }

            adfw.Events.dispatchEvent(adfw.Events.CONTENT_START, {
                ms: resumeTime,
                url: state.currentContentVideoUrl()
            });
            adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TYPE, {
                type: "content"
            });
        }
        catch (e) {
            error("Error while attempting to play content: " + e);
            error(adfw.Utils.getInspectionString(e));
            internalOnActivePlayerProblem(adfw.PlayerAdapter.Events.PLAYER_EXCEPTION, {
                message: e
            });
        }
    };

    //Called during the last ad in an adbreak, starts buffering the content in preparation of resumption.
    var tryBufferingContent = function () {
    	log("tryBufferingContent");
        if (!state.currentContentVideoUrl() || player.getBufferedVideoUrl() || alreadyTriedToBufferContent) {
            return false;
        }
        else if (!adfw.Config.get("PREBUFFER_ENABLED")) {
            return false;
        } else {

            var beforeContentStartFunction = state.beforeContentStart();
            var resumeTime = state.currentContentPlayhead() ? Math.max(state.currentContentPlayhead() - (adfw.Config.get("REWIND_BEFORE_RESUME") * 1000), 0) : 0;
            state.currentBufferedLinearAd(null);
            state.currentBufferedLinearAdBreak(null);

            var contentUrl = state.currentContentVideoUrl();

            if (!disableContentControl) {
                //If the content Url does not specify a STARTBITRATE, modify the Url to be the previously recorded content bitrate
                var startBitrate = state.contentBitrate();
                //log("Loaded Content Bitrate: " + startBitrate);
                if (!startBitrate) {
                    //If no previous bitrate was recorded, try to get it from the current ad
                    startBitrate = player.Execute("GetCurrentBitrates");
                }
                var lowerCaseContent = contentUrl.toLowerCase();

                //If content is of a streaming protocol and we have recorded a preferred bitrate, prebuffer the content using the saved bitrate
                if (
                    adfw.Config.get("ADAPTIVE_CONTENT") === true
                    && state.currentPlaybackType() === adfw.PlaybackState.PlaybackType.LINEAR_AD
                    && typeof(startBitrate) === "number" && startBitrate > 1000
                    && lowerCaseContent.indexOf("startbitrate") < 0
                    && (lowerCaseContent.indexOf("component=hls") > 0 || lowerCaseContent.indexOf("component=smooth") > 0 || lowerCaseContent.indexOf("component=dash") > 0)) {
                    startBitrate = Math.round(startBitrate * adfw.Config.get("START_BITRATE_AUTO_RATIO"));
                    if (typeof startBitrate === "number" && startBitrate > 1000) {
                        contentUrl += "|STARTBITRATE=" + startBitrate;
                    }
                }

                //log("Prebuffer content at " + resumeTime + "ms: " + contentUrl);
                player.startBufferingVideo(contentUrl, resumeTime, beforeContentStartFunction);
            }
            else {
                //Do nothing
            }
            alreadyTriedToBufferContent = true;
            adfw.Events.dispatchEvent(adfw.Events.CONTENT_PREBUFFER_START, {
                ms: resumeTime,
                url: contentUrl,
            });

            //PreLoad the scheduled nonLinearAD
            var nonlinearAd = state.currentNonLinearAd();
            var nonlinearCreative = null;
            var variation = null;
            if (nonlinearAd) {
                nonlinearCreative = nonlinearAd.getNonLinearCreative();
            }
            if (nonlinearCreative) {
                variation = nonlinearCreative.getBestVariation();
            }
            if (variation && variation.apiFramework == 'VPAID') {
                prebufferNextNonLinearVPAIDAd(nonlinearAd);
            }

        }
    };

    //This function is called at the end of a midroll. It causes the resumption of the content if we are currently playing a linear ad.
    var resumeFromMidroll = function () {
    	log("resumeFromMidroll"); 
        if (state.currentPlaybackType() !== adfw.PlaybackState.PlaybackType.CONTENT) {
            playOrResumeContent();
        }
    };

    //Handles the playback time updates during content playback. This function is complex because it has to do prebuffering and triggering of midrolls.
    var contentOnCurrentPlaytime = function (playtime) { 
        var nextAd = null;
        var linearCreative = null;
        var currentCreative = null;
        var mediaFile = null;

        state.currentContentPlayhead(playtime);
        schedule.notifyContentPlayhead(playtime, getDuration());
        adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TIME, {
            ms: playtime
        });
        adfw.Events.dispatchEvent(adfw.Events.CONTENT_PLAYBACK_TIME, {
            ms: playtime
        });

        if (state.isTrickPlaying()) {
            //Do not trigger midrolls
        }
        else {
            //Check midrolls and play/prebuffer them if necessary, giving a callback function instruction to resume this content upon completion
            var midrollWillPlay = false;

            var nextMidroll = null;

            var nonLinearAd = state.currentNonLinearAd();
            var nonLinearCreative = null;
            if (nonLinearAd) {
                nonLinearCreative = nonLinearAd.getNonLinearCreative();
            }
            try {
                nextMidroll = schedule.getNextUnplayedMidroll(state.currentContentPlayhead(), getDuration());
            } catch (e) {
                error(e);
            }
            //log("Next Midroll: " + nextMidroll);

            //Disable Ad Insertion logic
            if (nextMidroll && adfw.Config.get("DISABLE_AD_INSERTION") === true) {
                adfw.Events.dispatchEvent("DEBUG_MESSAGE", {
                    message: "Skipping ad break: Ad insertion has been disabled"
                });
                nextMidroll.setSkipped();
                nextMidroll = null;
            }

            //Prebuffering logic
            if (nextMidroll) {
                if (nonLinearCreative) {
                    var midrollInterruptsDisplayTime = nextMidroll.test(state.currentContentPlayhead() + nonLinearCreative.getBestVariation().calculateDisplayTime(), getDuration());
                    if (!nextMidroll.getNextAd() || !nextMidroll.getNextAd().getLinearCreative()) {
                        midrollInterruptsDisplayTime = false;
                    }
                    //If there's no midroll coming up soon, this is a good time to play a nonlinear
                    //log("test: " + (state.currentContentPlayhead() + nonLinearCreative.getBestVariation().calculateDisplayTime()) + " | " + getDuration());
                    if (!midrollInterruptsDisplayTime) {
                        playNonLinearAd();
                    } else {
                        log("skip nonlinear due to midroll interruption");
                    }
                }
                if (nextMidroll.test(state.currentContentPlayhead(), getDuration())) {
                    var triggerMS = nextMidroll.getOffset().getTriggerMS(getDuration());

                    if (nextMidroll === state.currentResolvingAdBreak()) {
                        //Already waiting for this ad break - just return
                        return false;
                    }
                    state.currentResolvingAdBreak(nextMidroll);
                    nextMidroll.resolve();
                    nextMidroll.whenReady(function () {
                        state.currentResolvingAdBreak(null);
                        if (!nextMidroll.isPlayed()) {

                            var isLinear = nextMidroll.isLinear();

                            if (isLinear) {

                                //Record content bitrate so that we can resume to it
                                var contentBitrate = player.Execute("GetCurrentBitrates");
                                if (typeof contentBitrate === "number") {
                                    state.contentBitrate(contentBitrate);
                                }

                                if (disableContentControl) {
                                    refreshContentStopDeferred();
                                }
                                state.currentPlaybackType(adfw.PlaybackState.PlaybackType.LINEAR_AD);

                                adfw.Events.dispatchEvent(adfw.Events.PLAYBACK_TYPE, {
                                    type: "midroll"
                                });
                                adfw.Events.dispatchEvent(adfw.Events.CONTENT_SUSPEND);
                                if (disableContentControl) {
                                    contentStopDeferred.promise
                                        .then(function () {
                                            log("contentStopPromise fulfilled. Playing ad break...");
                                            playAdBreak(nextMidroll, resumeFromMidroll);
                                        })
                                        .catch(function (e) {
                                            error("contentStopPromise failed: " + e);
                                            nextMidroll.setSkipped();
                                        });
                                }
                                else {
                                    log("Stopping player for a midroll!");
                                    player.stop();
                                    playAdBreak(nextMidroll, resumeFromMidroll);
                                }
                            }
                            else {
                                playAdBreak(nextMidroll, resumeFromMidroll);
                            }

                            checkRepeatingAdBreak(nextMidroll, triggerMS);
                        }
                    });

                } else if (nextMidroll.getNextAd() && nextMidroll.getNextAd().getLinearCreative() && nextMidroll.test((state.currentContentPlayhead() + adfw.Config.get("CONTENT_PREBUFFER_ADVANCE_TIME")), getDuration())) {
                    nextMidroll.resolve();
                    tryBufferingAd(nextMidroll, nextMidroll.getNextAd());
                }

            } else {
                //No midrolls coming up anymore? Let's play any NonLinears we have left
                if (nonLinearCreative) {
                    playNonLinearAd();
                }
                //Let's buffer any postrolls we have
                if ((getDuration() - state.currentContentPlayhead()) < adfw.Config.get("CONTENT_PREBUFFER_ADVANCE_TIME")) {
                    //No more midrolls will play during the course of the content - let's buffer a postroll
                    var nextPostroll = schedule.getNextUnplayedPostroll();
                    if (nextPostroll && nextPostroll.getNextAd() && nextPostroll.getNextAd().getLinearCreative()) {
                        tryBufferingAd(nextPostroll, nextPostroll.getNextAd());
                    }
                }
            }
        }


    };

    //Checks if an adbreak is repeating. If it is, it will schedule the repeating adbreak based on the trigger time.
    var checkRepeatingAdBreak = function (oldBreak, triggerTime) {
    	log("checkRepeatingAdBreak");
        if (oldBreak.isRepeating()) {
            oldBreak.createRepeatingAdBreakPromise(triggerTime)
                .then(function (newAdBreak) {
                    //log("Scheduling repeat ad break: " + newAdBreak);
                    schedule.scheduleAdbreak(newAdBreak);
                    if (oldBreak) {
                        oldBreak.deleteRepeatData();
                    }
                })
                .catch(function () {
                    if (oldBreak) {
                        oldBreak.deleteRepeatData();
                    }
                });
        }
    };

    var setCompanionAdHandler = function (callback) {
        log("setCompanionAdHandler");
        if(typeof callback !== "function")
           throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR',"The parameter is not a function format. It can't be set.");
        adfw.Events.addListener(adfw.Events.COMPANION_ADS_CREATIVE_DETECTED, function (evt, params) {
            callback(evt, params);
        });
    };

    var listenForVPAIDDone = function (callback, ad) {
        log("listenForVPAIDDone executed on: " + ad.uid);

        var completeFunc = function (evt, params) {
            if (ad === params.ad) {
                log("CONTROLLER: VPAID_COMPLETE: " + ad.uid);

                callback();
            } else {
                log("WRONG ONE!!! : " + ad.uid);
            }
        };

        var errorFunc = function (evt, params) {
            if (ad === params.ad) {
                log("CONTROLLER: VPAID_ERROR");
                var errorMessage = "VPAID ERROR";

                if (params.errorMessage) {
                    errorMessage = params.errorMessage;
                }
                handleVSuitePlaybackError(state.currentAdBreak(), ad, 901, errorMessage, state.currentContentPlayhead(), null);
                callback();
            } else {
                log("WRONG ONE(e): " + ad.uid);
            }
        };

        adfw.Events.addListener(adfw.Events.VPAID_COMPLETE, completeFunc, true);
        adfw.Events.addListener(adfw.Events.VPAID_ERROR, errorFunc, true);
    };

    var handleCompanionAdViewElementClick = function (PriorityCompanionResource) {
        log("handleCompanionAdViewElementClick");
        var clickThrough = PriorityCompanionResource.clickThrough;
        var clickTrackers = PriorityCompanionResource.clickTrackers;

        //Handle Click for Static Resource
        if (clickThrough && PriorityCompanionResource.getType() == 'STATIC_IMAGE') {
            //OPEN IFRAME
            adfw.VisualOverlay.openIFrame(clickThrough);
            //Handle Click for HTML Resource
        } else if (PriorityCompanionResource.getType() == 'HTML') {
            //Extracting url from Atag
            var regex_a_tag = /href=['"]([^'">]+)/i;
            clickThrough = regex_a_tag.exec(PriorityCompanionResource.content);
            if (clickThrough) {
                //OPEN IFRAME
                adfw.VisualOverlay.openIFrame(clickThrough[1]);
            }
        }
        if (clickTrackers) {
            //SEND TRACKING
            PriorityCompanionResource.handleClick();
        }
    };

    //*******************************************************************************************************
    //OTHER/UTILITY

    //Immediately disable ad insertion, cutting off any ads in progress
    var disableAdInsertion = function (allowCurrentAdbreakToFinish) {

        log("Disabling ad insertion...");

        adfw.Config.set("DISABLE_AD_INSERTION", true);

        //Cancel any linear ads playing
        if (allowCurrentAdbreakToFinish !== true && state.isLinearAdMode()) {
            log("Stopping current ad and resuming content: " + state.currentContentVideoUrl());
            player.stop();
            if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper) {
                adfw.VisualOverlay.VPAIDWrapper.stopAd();
            }
            if (state.currentContentVideoUrl()) {
                playOrResumeContent();
            }
        }

        log("Disabled ad insertion...");

    };

    var enableAdInsertion = function () {
        log("Enabling ad insertion...");
        adfw.Config.set("DISABLE_AD_INSERTION", false);
    };

    //Send VSuite Errors to the ad server
    var handleVSuitePlaybackError = function (adbreak, ad, code, message, contentPlayhead, adAssetURI) {
        try {
            var eMessage = message ? message : adfw.Errors[code];
            if (adbreak) {
                adbreak.handleError(code, eMessage, contentPlayhead, adAssetURI);
            } else {
                error("handleVSuitePlaybackError called with null adbreak");
            }
            if (ad) {
                ad.handleError(code, eMessage, contentPlayhead, adAssetURI);
            } else {
                error("handleVSuitePlaybackError called with null ad");
            }

            adfw.Events.dispatchEvent("VSUITE_PLAYBACK_ERROR", {
                message: eMessage,
                code: code,
                url: adAssetURI,
                contentPlayhead: contentPlayhead,
            });
            log("VSuite Playback Error: " + eMessage);
        } catch (e) {
            error("Failed to dispatch error: " + e);
        }
    };

    //Event handlers for VAST Events
    var onAdBreakStart = function () {
        state.currentAdBreak().handleBreakStart();
    };
    var onAdBreakEnd = function () {
        state.currentAdBreak().handleBreakEnd();
    };
    var onLinearAdProgress = function () {


        //Cancel any ad timeout checking
        clearLinearAdTimeout();

        if (!state.currentLinearAd()) {
            return false;
        }

        state.currentLinearAd().handleImpression(state.currentContentPlayhead(), state.currentVideoUrl());
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleProgress("progress", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdComplete = function () {
        adfw.Events.dispatchEvent(adfw.Events.LINEAR_AD_COMPLETE);
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("complete", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdSkip = function () {
        //Cancel any ad timeout checking
        clearLinearAdTimeout();
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("skip", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdClose = function () {
        //Cancel any ad timeout checking
        clearLinearAdTimeout();
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("closeLinear", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
            state.currentLinearCreative().handleEvent("close", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdMute = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("mute", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdUnmute = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("unmute", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdPause = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("pause", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdRewind = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("rewind", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdResume = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("resume", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdExpand = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("expand", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdCollapse = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("collapse", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdFullscreen = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("fullscreen", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdExitFullscreen = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("exitFullscreen", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };
    var onLinearAdAcceptInvitation = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("acceptInvitationLinear", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };

    var onCompanionAdProgress = function () {
        if (state.currentLinearCreative()) {
            state.currentLinearCreative().handleEvent("progress", state.currentAdPlayhead(), getDuration(), state.currentContentPlayhead(), state.currentVideoUrl());
        }
    };

    //Returns the SEFAdapter object (for fine player control)
    var getPlayer = function () {
        return player;
    };

    //State getters
    var getPlayhead = function () {
        return state.currentPlayhead();
    };
    var getContentPlayhead = function () {
        return state.currentContentPlayhead();
    };
    var getAdPlayhead = function () {
        return state.currentAdPlayhead();
    };
    var isPlayingLinearAd = function () {
        return state.isLinearAdMode();
    };
    var getState = function () {
        return state;
    };
    var getSchedule = function () {
        return schedule;
    };

    //SEF Adapter Forwarder
    var getDisplayRect = function () {
        return player.getDisplayRect();
    };
    var setDisplayRect = function (x, y, w, h) {
    	if(typeof(x) !== "number" || typeof(y) !== "number" || typeof(w) !== "number" || typeof(h) !== "number")
    		throw new adfw.Utils.WebAPIExceptionForAdfw('TYPE_MISMATCH_ERR', "(" + x + ", " + y + ", " + w + ", " + h + ") is not the right format" );
        player.setDisplayRect(x, y, w, h);
    };
    var getDisplayRectRatio = function () {
        return player.getDisplayRectRatio();
    };
    var setDisplayRectRatio = function (x, y, w, h) {
    	if(typeof(x) !== "number" || typeof(y) !== "number" || typeof(w) !== "number" || typeof(h) !== "number")
    		throw( "(" + x + ", " + y + ", " + w + ", " + h + ") is not the right format" );
        player.setDisplayRectRatio(x, y, w, h);
    };
    var getRelativeDisplayRect = function () {
        return player.getRelativeDisplayRect();
    };
    var setRelativeDisplayRect = function (x, y, w, h) {
        player.setRelativeDisplayRect(x, y, w, h);
    };

    var getDuration = function () {
        if (adfw.VisualOverlay && adfw.VisualOverlay.VPAIDWrapper && true === adfw.VisualOverlay.VPAIDWrapper.getAdLinear()) {
            return adfw.VisualOverlay.VPAIDWrapper.VPAIDDuration ? Math.round(adfw.VisualOverlay.VPAIDWrapper.VPAIDDuration * 1000) : adfw.VisualOverlay.VPAIDWrapper.VPAIDDuration;
        }
        else if (disableContentControl && getCurrentPlaybackType() === adfw.PlaybackState.PlaybackType.CONTENT) {
            return mockContentDuration;
        }
        else {
            return player.getDuration();
        }
    };

    //Just some error/logging functions
    var log = function (msg) {
        adfw.Utils.log(msg, "[ADFW CORE]");
    };
    var error = function (msg) {
        adfw.Utils.error(msg, "[ADFW CORE]");
    };

    //Return public functions
    return {
        //General Functions
        initialize: initialize,

        open: open,
        startPlayback: startPlayback,
        setAdInsertionPolicy: setAdInsertionPolicy,
        setBeforeContentStartHandler: setBeforeContentStartHandler,
        setBeforeLinearAdStartHandler: setBeforeLinearAdStartHandler,
        setAfterContentStartHandler: setAfterContentStartHandler,
        setAfterLinearAdStartHandler: setAfterLinearAdStartHandler,

        changeContentUrl: changeContentUrl,
        setLinearAdUrlModifier: setLinearAdUrlModifier,
        setTrackingUrlModifier: setTrackingUrlModifier,
        setErrorUrlModifier: setErrorUrlModifier,

        insertAdBreak: insertAdBreak,
        insertAdBreakFromVast: insertAdBreakFromVast,
        cancelScheduledAd: cancelScheduledAd,
        cancelNextScheduledAd: cancelNextScheduledAd,
        playAdImmediately: playAdImmediately,

        bufferStandaloneAd: bufferStandaloneAd,
        playBufferedStandaloneAd: playBufferedStandaloneAd,

        getCurrentPlaybackType: getCurrentPlaybackType,

        //Player (playback) functionality
        stop: stop,
        pause: pause,
        resume: resume,
        jumpForward: jumpForward,
        jumpBackward: jumpBackward,
        signalTrickPlayStart: signalTrickPlayStart,
        signalTrickPlayStop: signalTrickPlayStop,
        signalMuted: signalMuted,
        signalUnmuted: signalUnmuted,
        getDuration: getDuration,
        setDisplayRect: setDisplayRect,
        getDisplayRect: getDisplayRect,
        setDisplayRectRatio: setDisplayRectRatio,
        getDisplayRectRatio: getDisplayRectRatio,
        setRelativeDisplayRect: setRelativeDisplayRect,
        getRelativeDisplayRect: getRelativeDisplayRect,
        getPlayhead: getPlayhead,
        getContentPlayhead: getContentPlayhead,
        setContentPlayhead: setContentPlayhead,
        offsetContentPlayhead: offsetContentPlayhead,
        getAdPlayhead: getAdPlayhead,
        getAdBreakTimes: getAdBreakTimes,
        getPlayableAdBreakTimes: getPlayableAdBreakTimes,
        isPlayingLinearAd: isPlayingLinearAd,
        disableAdInsertion: disableAdInsertion,
        enableAdInsertion: enableAdInsertion,
        setCompanionAdHandler: setCompanionAdHandler,

        //Other
        getPlayer: getPlayer,
        getVersion: getVersion,

        //For Disable Content Control
        signalContentStopped: signalContentStopped,
        signalContentPlaybackTime: signalContentPlaybackTime,
        signalContentPlaybackComplete: signalContentPlaybackComplete,

        //Needs documentation


        //Absolutely should NOT be public, these are exposed to allow other parts of the framework to control the Controller
        handleIFrameOpen: handleIFrameOpen,
        handleIFrameClose: handleIFrameClose,
        resumeFromMidroll: resumeFromMidroll,
        handleVSuitePlaybackError: handleVSuitePlaybackError,
        handleCompanionAdViewElementClick: handleCompanionAdViewElementClick,
        getState: getState,
        getSchedule: getSchedule,
        prebufferingForVPaid: prebufferingForVPaid,
    };
}());

if (typeof adfw.DOMParser === 'undefined') {
    throw new Error("Failed to load DOMParser!");
}

//Realias AdFramework properties to be compliant with Tizen WebAPI standards
adfw.controller = adfw.Controller;
adfw.parser = adfw.Parser;
adfw.config = adfw.Config;
adfw.events = adfw.Events;
adfw.utils = adfw.Utils;
adfw.platformutils = adfw.PlatformUtils;
adfw.visualoverlay = adfw.VisualOverlay;
adfw.playeradapter = adfw.PlayerAdapter;


return adfw;
})
;
(function(){var whitelist=['adinfo','allshare','appcgplayer','appcommon','audiocapture','avinfo','billing','certmanager','contentsinfo','displayrotator','drminfo','happycast','logging','microphone','network','oobepromotion','productinfo','samsunghealth','securityapp','sso','tvinfo','was','widgetdata','systeminfo','aisound','terms'];for(var i in whitelist)if(webapis.hasOwnProperty(whitelist[i]))Object.defineProperty(webapis,whitelist[i],{writable:false});}());